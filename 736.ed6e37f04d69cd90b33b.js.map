{"version":3,"file":"736.ed6e37f04d69cd90b33b.js","mappings":"oKAIA,SAASA,EAAmBC,EAAOC,EAAWC,GAC1C,MAAMC,GAAgB,OAAcH,GAASA,GAAQ,QAAYA,GAEjE,OADAG,EAAcC,OAAM,OAAmB,GAAID,EAAeF,EAAWC,IAC9DC,EAAcE,SACzB,C,iLCGA,MAAMC,EAAe,CAACN,EAAOO,IAEZ,WAATA,MAKiB,iBAAVP,IAAsBQ,MAAMC,QAAQT,OAE1B,iBAAVA,IACNU,EAAA,EAAQC,KAAKX,IAAoB,MAAVA,GACvBA,EAAMY,WAAW,UCtB1B,MAAMC,EAAab,GAAoB,OAAVA,EAC7B,SAASc,EAAiBb,GAAW,OAAEc,EAAM,WAAEC,EAAa,QAAUC,GAClE,MAAMC,EAAoBjB,EAAUkB,OAAON,GACrCO,EAAQL,GAAyB,SAAfC,GAAyBD,EAAS,GAAM,EAC1D,EACAG,EAAkBG,OAAS,EACjC,OAAQD,QAA2BE,IAAlBL,EAEXA,EADAC,EAAkBE,EAE5B,CCMA,MAAMG,EACF,WAAAC,EAAY,SAAEC,GAAW,EAAI,MAAEC,EAAQ,EAAC,KAAEC,EAAO,YAAW,OAAEZ,EAAS,EAAC,YAAEa,EAAc,EAAC,WAAEZ,EAAa,UAAWd,IAE/G2B,KAAKC,WAAY,EACjBD,KAAKE,qBAAsB,EAC3BF,KAAKG,UAAY,IAAKC,MACtBJ,KAAK3B,QAAU,CACXuB,WACAC,QACAC,OACAZ,SACAa,cACAZ,gBACGd,GAEP2B,KAAKK,uBACT,CAWA,aAAAC,GACI,OAAKN,KAAKO,YAEHP,KAAKO,WAAaP,KAAKG,UA/BZ,GAgCZH,KAAKO,WAFAP,KAAKG,SAIpB,CAMA,YAAIK,GAIA,OAHKR,KAAKS,WAAcT,KAAKE,sBACzB,SAEGF,KAAKS,SAChB,CAMA,mBAAAC,CAAoBtC,EAAWgB,GAC3BY,KAAKO,WAAa,IAAKH,MACvBJ,KAAKE,qBAAsB,EAC3B,MAAM,KAAExB,EAAI,KAAEoB,EAAI,SAAEa,EAAQ,MAAEd,EAAK,WAAEe,EAAU,SAAEC,EAAQ,YAAEC,GAAiBd,KAAK3B,QAKjF,IAAKyC,IC5Db,SAAoB1C,EAAWM,EAAMoB,EAAMa,GAMvC,MAAMI,EAAiB3C,EAAU,GACjC,GAAuB,OAAnB2C,EACA,OAAO,EAMX,GAAa,YAATrC,GAA+B,eAATA,EACtB,OAAO,EACX,MAAMsC,EAAiB5C,EAAUA,EAAUoB,OAAS,GAC9CyB,EAAqBxC,EAAasC,EAAgBrC,GAClDwC,EAAqBzC,EAAauC,EAAgBtC,GAGxD,OAFA,OAAQuC,IAAuBC,EAAoB,6BAA6BxC,WAAcqC,UAAuBC,OAAoBD,+DAA4EA,8BAA2CC,oCAE3PC,IAAuBC,KA9BhC,SAA6B9C,GACzB,MAAM+C,EAAU/C,EAAU,GAC1B,GAAyB,IAArBA,EAAUoB,OACV,OAAO,EACX,IAAK,IAAI4B,EAAI,EAAGA,EAAIhD,EAAUoB,OAAQ4B,IAClC,GAAIhD,EAAUgD,KAAOD,EACjB,OAAO,CAEnB,CAyBYE,CAAoBjD,KACb,WAAT0B,IAAqB,QAAYA,KAAUa,EACrD,CDkC6BW,CAAWlD,EAAWM,EAAMoB,EAAMa,GAAW,CAE9D,GAAI,IAAsBQ,UAAYtB,EAKlC,OAJAgB,GACIA,EAAS5B,EAAiBb,EAAW4B,KAAK3B,QAASe,IACvDwB,GAAcA,SACdZ,KAAKuB,yBAKLvB,KAAK3B,QAAQmD,SAAW,CAEhC,CACA,MAAMC,EAAoBzB,KAAK0B,aAAatD,EAAWgB,IAC7B,IAAtBqC,IAEJzB,KAAKS,UAAY,CACbrC,YACAgB,mBACGqC,GAEPzB,KAAK2B,iBACT,CACA,cAAAA,GAAmB,CAMnB,IAAAC,CAAKC,EAASC,GACV,OAAO9B,KAAK+B,uBAAuBH,KAAKC,EAASC,EACrD,CACA,OAAAE,GACIhC,KAAK3B,QAAQyB,KAAO,YACpBE,KAAK3B,QAAQ4D,KAAO,QACxB,CACA,qBAAA5B,GACIL,KAAK+B,uBAAyB,IAAIG,SAASL,IACvC7B,KAAKuB,uBAAyBM,CAAO,GAE7C,E,4CE/GJ,SAASM,EAAsBC,EAAcC,EAAGlB,GAC5C,MAAMmB,EAAQC,KAAKC,IAAIH,EAFI,EAEwB,GACnD,OAAO,OAAkBlB,EAAUiB,EAAaE,GAAQD,EAAIC,EAChE,CCNA,MAAMG,EAES,IAFTA,EAGO,GAHPA,EAII,EAJJA,EAKQ,EALRA,EAOQ,IAPRA,EAQM,GARNA,EASc,GATdA,EAWS,CACPC,SAAU,IACVC,QAAS,GAbXF,EAeS,CACPC,SAAU,KACVC,QAAS,IAjBXF,EAoBW,IApBXA,EAqBW,GArBXA,EAsBU,IAtBVA,EAuBU,ECnBVG,EAAU,KAChB,SAASC,GAAW,SAAErB,EAAWiB,EAAuB,OAAEK,EAASL,EAAqB,SAAE9B,EAAW8B,EAAuB,KAAEM,EAAON,IACjI,IAAIO,EACAC,GACJ,OAAQzB,IAAY,OAAsBiB,GAA6B,8CACvE,IAAIS,EAAe,EAAIJ,EAIvBI,GAAe,EAAAC,EAAA,GAAMV,EAA2BA,EAA2BS,GAC3E1B,GAAW,EAAA2B,EAAA,GAAMV,EAA4BA,GAA4B,OAAsBjB,IAC3F0B,EAAe,GAIfF,EAAYI,IACR,MAAMC,EAAmBD,EAAeF,EAClCI,EAAQD,EAAmB7B,EAC3B+B,EAAIF,EAAmB1C,EACvB6C,EAAIC,EAAgBL,EAAcF,GAClCQ,EAAInB,KAAKoB,KAAKL,GACpB,OAAOV,EAAWW,EAAIC,EAAKE,CAAC,EAEhCT,EAAcG,IACV,MACME,EADmBF,EAAeF,EACP1B,EAC3BoC,EAAIN,EAAQ3C,EAAWA,EACvBkD,EAAItB,KAAKuB,IAAIZ,EAAc,GAAKX,KAAKuB,IAAIV,EAAc,GAAK5B,EAC5DuC,EAAIxB,KAAKoB,KAAKL,GACdU,EAAIP,EAAgBlB,KAAKuB,IAAIV,EAAc,GAAIF,GAErD,QADgBF,EAASI,GAAgBR,EAAU,GAAK,EAAI,KACzCgB,EAAIC,GAAKE,GAAMC,CAAC,IAOvChB,EAAYI,GACEb,KAAKoB,KAAKP,EAAe5B,KACxB4B,EAAezC,GAAYa,EAAW,GAC1C,KAEXyB,EAAcG,GACAb,KAAKoB,KAAKP,EAAe5B,IACIA,EAAWA,GAAvCb,EAAWyC,KAI9B,MACMA,EAmBV,SAAyBJ,EAAUC,EAAYgB,GAC3C,IAAIC,EAASD,EACb,IAAK,IAAI7C,EAAI,EAAGA,EAAI+C,EAAgB/C,IAChC8C,GAAkBlB,EAASkB,GAAUjB,EAAWiB,GAEpD,OAAOA,CACX,CAzByBE,CAAgBpB,EAAUC,EAD1B,EAAIzB,GAGzB,GADAA,GAAW,OAAsBA,GAC7B6C,MAAMjB,GACN,MAAO,CACHkB,UAAW7B,EACX8B,QAAS9B,EACTjB,YAGH,CACD,MAAM8C,EAAY/B,KAAKuB,IAAIV,EAAc,GAAKL,EAC9C,MAAO,CACHuB,YACAC,QAAwB,EAAfrB,EAAmBX,KAAKiC,KAAKzB,EAAOuB,GAC7C9C,WAER,CACJ,CACA,MAAM2C,EAAiB,GAQvB,SAASV,EAAgBL,EAAcF,GACnC,OAAOE,EAAeb,KAAKiC,KAAK,EAAItB,EAAeA,EACvD,CC3EA,MAAMuB,EAAe,CAAC,WAAY,UAC5BC,EAAc,CAAC,YAAa,UAAW,QAC7C,SAASC,EAAatG,EAASuG,GAC3B,OAAOA,EAAKC,MAAMC,QAAyBrF,IAAjBpB,EAAQyG,IACtC,CAuCA,SAASC,EAAOC,EAA0BvC,EAA+BK,EAASL,GAC9E,MAAMpE,EAA6C,iBAA5B2G,EACjB,CACEC,eAAgBD,EAChB5G,UAAW,CAAC,EAAG,GACf0E,UAEFkC,EACN,IAAI,UAAEE,EAAS,UAAEC,GAAc9G,EAC/B,MAAM+G,EAAS/G,EAAQD,UAAU,GAC3BiH,EAAShH,EAAQD,UAAUC,EAAQD,UAAUoB,OAAS,GAKtD8F,EAAQ,CAAEC,MAAM,EAAOpH,MAAOiH,IAC9B,UAAEd,EAAS,QAAEC,EAAO,KAAExB,EAAI,SAAEvB,EAAQ,SAAEb,EAAQ,uBAAE6E,GAtD1D,SAA0BnH,GACtB,IAAIoH,EAAgB,CAChB9E,SAAU8B,EACV6B,UAAW7B,EACX8B,QAAS9B,EACTM,KAAMN,EACN+C,wBAAwB,KACrBnH,GAGP,IAAKsG,EAAatG,EAASqG,IACvBC,EAAatG,EAASoG,GACtB,GAAIpG,EAAQ4G,eAAgB,CACxB,MAAMA,EAAiB5G,EAAQ4G,eACzBS,EAAQ,EAAInD,KAAKoD,IAAwB,IAAjBV,GACxBX,EAAYoB,EAAOA,EACnBnB,EAAU,GACZ,EAAApB,EAAA,GAAM,IAAM,EAAG,GAAK9E,EAAQyE,QAAU,IACtCP,KAAKiC,KAAKF,GACdmB,EAAgB,IACTA,EACH1C,KAAMN,EACN6B,YACAC,UAER,KACK,CACD,MAAMqB,EAAU/C,EAAWxE,GAC3BoH,EAAgB,IACTA,KACAG,EACH7C,KAAMN,GAEVgD,EAAcD,wBAAyB,CAC3C,CAEJ,OAAOC,CACX,CAiBsFI,CAAiB,IAC5FxH,EACHsC,WAAW,OAAsBtC,EAAQsC,UAAY,KAEnDmF,EAAkBnF,GAAY,EAC9BuC,EAAeqB,GAAW,EAAIhC,KAAKiC,KAAKF,EAAYvB,IACpDgD,EAAeV,EAASD,EACxBY,GAAsB,OAAsBzD,KAAKiC,KAAKF,EAAYvB,IAQlEkD,EAAkB1D,KAAK2D,IAAIH,GAAgB,EAOjD,IAAII,EACJ,GAPAjB,IAAcA,EAAYe,EACpBxD,EAAyBC,SACzBD,EAAyBE,SAC/BwC,IAAcA,EAAYc,EACpBxD,EAAyBC,SACzBD,EAAyBE,SAE3BO,EAAe,EAAG,CAClB,MAAMkD,EAAc3C,EAAgBuC,EAAqB9C,GAEzDiD,EAAiB9D,IACb,MAAMW,EAAWT,KAAKoB,KAAKT,EAAe8C,EAAsB3D,GAChE,OAAQgD,EACJrC,IACO8C,EACC5C,EAAe8C,EAAsBD,GACrCK,EACA7D,KAAK8D,IAAID,EAAc/D,GACvB0D,EAAexD,KAAK+D,IAAIF,EAAc/D,GAAI,CAE9D,MACK,GAAqB,IAAjBa,EAELiD,EAAiB9D,GAAMgD,EACnB9C,KAAKoB,KAAKqC,EAAsB3D,IAC3B0D,GACID,EAAkBE,EAAsBD,GAAgB1D,OAEpE,CAED,MAAMkE,EAAoBP,EAAsBzD,KAAKiC,KAAKtB,EAAeA,EAAe,GACxFiD,EAAiB9D,IACb,MAAMW,EAAWT,KAAKoB,KAAKT,EAAe8C,EAAsB3D,GAE1DmE,EAAWjE,KAAKkE,IAAIF,EAAoBlE,EAAG,KACjD,OAAQgD,EACHrC,IACK8C,EACE5C,EAAe8C,EAAsBD,GACrCxD,KAAKmE,KAAKF,GACVD,EACIR,EACAxD,KAAKoE,KAAKH,IAClBD,CAAkB,CAElC,CACA,MAAMK,EAAY,CACdC,mBAAoBrB,GAAyBhE,GAAmB,KAChEsF,KAAOzE,IACH,MAAMlB,EAAUgF,EAAc9D,GAC9B,GAAKmD,EAmBDF,EAAMC,KAAOlD,GAAKb,MAnBO,CACzB,IAAIuF,EAAkB,EAMlB7D,EAAe,IACf6D,EACU,IAAN1E,GACM,OAAsByD,GACtB3D,EAAsBgE,EAAe9D,EAAGlB,IAEtD,MAAM6F,EAA2BzE,KAAK2D,IAAIa,IAAoB7B,EACxD+B,EAA+B1E,KAAK2D,IAAIb,EAASlE,IAAYgE,EACnEG,EAAMC,KACFyB,GAA4BC,CACpC,CAKA,OADA3B,EAAMnH,MAAQmH,EAAMC,KAAOF,EAASlE,EAC7BmE,CAAK,EAEhB4B,SAAU,KACN,MAAML,EAAqBtE,KAAKkE,KAAI,QAAsBG,GAAY,MAChEO,GAAS,SAAsBC,GAAaR,EAAUE,KAAKD,EAAqBO,GAAUjJ,OAAO0I,EAAoB,IAC3H,OAAOA,EAAqB,MAAQM,CAAM,GAGlD,OAAOP,CACX,CChKA,SAASS,GAAQ,UAAEjJ,EAAS,SAAEuC,EAAW,EAAG,MAAE2G,EAAQ,GAAG,aAAEC,EAAe,IAAG,cAAEC,EAAgB,GAAE,gBAAEC,EAAkB,IAAG,aAAEC,EAAY,IAAEjB,EAAG,IAAEjE,EAAG,UAAE2C,EAAY,GAAG,UAAED,IAC/J,MAAME,EAAShH,EAAU,GACnBkH,EAAQ,CACVC,MAAM,EACNpH,MAAOiH,GAGLuC,EAAmBC,QACTnI,IAARgH,EACOjE,OACC/C,IAAR+C,GAEGD,KAAK2D,IAAIO,EAAMmB,GAAKrF,KAAK2D,IAAI1D,EAAMoF,GAD/BnB,EAC0CjE,EAEzD,IAAIqF,EAAYP,EAAQ3G,EACxB,MAAMmH,EAAQ1C,EAASyC,EACjBxC,OAA0B5F,IAAjBiI,EAA6BI,EAAQJ,EAAaI,GAK7DzC,IAAWyC,IACXD,EAAYxC,EAASD,GACzB,MAAM2C,EAAa1F,IAAOwF,EAAYtF,KAAKoB,KAAKtB,EAAIkF,GAC9CS,EAAc3F,GAAMgD,EAAS0C,EAAU1F,GACvC4F,EAAiB5F,IACnB,MAAMiB,EAAQyE,EAAU1F,GAClB6F,EAASF,EAAW3F,GAC1BiD,EAAMC,KAAOhD,KAAK2D,IAAI5C,IAAU6B,EAChCG,EAAMnH,MAAQmH,EAAMC,KAAOF,EAAS6C,CAAM,EAQ9C,IAAIC,EACAC,EACJ,MAAMC,EAAsBhG,IAjCN,IAACuF,KAkCAtC,EAAMnH,WAlCSsB,IAARgH,GAAqBmB,EAAInB,QAAiBhH,IAAR+C,GAAqBoF,EAAIpF,KAoCrF2F,EAAsB9F,EACtB+F,EAAWrD,EAAO,CACd3G,UAAW,CAACkH,EAAMnH,MAAOwJ,EAAgBrC,EAAMnH,QAC/CwC,SAAUwB,EAAsB6F,EAAY3F,EAAGiD,EAAMnH,OACrDoG,QAASiD,EACTlD,UAAWmD,EACXtC,YACAD,cACF,EAGN,OADAmD,EAAmB,GACZ,CACHxB,mBAAoB,KACpBC,KAAOzE,IAOH,IAAIiG,GAAkB,EAUtB,OATKF,QAAoC3I,IAAxB0I,IACbG,GAAkB,EAClBL,EAAc5F,GACdgG,EAAmBhG,SAMK5C,IAAxB0I,GAAqC9F,GAAK8F,EACnCC,EAAStB,KAAKzE,EAAI8F,KAGxBG,GAAmBL,EAAc5F,GAC3BiD,EACX,EAGZ,C,8DC7EA,SAASiD,GAAcC,EAAQrB,GAC3B,OAAOqB,EAAOC,KAAI,IAAMtB,GAAUlF,EAAA,KAAWyG,OAAO,EAAGF,EAAOhJ,OAAS,EAC3E,CACA,SAASpB,IAAU,SAAEoD,EAAW,IAAKpD,UAAWuK,EAAc,MAAEC,EAAK,KAAE3G,EAAO,cAK1E,MAAM4G,GAAkB,OAAc5G,GAChCA,EAAKwG,IAAI,MACT,OAA2BxG,GAK3BqD,EAAQ,CACVC,MAAM,EACNpH,MAAOwK,EAAe,IAKpBG,GAAgB,OAGtBF,GAASA,EAAMpJ,SAAWmJ,EAAenJ,OACnCoJ,GACA,OAAcD,GAAiBnH,GAC/BuH,GAAoB,EAAAC,EAAA,GAAYF,EAAeH,EAAgB,CACjE1G,KAAMtD,MAAMC,QAAQiK,GACdA,EACAN,GAAcI,EAAgBE,KAExC,MAAO,CACHhC,mBAAoBrF,EACpBsF,KAAOzE,IACHiD,EAAMnH,MAAQ4K,EAAkB1G,GAChCiD,EAAMC,KAAOlD,GAAKb,EACX8D,GAGnB,CC7CA,MAAM2D,GAAmBC,IACrB,MAAMC,EAAgB,EAAGC,eAAgBF,EAAOE,GAChD,MAAO,CACH7K,MAAO,IAAM,KAAM2K,OAAOC,GAAe,GACzCE,KAAM,KAAM,QAAYF,GAKxB/I,IAAK,IAAO,KAAUkJ,aAAe,KAAUF,UAAY,IAAKhJ,MACnE,ECACmJ,GAAa,CACfC,MAAOnC,EACPA,QAAO,EACPoC,MAAOrL,GACPA,UAAWA,GACX2G,OAAM,GAEJ2E,GAAqBC,GAAYA,EAAU,IAMjD,MAAMC,WAA4BlK,EAC9B,WAAAC,CAAYtB,GACRwL,MAAMxL,GAIN2B,KAAK8J,SAAW,KAIhB9J,KAAK+J,WAAa,KAIlB/J,KAAKgK,YAAc,EAInBhK,KAAKiK,cAAgB,EAMrBjK,KAAKkK,iBAAmB,UAIxBlK,KAAKmK,UAAY,KACjBnK,KAAKsF,MAAQ,OAKbtF,KAAKqJ,KAAO,KAGR,GAFArJ,KAAKoK,SAASC,SACdrK,KAAKC,WAAY,EACE,SAAfD,KAAKsF,MACL,OACJtF,KAAKsK,WACL,MAAM,OAAEC,GAAWvK,KAAK3B,QACxBkM,GAAUA,GAAQ,EAEtB,MAAM,KAAE7L,EAAI,YAAE8L,EAAW,QAAEC,EAAO,UAAErM,GAAc4B,KAAK3B,QACjDqM,GAAsBD,aAAyC,EAASA,EAAQE,mBAAqB,IAE3G3K,KAAKoK,SAAW,IAAIM,EAAmBtM,GADpB,CAACiB,EAAmBD,IAAkBY,KAAKU,oBAAoBrB,EAAmBD,IACvCV,EAAM8L,EAAaC,GACjFzK,KAAKoK,SAASQ,iBAClB,CACA,OAAA5I,GACI6H,MAAM7H,UAEFhC,KAAKS,WACLoK,OAAOC,OAAO9K,KAAKS,UAAWT,KAAK0B,aAAa1B,KAAKS,UAAUrC,WAEvE,CACA,YAAAsD,CAAaqJ,GACT,MAAM,KAAEjL,EAAO,YAAW,OAAEZ,EAAS,EAAC,YAAEa,EAAc,EAAC,WAAEZ,EAAU,SAAEwB,EAAW,GAAOX,KAAK3B,QACtF2M,GAAmB,QAAYlL,GAC/BA,EACAyJ,GAAWzJ,IAAS1B,GAO1B,IAAI6M,EACAC,EACAF,IAAqB5M,IACK,iBAAnB2M,EAAY,KAInBE,GAAwB,EAAAE,EAAA,GAAKzB,IAAmB,EAAA0B,EAAA,GAAIL,EAAY,GAAIA,EAAY,KAChFA,EAAc,CAAC,EAAG,MAEtB,MAAMnE,EAAYoE,EAAiB,IAAKhL,KAAK3B,QAASD,UAAW2M,IAK9C,WAAf5L,IACA+L,EAAoBF,EAAiB,IAC9BhL,KAAK3B,QACRD,UAAW,IAAI2M,GAAaM,UAC5B1K,UAAWA,KAWkB,OAAjCiG,EAAUC,qBACVD,EAAUC,oBAAqB,QAAsBD,IAEzD,MAAM,mBAAEC,GAAuBD,EACzB0E,EAAmBzE,EAAqB9G,EAE9C,MAAO,CACH6G,YACAsE,oBACAD,wBACApE,qBACAyE,mBACAC,cAPkBD,GAAoBpM,EAAS,GAAKa,EAS5D,CACA,cAAA4B,GACI,MAAM,SAAE/B,GAAW,GAASI,KAAK3B,QACjC2B,KAAKwL,OACyB,WAA1BxL,KAAKkK,kBAAkCtK,EAIvCI,KAAKsF,MAAQtF,KAAKkK,iBAHlBlK,KAAKyL,OAKb,CACA,IAAAC,CAAKtC,EAAWuC,GAAS,GACrB,MAAM,SAAEnL,GAAaR,KAErB,IAAKQ,EAAU,CACX,MAAM,UAAEpC,GAAc4B,KAAK3B,QAC3B,MAAO,CAAEkH,MAAM,EAAMpH,MAAOC,EAAUA,EAAUoB,OAAS,GAC7D,CACA,MAAM,cAAEJ,EAAa,UAAEwH,EAAS,kBAAEsE,EAAiB,sBAAED,EAAqB,UAAE7M,EAAS,mBAAEyI,EAAkB,cAAE0E,EAAa,iBAAED,GAAsB9K,EAChJ,GAAuB,OAAnBR,KAAKmK,UACL,OAAOvD,EAAUE,KAAK,GAC1B,MAAM,MAAEjH,EAAK,OAAEX,EAAM,WAAEC,EAAU,YAAEY,EAAW,SAAEc,GAAab,KAAK3B,QAO9D2B,KAAK4L,MAAQ,EACb5L,KAAKmK,UAAY5H,KAAKkE,IAAIzG,KAAKmK,UAAWf,GAErCpJ,KAAK4L,MAAQ,IAClB5L,KAAKmK,UAAY5H,KAAKkE,IAAI2C,EAAYmC,EAAgBvL,KAAK4L,MAAO5L,KAAKmK,YAGvEwB,EACA3L,KAAKgK,YAAcZ,EAEI,OAAlBpJ,KAAK8J,SACV9J,KAAKgK,YAAchK,KAAK8J,SAMxB9J,KAAKgK,YACDzH,KAAKsJ,MAAMzC,EAAYpJ,KAAKmK,WAAanK,KAAK4L,MAGtD,MAAME,EAAmB9L,KAAKgK,YAAcnK,GAASG,KAAK4L,OAAS,EAAI,GAAK,GACtEG,EAAiB/L,KAAK4L,OAAS,EAC/BE,EAAmB,EACnBA,EAAmBP,EACzBvL,KAAKgK,YAAczH,KAAKC,IAAIsJ,EAAkB,GAE3B,aAAf9L,KAAKsF,OAA0C,OAAlBtF,KAAK8J,WAClC9J,KAAKgK,YAAcuB,GAEvB,IAAIS,EAAUhM,KAAKgK,YACfiC,EAAiBrF,EACrB,GAAI1H,EAAQ,CAMR,MAAMkI,EAAW7E,KAAKkE,IAAIzG,KAAKgK,YAAauB,GAAiBD,EAK7D,IAAIY,EAAmB3J,KAAK4J,MAAM/E,GAK9BgF,EAAoBhF,EAAW,GAK9BgF,GAAqBhF,GAAY,IAClCgF,EAAoB,GAEF,IAAtBA,GAA2BF,IAC3BA,EAAmB3J,KAAKkE,IAAIyF,EAAkBhN,EAAS,GAIhCmN,QAAQH,EAAmB,KAE3B,YAAf/M,GACAiN,EAAoB,EAAIA,EACpBrM,IACAqM,GAAqBrM,EAAcuL,IAGnB,WAAfnM,IACL8M,EAAiBf,IAGzBc,GAAU,EAAA7I,EAAA,GAAM,EAAG,EAAGiJ,GAAqBd,CAC/C,CAMA,MAAMhG,EAAQyG,EACR,CAAExG,MAAM,EAAOpH,MAAOC,EAAU,IAChC6N,EAAenF,KAAKkF,GACtBf,IACA3F,EAAMnH,MAAQ8M,EAAsB3F,EAAMnH,QAE9C,IAAI,KAAEoH,GAASD,EACVyG,GAAyC,OAAvBlF,IACnBtB,EACIvF,KAAK4L,OAAS,EACR5L,KAAKgK,aAAeuB,EACpBvL,KAAKgK,aAAe,GAElC,MAAMsC,EAAwC,OAAlBtM,KAAK8J,WACb,aAAf9J,KAAKsF,OAAwC,YAAftF,KAAKsF,OAAuBC,GAU/D,OATI+G,QAAyC7M,IAAlBL,IACvBkG,EAAMnH,MAAQc,EAAiBb,EAAW4B,KAAK3B,QAASe,IAExDyB,GACAA,EAASyE,EAAMnH,OAEfmO,GACAtM,KAAKuM,SAEFjH,CACX,CACA,YAAI9D,GACA,MAAM,SAAEhB,GAAaR,KACrB,OAAOQ,GAAW,OAAsBA,EAASqG,oBAAsB,CAC3E,CACA,QAAI2F,GACA,OAAO,OAAsBxM,KAAKgK,YACtC,CACA,QAAIwC,CAAKC,GACLA,GAAU,OAAsBA,GAChCzM,KAAKgK,YAAcyC,EACG,OAAlBzM,KAAK8J,UAAoC,IAAf9J,KAAK4L,MAC/B5L,KAAK8J,SAAW2C,EAEXzM,KAAK0M,SACV1M,KAAKmK,UAAYnK,KAAK0M,OAAOtM,MAAQqM,EAAUzM,KAAK4L,MAE5D,CACA,SAAIA,GACA,OAAO5L,KAAKiK,aAChB,CACA,SAAI2B,CAAMe,GACN,MAAMC,EAAa5M,KAAKiK,gBAAkB0C,EAC1C3M,KAAKiK,cAAgB0C,EACjBC,IACA5M,KAAKwM,MAAO,OAAsBxM,KAAKgK,aAE/C,CACA,IAAAwB,GAII,GAHKxL,KAAKoK,SAASyC,aACf7M,KAAKoK,SAAS0C,UAEb9M,KAAKS,UAEN,YADAT,KAAKkK,iBAAmB,WAG5B,GAAIlK,KAAKC,UACL,OACJ,MAAM,OAAEyM,EAASzD,GAAe,OAAE8D,EAAM,UAAE5C,GAAcnK,KAAK3B,QACxD2B,KAAK0M,SACN1M,KAAK0M,OAASA,GAAQtD,GAAcpJ,KAAK0L,KAAKtC,MAElD2D,GAAUA,IACV,MAAM3M,EAAMJ,KAAK0M,OAAOtM,MACF,OAAlBJ,KAAK8J,SACL9J,KAAKmK,UAAY/J,EAAMJ,KAAK8J,SAEtB9J,KAAKmK,UAGS,aAAfnK,KAAKsF,QACVtF,KAAKmK,UAAY/J,GAHjBJ,KAAKmK,UAAYA,QAA6CA,EAAYnK,KAAKM,gBAKhE,aAAfN,KAAKsF,OACLtF,KAAKK,wBAETL,KAAK+J,WAAa/J,KAAKmK,UACvBnK,KAAK8J,SAAW,KAKhB9J,KAAKsF,MAAQ,UACbtF,KAAK0M,OAAOnO,OAChB,CACA,KAAAkN,GACI,IAAIuB,EACChN,KAAKS,WAIVT,KAAKsF,MAAQ,SACbtF,KAAK8J,SAAuC,QAA3BkD,EAAKhN,KAAKgK,mBAAgC,IAAPgD,EAAgBA,EAAK,GAJrEhN,KAAKkK,iBAAmB,QAKhC,CACA,QAAA+C,GACuB,YAAfjN,KAAKsF,OACLtF,KAAKwL,OAETxL,KAAKkK,iBAAmBlK,KAAKsF,MAAQ,WACrCtF,KAAK8J,SAAW,IACpB,CACA,MAAAyC,GACIvM,KAAKsK,WACLtK,KAAKsF,MAAQ,WACb,MAAM,WAAE1E,GAAeZ,KAAK3B,QAC5BuC,GAAcA,GAClB,CACA,MAAAyJ,GAC4B,OAApBrK,KAAK+J,YACL/J,KAAK0L,KAAK1L,KAAK+J,YAEnB/J,KAAKsK,WACLtK,KAAKK,uBACT,CACA,QAAAiK,GACItK,KAAKsF,MAAQ,OACbtF,KAAKkN,aACLlN,KAAKuB,yBACLvB,KAAKK,wBACLL,KAAKmK,UAAYnK,KAAK+J,WAAa,KACnC/J,KAAKoK,SAASC,QAClB,CACA,UAAA6C,GACSlN,KAAK0M,SAEV1M,KAAK0M,OAAOrD,OACZrJ,KAAK0M,YAASjN,EAClB,CACA,MAAAkM,CAAOa,GAEH,OADAxM,KAAKmK,UAAY,EACVnK,KAAK0L,KAAKc,GAAM,EAC3B,EC1XJ,MAAMW,GAAoB,IAAIC,IAAI,CAC9B,UACA,WACA,SACA,cCLJ,MAAMC,IAA8B,E,QAAA,IAAK,IAAMxC,OAAOyC,eAAeC,KAAKC,QAAQC,UAAW,aCgE7F,MAAMC,GAA6B,CAC/BC,WAAU,IACVC,UAAS,KACTC,UAAS,MAKb,MAAMC,WAA6BpO,EAC/B,WAAAC,CAAYtB,GACRwL,MAAMxL,GACN,MAAM,KAAEK,EAAI,YAAE8L,EAAW,QAAEC,EAAO,UAAErM,GAAc4B,KAAK3B,QACvD2B,KAAKoK,SAAW,IAAI2D,EAAA,EAAqB3P,GAAW,CAACiB,EAAmBD,IAAkBY,KAAKU,oBAAoBrB,EAAmBD,IAAgBV,EAAM8L,EAAaC,GACzKzK,KAAKoK,SAASQ,iBAClB,CACA,YAAAlJ,CAAatD,EAAWgB,GACpB,IAAI,SAAEoC,EAAW,IAAG,MAAEoH,EAAK,KAAE3G,EAAI,KAAEnC,EAAI,YAAE0K,EAAW,KAAE9L,EAAI,UAAEyL,GAAenK,KAAK3B,QAKhF,IAAKmM,EAAYwD,QAAUxD,EAAYwD,MAAM7M,QACzC,OAAO,EAjBnB,IA1CuC9C,EA0E/B,GARoB,iBAAT4D,IACP,WACkBA,KAzBZyL,KA0BNzL,EAAOyL,GAA2BzL,IArEP5D,EA0EG2B,KAAK3B,SAzEnC,QAAYA,EAAQyB,OACP,WAAjBzB,EAAQyB,QACP,QAAuBzB,EAAQ4D,MAuEiB,CAC7C,MAAM,WAAErB,EAAU,SAAEC,EAAQ,YAAE2J,EAAW,QAAEC,KAAYpM,GAAY2B,KAAK3B,QAClE4P,EAvElB,SAA8B7P,EAAWC,GAMrC,MAAM6P,EAAkB,IAAItE,GAAoB,IACzCvL,EACHD,YACAc,OAAQ,EACRW,MAAO,EACPiB,aAAa,IAEjB,IAAIwE,EAAQ,CAAEC,MAAM,EAAOpH,MAAOC,EAAU,IAC5C,MAAM+P,EAAwB,GAK9B,IAAI9L,EAAI,EACR,MAAQiD,EAAMC,MAAQlD,EA/BN,KAgCZiD,EAAQ4I,EAAgBvC,OAAOtJ,GAC/B8L,EAAsBC,KAAK9I,EAAMnH,OACjCkE,GAvCY,GAyChB,MAAO,CACHuG,WAAOnJ,EACPrB,UAAW+P,EACX3M,SAAUa,EA5CE,GA6CZJ,KAAM,SAEd,CAwC0CoM,CAAqBjQ,EAAWC,GAKrC,KAJzBD,EAAY6P,EAAsB7P,WAIpBoB,SACVpB,EAAU,GAAKA,EAAU,IAE7BoD,EAAWyM,EAAsBzM,SACjCoH,EAAQqF,EAAsBrF,MAC9B3G,EAAOgM,EAAsBhM,KAC7BnC,EAAO,WACX,CACA,MAAMtB,ECpHd,SAA6BiM,EAAS6D,EAAWlQ,GAAW,MAAEyB,EAAQ,EAAC,SAAE2B,EAAW,IAAG,OAAEtC,EAAS,EAAC,WAAEC,EAAa,OAAM,KAAE8C,EAAO,YAAW,MAAE2G,GAAW,CAAC,GACtJ,MAAM2F,EAAkB,CAAE,CAACD,GAAYlQ,GACnCwK,IACA2F,EAAgBC,OAAS5F,GAC7B,MAAMzB,GAAS,QAAwBlF,EAAMT,GAM7C,OAFI7C,MAAMC,QAAQuI,KACdoH,EAAgBpH,OAASA,GACtBsD,EAAQgE,QAAQF,EAAiB,CACpC1O,QACA2B,WACA2F,OAASxI,MAAMC,QAAQuI,GAAmB,SAATA,EACjCuH,KAAM,OACNC,WAAYzP,EAAS,EACrB0P,UAA0B,YAAfzP,EAA2B,YAAc,UAE5D,CDkG0B0P,CAAoBrE,EAAYwD,MAAM7M,QAASzC,EAAMN,EAAW,IAAK4B,KAAK3B,QAASmD,WAAUoH,QAAO3G,SAyBtH,OAtBAzD,EAAU2L,UAAYA,QAA6CA,EAAYnK,KAAKM,gBAChFN,KAAK8O,kBACL,QAAetQ,EAAWwB,KAAK8O,iBAC/B9O,KAAK8O,qBAAkBrP,GAWvBjB,EAAUuQ,SAAW,KACjB,MAAM,WAAEnO,GAAeZ,KAAK3B,QAC5BmM,EAAYwE,IAAI/P,EAAiBb,EAAW4B,KAAK3B,QAASe,IAC1DwB,GAAcA,IACdZ,KAAKqK,SACLrK,KAAKuB,wBAAwB,EAG9B,CACH/C,YACAgD,WACAoH,QACA9I,OACAmC,OACA7D,UAAWA,EAEnB,CACA,YAAIoD,GACA,MAAM,SAAEhB,GAAaR,KACrB,IAAKQ,EACD,OAAO,EACX,MAAM,SAAEgB,GAAahB,EACrB,OAAO,OAAsBgB,EACjC,CACA,QAAIgL,GACA,MAAM,SAAEhM,GAAaR,KACrB,IAAKQ,EACD,OAAO,EACX,MAAM,UAAEhC,GAAcgC,EACtB,OAAO,OAAsBhC,EAAUwL,aAAe,EAC1D,CACA,QAAIwC,CAAKC,GACL,MAAM,SAAEjM,GAAaR,KACrB,IAAKQ,EACD,OACJ,MAAM,UAAEhC,GAAcgC,EACtBhC,EAAUwL,aAAc,OAAsByC,EAClD,CACA,SAAIb,GACA,MAAM,SAAEpL,GAAaR,KACrB,IAAKQ,EACD,OAAO,EACX,MAAM,UAAEhC,GAAcgC,EACtB,OAAOhC,EAAUyQ,YACrB,CACA,SAAIrD,CAAMe,GACN,MAAM,SAAEnM,GAAaR,KACrB,IAAKQ,EACD,OACJ,MAAM,UAAEhC,GAAcgC,EACtBhC,EAAUyQ,aAAetC,CAC7B,CACA,SAAIrH,GACA,MAAM,SAAE9E,GAAaR,KACrB,IAAKQ,EACD,MAAO,OACX,MAAM,UAAEhC,GAAcgC,EACtB,OAAOhC,EAAU0Q,SACrB,CACA,aAAI/E,GACA,MAAM,SAAE3J,GAAaR,KACrB,IAAKQ,EACD,OAAO,KACX,MAAM,UAAEhC,GAAcgC,EAGtB,OAAOhC,EAAU2L,SACrB,CAKA,cAAAgF,CAAeC,GACX,GAAKpP,KAAKS,UAGL,CACD,MAAM,SAAED,GAAaR,KACrB,IAAKQ,EACD,OAAO6O,EAAA,EACX,MAAM,UAAE7Q,GAAcgC,GACtB,QAAehC,EAAW4Q,EAC9B,MARIpP,KAAK8O,gBAAkBM,EAS3B,OAAOC,EAAA,CACX,CACA,IAAA7D,GACI,GAAIxL,KAAKC,UACL,OACJ,MAAM,SAAEO,GAAaR,KACrB,IAAKQ,EACD,OACJ,MAAM,UAAEhC,GAAcgC,EACM,aAAxBhC,EAAU0Q,WACVlP,KAAKK,wBAET7B,EAAUgN,MACd,CACA,KAAAC,GACI,MAAM,SAAEjL,GAAaR,KACrB,IAAKQ,EACD,OACJ,MAAM,UAAEhC,GAAcgC,EACtBhC,EAAUiN,OACd,CACA,IAAApC,GAGI,GAFArJ,KAAKoK,SAASC,SACdrK,KAAKC,WAAY,EACE,SAAfD,KAAKsF,MACL,OACJtF,KAAKuB,yBACLvB,KAAKK,wBACL,MAAM,SAAEG,GAAaR,KACrB,IAAKQ,EACD,OACJ,MAAM,UAAEhC,EAAS,UAAEJ,EAAS,SAAEoD,EAAQ,KAAE1B,EAAI,KAAEmC,EAAI,MAAE2G,GAAUpI,EAC9D,GAA4B,SAAxBhC,EAAU0Q,WACc,aAAxB1Q,EAAU0Q,UACV,OAUJ,GAAIlP,KAAKwM,KAAM,CACX,MAAM,YAAEhC,EAAW,SAAE3J,EAAQ,WAAED,EAAU,QAAE6J,KAAYpM,GAAY2B,KAAK3B,QAClE6P,EAAkB,IAAItE,GAAoB,IACzCvL,EACHD,YACAoD,WACA1B,OACAmC,OACA2G,QACA9H,aAAa,IAEXwO,GAAa,OAAsBtP,KAAKwM,MAC9ChC,EAAY+E,gBAAgBrB,EAAgBvC,OAAO2D,EAhQ3C,IAgQqEnR,MAAO+P,EAAgBvC,OAAO2D,GAAYnR,MAhQ/G,GAiQZ,CACA,MAAM,OAAEoM,GAAWvK,KAAK3B,QACxBkM,GAAUA,IACVvK,KAAKqK,QACT,CACA,QAAA4C,GACI,MAAM,SAAEzM,GAAaR,KAChBQ,GAELA,EAAShC,UAAU+N,QACvB,CACA,MAAAlC,GACI,MAAM,SAAE7J,GAAaR,KAChBQ,GAELA,EAAShC,UAAU6L,QACvB,CACA,eAAOmF,CAASnR,GACZ,MAAM,YAAEmM,EAAW,KAAE9L,EAAI,YAAEqB,EAAW,WAAEZ,EAAU,QAAEoF,EAAO,KAAEzE,GAASzB,EACtE,KAAKmM,GACAA,EAAYwD,OACXxD,EAAYwD,MAAM7M,mBAAmBsO,aACvC,OAAO,EAEX,MAAM,SAAE5O,EAAQ,kBAAE6O,GAAsBlF,EAAYwD,MAAM2B,WAC1D,OAAQtC,MACJ3O,GACAyO,GAAkByC,IAAIlR,KAKrBmC,IACA6O,IACA3P,GACc,WAAfZ,GACY,IAAZoF,GACS,YAATzE,CACR,E,eEvTJ,MAAM+P,GAAoB,CACtB/P,KAAM,SACNwE,UAAW,IACXC,QAAS,GACTW,UAAW,IAQT4K,GAAsB,CACxBhQ,KAAM,YACN0B,SAAU,IAMR,GAAO,CACT1B,KAAM,YACNmC,KAAM,CAAC,IAAM,GAAK,IAAM,GACxBT,SAAU,IAERuO,GAAuB,CAACC,GAAY5R,eAClCA,EAAUoB,OAAS,EACZsQ,GAEF,KAAeF,IAAII,GACjBA,EAASjR,WAAW,SAxBQ,CACvCe,KAAM,SACNwE,UAAW,IACXC,QAAoB,IAsBanG,EAAU,GAtBnB,EAAImE,KAAKiC,KAAK,KAAO,GAC7CU,UAAW,IAsBD2K,GAEH,GCzBX,MAAMI,GAAqB,CAACvR,EAAMP,EAAOkH,EAAQ6K,EAAa,CAAC,EAAGzF,EAAS0F,IAAevP,IACtF,MAAMwP,GAAkB,QAAmBF,EAAYxR,IAAS,CAAC,EAM3DmB,EAAQuQ,EAAgBvQ,OAASqQ,EAAWrQ,OAAS,EAK3D,IAAI,QAAEmM,EAAU,GAAMkE,EACtBlE,IAAoB,OAAsBnM,GAC1C,IAAIxB,EAAU,CACVD,UAAWO,MAAMC,QAAQyG,GAAUA,EAAS,CAAC,KAAMA,GACnDpD,KAAM,UACNtB,SAAUxC,EAAMkS,iBACbD,EACHvQ,OAAQmM,EACRnL,SAAW+G,IACPzJ,EAAM6Q,IAAIpH,GACVwI,EAAgBvP,UAAYuP,EAAgBvP,SAAS+G,EAAE,EAE3DhH,WAAY,KACRA,IACAwP,EAAgBxP,YAAcwP,EAAgBxP,YAAY,EAE9DlC,OACA8L,YAAarM,EACbsM,QAAS0F,OAAY1Q,EAAYgL,ICpCzC,UAA6B,KAAE6F,EAAMzQ,MAAO0Q,EAAM,cAAEC,EAAa,gBAAEC,EAAe,iBAAEC,EAAgB,OAAExR,EAAM,WAAEC,EAAU,YAAEY,EAAW,KAAE4Q,EAAI,QAAE3E,KAAYkE,IACrJ,QAASrF,OAAOjG,KAAKsL,GAAY1Q,MACrC,EDwCSoR,CAAoBR,KACrB/R,EAAU,IACHA,KACA0R,GAAqBrR,EAAML,KAQlCA,EAAQmD,WACRnD,EAAQmD,UAAW,OAAsBnD,EAAQmD,WAEjDnD,EAAQ0B,cACR1B,EAAQ0B,aAAc,OAAsB1B,EAAQ0B,mBAEnCN,IAAjBpB,EAAQsS,OACRtS,EAAQD,UAAU,GAAKC,EAAQsS,MAEnC,IAAIE,GAAa,EAmBjB,KAlBqB,IAAjBxS,EAAQyB,MACc,IAArBzB,EAAQmD,WAAmBnD,EAAQ0B,eACpC1B,EAAQmD,SAAW,EACG,IAAlBnD,EAAQwB,QACRgR,GAAa,KAGjB,IAAsB1P,SACtB,IAAmB2P,kBACnBD,GAAa,EACbxS,EAAQmD,SAAW,EACnBnD,EAAQwB,MAAQ,GAOhBgR,IAAeV,QAA6B1Q,IAAhBtB,EAAM4S,MAAqB,CACvD,MAAM3R,EAAgBH,EAAiBZ,EAAQD,UAAWgS,GAC1D,QAAsB3Q,IAAlBL,EAOA,OANA,KAAM8J,QAAO,KACT7K,EAAQwC,SAASzB,GACjBf,EAAQuC,YAAY,IAIjB,IAAI,KAAsB,GAEzC,CAMA,OAAKuP,GAAarC,GAAqB0B,SAASnR,GACrC,IAAIyP,GAAqBzP,GAGzB,IAAIuL,GAAoBvL,EACnC,C,mHE9FJ,SAAS2S,GAAqB,cAAEC,EAAa,eAAEC,GAAkBpM,GAC7D,MAAMqM,EAAcF,EAAc3D,eAAexI,KAAgC,IAAxBoM,EAAepM,GAExE,OADAoM,EAAepM,IAAO,EACfqM,CACX,CACA,SAASC,EAAcC,EAAeC,GAAqB,MAAEzR,EAAQ,EAAC,mBAAE0R,EAAkB,KAAEzR,GAAS,CAAC,GAClG,IAAIkN,EACJ,IAAI,WAAEkD,EAAamB,EAActB,uBAAsB,cAAEyB,KAAkBnM,GAAWiM,EAClFC,IACArB,EAAaqB,GACjB,MAAME,EAAa,GACbC,EAAqB5R,GACvBuR,EAAcM,gBACdN,EAAcM,eAAeC,WAAW9R,GAC5C,IAAK,MAAMgF,KAAOO,EAAQ,CACtB,MAAMlH,EAAQkT,EAAcQ,SAAS/M,EAAgD,QAA1CkI,EAAKqE,EAAcS,aAAahN,UAAyB,IAAPkI,EAAgBA,EAAK,MAC5G+E,EAAc1M,EAAOP,GAC3B,QAAoBrF,IAAhBsS,GACCL,GACGV,EAAqBU,EAAoB5M,GAC7C,SAEJ,MAAMsL,EAAkB,CACpBvQ,YACG,QAAmBqQ,GAAc,CAAC,EAAGpL,IAM5C,IAAIqL,GAAY,EAChB,GAAI6B,OAAOC,uBAAwB,CAC/B,MAAMC,GAAW,OAAqBb,GACtC,GAAIa,EAAU,CACV,MAAM/H,EAAY6H,OAAOC,uBAAuBC,EAAUpN,EAAK,MAC7C,OAAdqF,IACAiG,EAAgBjG,UAAYA,EAC5BgG,GAAY,EAEpB,CACJ,EACA,OAAqBkB,EAAevM,GACpC3G,EAAMI,OAAM,OAAmBuG,EAAK3G,EAAO4T,EAAaV,EAAcc,oBAAsB,IAAevC,IAAI9K,GACzG,CAAEhF,MAAM,GACRsQ,EAAiBiB,EAAelB,IACtC,MAAM3R,EAAYL,EAAMK,UACpBA,GACAiT,EAAWrD,KAAK5P,EAExB,CAQA,OAPIgT,GACAtP,QAAQkQ,IAAIX,GAAY7P,MAAK,KACzB,KAAMsH,QAAO,KACTsI,IAAiB,OAAUH,EAAeG,EAAc,GAC1D,IAGHC,CACX,CCrEA,SAASY,EAAehB,EAAeiB,EAASjU,EAAU,CAAC,GACvD,IAAI2O,EACJ,MAAMxM,GAAW,OAAe6Q,EAAeiB,EAA0B,SAAjBjU,EAAQyB,KACjB,QAAxCkN,EAAKqE,EAAckB,uBAAoC,IAAPvF,OAAgB,EAASA,EAAGwF,YAC7E/S,GACN,IAAI,WAAEyQ,EAAamB,EAActB,wBAA0B,CAAC,GAAMvP,GAAY,CAAC,EAC3EnC,EAAQkT,qBACRrB,EAAa7R,EAAQkT,oBAMzB,MAAMkB,EAAejS,EACf,IAAM0B,QAAQkQ,IAAIhB,EAAcC,EAAe7Q,EAAUnC,IACzD,IAAM6D,QAAQL,UAKd6Q,EAAqBrB,EAAcsB,iBAAmBtB,EAAcsB,gBAAgBC,KACpF,CAACC,EAAe,KACd,MAAM,cAAErC,EAAgB,EAAC,gBAAEC,EAAe,iBAAEC,GAAsBR,EAClE,OAkBZ,SAAyBmB,EAAeiB,EAAS9B,EAAgB,EAAGC,EAAkB,EAAGC,EAAmB,EAAGrS,GAC3G,MAAMoT,EAAa,GACbqB,GAAsBzB,EAAcsB,gBAAgBC,KAAO,GAAKnC,EAChEsC,EAA+C,IAArBrC,EAC1B,CAACtP,EAAI,IAAMA,EAAIqP,EACf,CAACrP,EAAI,IAAM0R,EAAqB1R,EAAIqP,EAU1C,OATA9R,MAAMgS,KAAKU,EAAcsB,iBACpBK,KAAKC,GACLC,SAAQ,CAACC,EAAO/R,KACjB+R,EAAMC,OAAO,iBAAkBd,GAC/Bb,EAAWrD,KAAKiE,EAAec,EAAOb,EAAS,IACxCjU,EACHwB,MAAO2Q,EAAgBuC,EAAwB3R,KAChDQ,MAAK,IAAMuR,EAAMC,OAAO,oBAAqBd,KAAU,IAEvDpQ,QAAQkQ,IAAIX,EACvB,CAlCmB4B,CAAgBhC,EAAeiB,EAAS9B,EAAgBqC,EAAcpC,EAAiBC,EAAkBrS,EAAQ,EAE1H,IAAM6D,QAAQL,WAKd,KAAEyO,GAASJ,EACjB,GAAII,EAAM,CACN,MAAOgD,EAAOC,GAAiB,mBAATjD,EAChB,CAACmC,EAAcC,GACf,CAACA,EAAoBD,GAC3B,OAAOa,IAAQ1R,MAAK,IAAM2R,KAC9B,CAEI,OAAOrR,QAAQkQ,IAAI,CAACK,IAAgBC,EAAmBrU,EAAQwB,QAEvE,CAkBA,SAASoT,EAAgB1P,EAAGC,GACxB,OAAOD,EAAEiQ,iBAAiBhQ,EAC9B,CC3DA,SAASiQ,EAAqBpC,EAAeqC,EAAYrV,EAAU,CAAC,GAEhE,IAAIG,EACJ,GAFA6S,EAAc+B,OAAO,iBAAkBM,GAEnC/U,MAAMC,QAAQ8U,GAAa,CAC3B,MAAMjC,EAAaiC,EAAWjL,KAAK6J,GAAYD,EAAehB,EAAeiB,EAASjU,KACtFG,EAAY0D,QAAQkQ,IAAIX,EAC5B,MACK,GAA0B,iBAAfiC,EACZlV,EAAY6T,EAAehB,EAAeqC,EAAYrV,OAErD,CACD,MAAMsV,EAA2C,mBAAfD,GAC5B,OAAerC,EAAeqC,EAAYrV,EAAQmU,QAClDkB,EACNlV,EAAY0D,QAAQkQ,IAAIhB,EAAcC,EAAesC,EAAoBtV,GAC7E,CACA,OAAOG,EAAUoD,MAAK,KAClByP,EAAc+B,OAAO,oBAAqBM,EAAW,GAE7D,C,kCCrBA,MACME,EAA+B,SAAU,E,QAAA,GADjB,iB,gDCA9B,SAASC,EAAqBxC,GAC1B,OAAOA,EAAcyC,MAAM,IAC/B,C,iBCJA,SAASC,EAAoBnM,GACzB,OAAc,OAANA,GACS,iBAANA,GACY,mBAAZA,EAAErJ,KACjB,C,kDCJA,MAAMyV,EAAqBpM,GAChBjJ,MAAMC,QAAQgJ,E,gDCCzB,SAASqM,EAAO9V,GACZ,MAAqB,iBAAVA,EACU,IAAVA,EAEQ,OAAVA,IACY,SAAVA,GAA8B,MAAVA,IAAiB,OAAkBA,GAKtE,C,2DCcA,SAAS+V,EAAYC,GAAY,GAC7B,MAAMC,GAAU,IAAAC,YAAW,KAC3B,GAAgB,OAAZD,EACA,MAAO,EAAC,EAAM,MAClB,MAAM,UAAEE,EAAS,eAAEC,EAAc,SAAEC,GAAaJ,EAG1CK,GAAK,IAAAC,UACX,IAAAC,YAAU,KACFR,GACAK,EAASC,EAAG,GACjB,CAACN,IACJ,MAAMS,GAAe,IAAAC,cAAY,IAAMV,GAAaI,GAAkBA,EAAeE,IAAK,CAACA,EAAIF,EAAgBJ,IAC/G,OAAQG,GAAaC,EAAiB,EAAC,EAAOK,GAAgB,EAAC,EACnE,C,kCCrCA,MAAME,GAAqB,E,QAAAC,eAAc,CAAC,E,kCCA1C,MAAMC,GAAc,E,QAAAD,eAAc,CAAEE,QAAQ,G,kCCG5C,MAAMC,GAAsB,E,QAAAH,eAAc,CACtCI,mBAAqBC,GAAMA,EAC3BC,UAAU,EACVC,cAAe,S,4ECLnB,SAASC,EAAuBzB,GAC5B,MAAM,QAAE0B,EAAO,QAAE/G,GCFrB,SAAgCqF,EAAOM,GACnC,IAAI,OAAsBN,GAAQ,CAC9B,MAAM,QAAE0B,EAAO,QAAE/G,GAAYqF,EAC7B,MAAO,CACH0B,SAAqB,IAAZA,IAAqB,OAAeA,GACvCA,OACA/V,EACNgP,SAAS,OAAeA,GAAWA,OAAUhP,EAErD,CACA,OAAyB,IAAlBqU,EAAM2B,QAAoBrB,EAAU,CAAC,CAChD,CDTiCsB,CAAuB5B,GAAO,IAAAO,YAAWsB,EAAA,IACtE,OAAO,IAAAC,UAAQ,KAAM,CAAGJ,UAAS/G,aAAY,CAACoH,EAA0BL,GAAUK,EAA0BpH,IAChH,CACA,SAASoH,EAA0BC,GAC/B,OAAOnX,MAAMC,QAAQkX,GAAQA,EAAKC,KAAK,KAAOD,CAClD,C,kCEPA,MAAMH,GAAgB,E,QAAAZ,eAAc,CAAC,E,kCCGrC,MAAMiB,GAAkB,E,QAAAjB,eAAc,K,kCCAtC,MAAMkB,GAA2B,E,QAAAlB,eAAc,CAAC,E","sources":["webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animate/single-value.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/utils/can-animate.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/spring/defaults.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/inertia.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/drivers/driver-frameloop.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/utils/accelerated-values.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/waapi/utils/supports-waapi.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/waapi/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-transition-defined.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-none.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/LazyContext.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/MotionContext/create.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/MotionContext/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/PresenceContext.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs"],"sourcesContent":["import { motionValue } from '../../value/index.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { animateMotionValue } from '../interfaces/motion-value.mjs';\n\nfunction animateSingleValue(value, keyframes, options) {\n    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\n    motionValue$1.start(animateMotionValue(\"\", motionValue$1, keyframes, options));\n    return motionValue$1.animation;\n}\n\nexport { animateSingleValue };\n","import { complex } from '../../value/types/complex/index.mjs';\n\n/**\n * Check if a value is animatable. Examples:\n *\n * ✅: 100, \"100px\", \"#fff\"\n * ❌: \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nconst isAnimatable = (value, name) => {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (name === \"zIndex\")\n        return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value))\n        return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n        (complex.test(value) || value === \"0\") && // And it contains numbers and/or colors\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\n\nexport { isAnimatable };\n","const isNotNull = (value) => value !== null;\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }, finalKeyframe) {\n    const resolvedKeyframes = keyframes.filter(isNotNull);\n    const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1\n        ? 0\n        : resolvedKeyframes.length - 1;\n    return !index || finalKeyframe === undefined\n        ? resolvedKeyframes[index]\n        : finalKeyframe;\n}\n\nexport { getFinalKeyframe };\n","import { time } from '../../frameloop/sync-time.mjs';\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass BaseAnimation {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }) {\n        // Track whether the animation has been stopped. Stopped animations won't restart.\n        this.isStopped = false;\n        this.hasAttemptedResolve = false;\n        this.createdAt = time.now();\n        this.options = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            ...options,\n        };\n        this.updateFinishedPromise();\n    }\n    /**\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there's a delay (main thread work) between the creation of\n     * the animation and the first commited frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n    calcStartTime() {\n        if (!this.resolvedAt)\n            return this.createdAt;\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n            ? this.resolvedAt\n            : this.createdAt;\n    }\n    /**\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\n     * this.resolved will synchronously flush all pending keyframe resolvers.\n     * This is a deoptimisation, but at its worst still batches read/writes.\n     */\n    get resolved() {\n        if (!this._resolved && !this.hasAttemptedResolve) {\n            flushKeyframeResolvers();\n        }\n        return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */\n    onKeyframesResolved(keyframes, finalKeyframe) {\n        this.resolvedAt = time.now();\n        this.hasAttemptedResolve = true;\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n            // Finish immediately\n            if (instantAnimationState.current || !delay) {\n                onUpdate &&\n                    onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.resolveFinishedPromise();\n                return;\n            }\n            // Finish after a delay\n            else {\n                this.options.duration = 0;\n            }\n        }\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n        if (resolvedAnimation === false)\n            return;\n        this._resolved = {\n            keyframes,\n            finalKeyframe,\n            ...resolvedAnimation,\n        };\n        this.onPostResolved();\n    }\n    onPostResolved() { }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.currentFinishedPromise.then(resolve, reject);\n    }\n    flatten() {\n        this.options.type = \"keyframes\";\n        this.options.ease = \"linear\";\n    }\n    updateFinishedPromise() {\n        this.currentFinishedPromise = new Promise((resolve) => {\n            this.resolveFinishedPromise = resolve;\n        });\n    }\n}\n\nexport { BaseAnimation };\n","import { isGenerator } from 'motion-dom';\nimport { warning } from 'motion-utils';\nimport { isAnimatable } from '../../utils/is-animatable.mjs';\n\nfunction hasKeyframesChanged(keyframes) {\n    const current = keyframes[0];\n    if (keyframes.length === 1)\n        return true;\n    for (let i = 0; i < keyframes.length; i++) {\n        if (keyframes[i] !== current)\n            return true;\n    }\n}\nfunction canAnimate(keyframes, name, type, velocity) {\n    /**\n     * Check if we're able to animate between the start and end keyframes,\n     * and throw a warning if we're attempting to animate between one that's\n     * animatable and another that isn't.\n     */\n    const originKeyframe = keyframes[0];\n    if (originKeyframe === null)\n        return false;\n    /**\n     * These aren't traditionally animatable but we do support them.\n     * In future we could look into making this more generic or replacing\n     * this function with mix() === mixImmediate\n     */\n    if (name === \"display\" || name === \"visibility\")\n        return true;\n    const targetKeyframe = keyframes[keyframes.length - 1];\n    const isOriginAnimatable = isAnimatable(originKeyframe, name);\n    const isTargetAnimatable = isAnimatable(targetKeyframe, name);\n    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n    // Always skip if any of these are true\n    if (!isOriginAnimatable || !isTargetAnimatable) {\n        return false;\n    }\n    return (hasKeyframesChanged(keyframes) ||\n        ((type === \"spring\" || isGenerator(type)) && velocity));\n}\n\nexport { canAnimate };\n","import { velocityPerSecond } from '../../../utils/velocity-per-second.mjs';\n\nconst velocitySampleDuration = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - velocitySampleDuration, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\nexport { calcGeneratorVelocity };\n","const springDefaults = {\n    // Default spring physics\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    velocity: 0.0,\n    // Default duration/bounce-based options\n    duration: 800, // in ms\n    bounce: 0.3,\n    visualDuration: 0.3, // in seconds\n    // Rest thresholds\n    restSpeed: {\n        granular: 0.01,\n        default: 2,\n    },\n    restDelta: {\n        granular: 0.005,\n        default: 0.5,\n    },\n    // Limits\n    minDuration: 0.01, // in seconds\n    maxDuration: 10.0, // in seconds\n    minDamping: 0.05,\n    maxDamping: 1,\n};\n\nexport { springDefaults };\n","import { warning, secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { springDefaults } from './defaults.mjs';\n\nconst safeMin = 0.001;\nfunction findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {\n    let envelope;\n    let derivative;\n    warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), \"Spring duration must be 10 seconds or less\");\n    let dampingRatio = 1 - bounce;\n    /**\n     * Restrict dampingRatio and duration to within acceptable ranges.\n     */\n    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);\n    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));\n    if (dampingRatio < 1) {\n        /**\n         * Underdamped spring\n         */\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        /**\n         * Critically-damped spring\n         */\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = secondsToMilliseconds(duration);\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: springDefaults.stiffness,\n            damping: springDefaults.damping,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nexport { calcAngularFreq, findSpring };\n","import { calcGeneratorDuration, maxGeneratorDuration, generateLinearEasing } from 'motion-dom';\nimport { millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { springDefaults } from './defaults.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: springDefaults.velocity,\n        stiffness: springDefaults.stiffness,\n        damping: springDefaults.damping,\n        mass: springDefaults.mass,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        if (options.visualDuration) {\n            const visualDuration = options.visualDuration;\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\n            const stiffness = root * root;\n            const damping = 2 *\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\n                Math.sqrt(stiffness);\n            springOptions = {\n                ...springOptions,\n                mass: springDefaults.mass,\n                stiffness,\n                damping,\n            };\n        }\n        else {\n            const derived = findSpring(options);\n            springOptions = {\n                ...springOptions,\n                ...derived,\n                mass: springDefaults.mass,\n            };\n            springOptions.isResolvedFromDuration = true;\n        }\n    }\n    return springOptions;\n}\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\n    const options = typeof optionsOrVisualDuration !== \"object\"\n        ? {\n            visualDuration: optionsOrVisualDuration,\n            keyframes: [0, 1],\n            bounce,\n        }\n        : optionsOrVisualDuration;\n    let { restSpeed, restDelta } = options;\n    const origin = options.keyframes[0];\n    const target = options.keyframes[options.keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0),\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale\n        ? springDefaults.restSpeed.granular\n        : springDefaults.restSpeed.default);\n    restDelta || (restDelta = isGranularScale\n        ? springDefaults.restDelta.granular\n        : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    const generator = {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = 0.0;\n                /**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can't overshoot, so\n                 * checking only for displacement is enough.\n                 */\n                if (dampingRatio < 1) {\n                    currentVelocity =\n                        t === 0\n                            ? secondsToMilliseconds(initialVelocity)\n                            : calcGeneratorVelocity(resolveSpring, t, current);\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        toString: () => {\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n            return calculatedDuration + \"ms \" + easing;\n        },\n    };\n    return generator;\n}\n\nexport { spring };\n","import { spring } from './spring/index.mjs';\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\nexport { inertia };\n","import { easeInOut } from '../../easing/ease.mjs';\nimport { isEasingArray } from '../../easing/utils/is-easing-array.mjs';\nimport { easingDefinitionToFunction } from '../../easing/utils/map.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { convertOffsetToTimes } from '../../utils/offsets/time.mjs';\n\nfunction defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = \"easeInOut\", }) {\n    /**\n     * Easing functions can be externally defined as strings. Here we convert them\n     * into actual functions.\n     */\n    const easingFunctions = isEasingArray(ease)\n        ? ease.map(easingDefinitionToFunction)\n        : easingDefinitionToFunction(ease);\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = {\n        done: false,\n        value: keyframeValues[0],\n    };\n    /**\n     * Create a times array based on the provided 0-1 offsets\n     */\n    const absoluteTimes = convertOffsetToTimes(\n    // Only use the provided offsets if they're the correct length\n    // TODO Maybe we should warn here if there's a length mismatch\n    times && times.length === keyframeValues.length\n        ? times\n        : defaultOffset(keyframeValues), duration);\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\n        ease: Array.isArray(easingFunctions)\n            ? easingFunctions\n            : defaultEasing(keyframeValues, easingFunctions),\n    });\n    return {\n        calculatedDuration: duration,\n        next: (t) => {\n            state.value = mapTimeToKeyframe(t);\n            state.done = t >= duration;\n            return state;\n        },\n    };\n}\n\nexport { defaultEasing, keyframes };\n","import { time } from '../../../frameloop/sync-time.mjs';\nimport { frame, cancelFrame, frameData } from '../../../frameloop/frame.mjs';\n\nconst frameloopDriver = (update) => {\n    const passTimestamp = ({ timestamp }) => update(timestamp);\n    return {\n        start: () => frame.update(passTimestamp, true),\n        stop: () => cancelFrame(passTimestamp),\n        /**\n         * If we're processing this frame we can use the\n         * framelocked timestamp to keep things in sync.\n         */\n        now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),\n    };\n};\n\nexport { frameloopDriver };\n","import { isGenerator, calcGeneratorDuration } from 'motion-dom';\nimport { invariant, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { mix } from '../../utils/mix/index.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { inertia } from '../generators/inertia.mjs';\nimport { keyframes } from '../generators/keyframes.mjs';\nimport { spring } from '../generators/spring/index.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\nconst generators = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\nconst percentToProgress = (percent) => percent / 100;\n/**\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\n * features we expose publically. Mostly the compatibility is to ensure visual identity\n * between both WAAPI and main thread animations.\n */\nclass MainThreadAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        /**\n         * The time at which the animation was paused.\n         */\n        this.holdTime = null;\n        /**\n         * The time at which the animation was cancelled.\n         */\n        this.cancelTime = null;\n        /**\n         * The current time of the animation.\n         */\n        this.currentTime = 0;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */\n        this.playbackSpeed = 1;\n        /**\n         * The state of the animation to apply when the animation is resolved. This\n         * allows calls to the public API to control the animation before it is resolved,\n         * without us having to resolve it first.\n         */\n        this.pendingPlayState = \"running\";\n        /**\n         * The time at which the animation was started.\n         */\n        this.startTime = null;\n        this.state = \"idle\";\n        /**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */\n        this.stop = () => {\n            this.resolver.cancel();\n            this.isStopped = true;\n            if (this.state === \"idle\")\n                return;\n            this.teardown();\n            const { onStop } = this.options;\n            onStop && onStop();\n        };\n        const { name, motionValue, element, keyframes } = this.options;\n        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\n        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n        this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    flatten() {\n        super.flatten();\n        // If we've already resolved the animation, re-initialise it\n        if (this._resolved) {\n            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));\n        }\n    }\n    initPlayback(keyframes$1) {\n        const { type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;\n        const generatorFactory = isGenerator(type)\n            ? type\n            : generators[type] || keyframes;\n        /**\n         * If our generator doesn't support mixing numbers, we need to replace keyframes with\n         * [0, 100] and then make a function that maps that to the actual keyframes.\n         *\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\n         */\n        let mapPercentToKeyframes;\n        let mirroredGenerator;\n        if (generatorFactory !== keyframes &&\n            typeof keyframes$1[0] !== \"number\") {\n            if (process.env.NODE_ENV !== \"production\") {\n                invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n            }\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [0, 100];\n        }\n        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === \"mirror\") {\n            mirroredGenerator = generatorFactory({\n                ...this.options,\n                keyframes: [...keyframes$1].reverse(),\n                velocity: -velocity,\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        const resolvedDuration = calculatedDuration + repeatDelay;\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n        return {\n            generator,\n            mirroredGenerator,\n            mapPercentToKeyframes,\n            calculatedDuration,\n            resolvedDuration,\n            totalDuration,\n        };\n    }\n    onPostResolved() {\n        const { autoplay = true } = this.options;\n        this.play();\n        if (this.pendingPlayState === \"paused\" || !autoplay) {\n            this.pause();\n        }\n        else {\n            this.state = this.pendingPlayState;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { resolved } = this;\n        // If the animations has failed to resolve, return the final keyframe.\n        if (!resolved) {\n            const { keyframes } = this.options;\n            return { done: true, value: keyframes[keyframes.length - 1] };\n        }\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;\n        if (this.startTime === null)\n            return generator.next(0);\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        }\n        else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        // Update currentTime\n        if (sample) {\n            this.currentTime = timestamp;\n        }\n        else if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime =\n                Math.round(timestamp - this.startTime) * this.speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.speed >= 0\n            ? timeWithoutDelay < 0\n            : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed);\n        if (mapPercentToKeyframes) {\n            state.value = mapPercentToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.speed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null &&\n            (this.state === \"finished\" || (this.state === \"running\" && done));\n        if (isAnimationFinished && finalKeyframe !== undefined) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    get duration() {\n        const { resolved } = this;\n        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\n    }\n    get time() {\n        return millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.holdTime !== null || this.speed === 0) {\n            this.holdTime = newTime;\n        }\n        else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.speed;\n        }\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (!this.resolver.isScheduled) {\n            this.resolver.resume();\n        }\n        if (!this._resolved) {\n            this.pendingPlayState = \"running\";\n            return;\n        }\n        if (this.isStopped)\n            return;\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp));\n        }\n        onPlay && onPlay();\n        const now = this.driver.now();\n        if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        }\n        else if (this.state === \"finished\") {\n            this.startTime = now;\n        }\n        if (this.state === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        this.cancelTime = this.startTime;\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        this.state = \"running\";\n        this.driver.start();\n    }\n    pause() {\n        var _a;\n        if (!this._resolved) {\n            this.pendingPlayState = \"paused\";\n            return;\n        }\n        this.state = \"paused\";\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n    }\n    complete() {\n        if (this.state !== \"running\") {\n            this.play();\n        }\n        this.pendingPlayState = this.state = \"finished\";\n        this.holdTime = null;\n    }\n    finish() {\n        this.teardown();\n        this.state = \"finished\";\n        const { onComplete } = this.options;\n        onComplete && onComplete();\n    }\n    cancel() {\n        if (this.cancelTime !== null) {\n            this.tick(this.cancelTime);\n        }\n        this.teardown();\n        this.updateFinishedPromise();\n    }\n    teardown() {\n        this.state = \"idle\";\n        this.stopDriver();\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        this.startTime = this.cancelTime = null;\n        this.resolver.cancel();\n    }\n    stopDriver() {\n        if (!this.driver)\n            return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(time) {\n        this.startTime = 0;\n        return this.tick(time, true);\n    }\n}\n// Legacy interface\nfunction animateValue(options) {\n    return new MainThreadAnimation(options);\n}\n\nexport { MainThreadAnimation, animateValue };\n","/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\n    \"opacity\",\n    \"clipPath\",\n    \"filter\",\n    \"transform\",\n    // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\n    // or until we implement support for linear() easing.\n    // \"background-color\"\n]);\n\nexport { acceleratedValues };\n","import { memo } from 'motion-utils';\n\nconst supportsWaapi = /*@__PURE__*/ memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\n\nexport { supportsWaapi };\n","import { supportsLinearEasing, attachTimeline, isGenerator, isWaapiSupportedEasing } from 'motion-dom';\nimport { millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { anticipate } from '../../easing/anticipate.mjs';\nimport { backInOut } from '../../easing/back.mjs';\nimport { circInOut } from '../../easing/circ.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { acceleratedValues } from './utils/accelerated-values.mjs';\nimport { startWaapiAnimation } from './waapi/index.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nimport { supportsWaapi } from './waapi/utils/supports-waapi.mjs';\n\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\nfunction requiresPregeneratedKeyframes(options) {\n    return (isGenerator(options.type) ||\n        options.type === \"spring\" ||\n        !isWaapiSupportedEasing(options.ease));\n}\nfunction pregenerateKeyframes(keyframes, options) {\n    /**\n     * Create a main-thread animation to pregenerate keyframes.\n     * We sample this at regular intervals to generate keyframes that we then\n     * linearly interpolate between.\n     */\n    const sampleAnimation = new MainThreadAnimation({\n        ...options,\n        keyframes,\n        repeat: 0,\n        delay: 0,\n        isGenerator: true,\n    });\n    let state = { done: false, value: keyframes[0] };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\n     * we're heading for an infinite loop.\n     */\n    let t = 0;\n    while (!state.done && t < maxDuration) {\n        state = sampleAnimation.sample(t);\n        pregeneratedKeyframes.push(state.value);\n        t += sampleDelta;\n    }\n    return {\n        times: undefined,\n        keyframes: pregeneratedKeyframes,\n        duration: t - sampleDelta,\n        ease: \"linear\",\n    };\n}\nconst unsupportedEasingFunctions = {\n    anticipate,\n    backInOut,\n    circInOut,\n};\nfunction isUnsupportedEase(key) {\n    return key in unsupportedEasingFunctions;\n}\nclass AcceleratedAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        const { name, motionValue, element, keyframes } = this.options;\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes, finalKeyframe) {\n        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;\n        /**\n         * If element has since been unmounted, return false to indicate\n         * the animation failed to initialised.\n         */\n        if (!motionValue.owner || !motionValue.owner.current) {\n            return false;\n        }\n        /**\n         * If the user has provided an easing function name that isn't supported\n         * by WAAPI (like \"anticipate\"), we need to provide the corressponding\n         * function. This will later get converted to a linear() easing function.\n         */\n        if (typeof ease === \"string\" &&\n            supportsLinearEasing() &&\n            isUnsupportedEase(ease)) {\n            ease = unsupportedEasingFunctions[ease];\n        }\n        /**\n         * If this animation needs pre-generated keyframes then generate.\n         */\n        if (requiresPregeneratedKeyframes(this.options)) {\n            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n            keyframes = pregeneratedAnimation.keyframes;\n            // If this is a very short animation, ensure we have\n            // at least two keyframes to animate between as older browsers\n            // can't animate between a single keyframe.\n            if (keyframes.length === 1) {\n                keyframes[1] = keyframes[0];\n            }\n            duration = pregeneratedAnimation.duration;\n            times = pregeneratedAnimation.times;\n            ease = pregeneratedAnimation.ease;\n            type = \"keyframes\";\n        }\n        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\n        // Override the browser calculated startTime with one synchronised to other JS\n        // and WAAPI animations starting this event loop.\n        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        if (this.pendingTimeline) {\n            attachTimeline(animation, this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        }\n        else {\n            /**\n             * Prefer the `onfinish` prop as it's more widely supported than\n             * the `finished` promise.\n             *\n             * Here, we synchronously set the provided MotionValue to the end\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\n             * be removed from the element which would then revert to its old styles.\n             */\n            animation.onfinish = () => {\n                const { onComplete } = this.options;\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.cancel();\n                this.resolveFinishedPromise();\n            };\n        }\n        return {\n            animation,\n            duration,\n            times,\n            type,\n            ease,\n            keyframes: keyframes,\n        };\n    }\n    get duration() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { duration } = resolved;\n        return millisecondsToSeconds(duration);\n    }\n    get time() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { animation } = resolved;\n        return millisecondsToSeconds(animation.currentTime || 0);\n    }\n    set time(newTime) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    get speed() {\n        const { resolved } = this;\n        if (!resolved)\n            return 1;\n        const { animation } = resolved;\n        return animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.playbackRate = newSpeed;\n    }\n    get state() {\n        const { resolved } = this;\n        if (!resolved)\n            return \"idle\";\n        const { animation } = resolved;\n        return animation.playState;\n    }\n    get startTime() {\n        const { resolved } = this;\n        if (!resolved)\n            return null;\n        const { animation } = resolved;\n        // Coerce to number as TypeScript incorrectly types this\n        // as CSSNumberish\n        return animation.startTime;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n    attachTimeline(timeline) {\n        if (!this._resolved) {\n            this.pendingTimeline = timeline;\n        }\n        else {\n            const { resolved } = this;\n            if (!resolved)\n                return noop;\n            const { animation } = resolved;\n            attachTimeline(animation, timeline);\n        }\n        return noop;\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        if (animation.playState === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        animation.play();\n    }\n    pause() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.pause();\n    }\n    stop() {\n        this.resolver.cancel();\n        this.isStopped = true;\n        if (this.state === \"idle\")\n            return;\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation, keyframes, duration, type, ease, times } = resolved;\n        if (animation.playState === \"idle\" ||\n            animation.playState === \"finished\") {\n            return;\n        }\n        /**\n         * WAAPI doesn't natively have any interruption capabilities.\n         *\n         * Rather than read commited styles back out of the DOM, we can\n         * create a renderless JS animation and sample it twice to calculate\n         * its current value, \"previous\" value, and therefore allow\n         * Motion to calculate velocity for any subsequent animation.\n         */\n        if (this.time) {\n            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\n            const sampleAnimation = new MainThreadAnimation({\n                ...options,\n                keyframes,\n                duration,\n                type,\n                ease,\n                times,\n                isGenerator: true,\n            });\n            const sampleTime = secondsToMilliseconds(this.time);\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n        }\n        const { onStop } = this.options;\n        onStop && onStop();\n        this.cancel();\n    }\n    complete() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.finish();\n    }\n    cancel() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.cancel();\n    }\n    static supports(options) {\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n        if (!motionValue ||\n            !motionValue.owner ||\n            !(motionValue.owner.current instanceof HTMLElement)) {\n            return false;\n        }\n        const { onUpdate, transformTemplate } = motionValue.owner.getProps();\n        return (supportsWaapi() &&\n            name &&\n            acceleratedValues.has(name) &&\n            /**\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\n             * no way to read the value from WAAPI every frame.\n             */\n            !onUpdate &&\n            !transformTemplate &&\n            !repeatDelay &&\n            repeatType !== \"mirror\" &&\n            damping !== 0 &&\n            type !== \"inertia\");\n    }\n}\n\nexport { AcceleratedAnimation };\n","import { mapEasingToNativeEasing } from 'motion-dom';\n\nfunction startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = \"loop\", ease = \"easeInOut\", times, } = {}) {\n    const keyframeOptions = { [valueName]: keyframes };\n    if (times)\n        keyframeOptions.offset = times;\n    const easing = mapEasingToNativeEasing(ease, duration);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */\n    if (Array.isArray(easing))\n        keyframeOptions.easing = easing;\n    return element.animate(keyframeOptions, {\n        delay,\n        duration,\n        easing: !Array.isArray(easing) ? easing : \"linear\",\n        fill: \"both\",\n        iterations: repeat + 1,\n        direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\",\n    });\n}\n\nexport { startWaapiAnimation };\n","import { transformProps } from '../../render/html/utils/keys-transform.mjs';\n\nconst underDampedSpring = {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restSpeed: 10,\n};\nconst criticallyDampedSpring = (target) => ({\n    type: \"spring\",\n    stiffness: 550,\n    damping: target === 0 ? 2 * Math.sqrt(550) : 30,\n    restSpeed: 10,\n});\nconst keyframesTransition = {\n    type: \"keyframes\",\n    duration: 0.8,\n};\n/**\n * Default easing curve is a slightly shallower version of\n * the default browser easing curve.\n */\nconst ease = {\n    type: \"keyframes\",\n    ease: [0.25, 0.1, 0.35, 1],\n    duration: 0.3,\n};\nconst getDefaultTransition = (valueKey, { keyframes }) => {\n    if (keyframes.length > 2) {\n        return keyframesTransition;\n    }\n    else if (transformProps.has(valueKey)) {\n        return valueKey.startsWith(\"scale\")\n            ? criticallyDampedSpring(keyframes[1])\n            : underDampedSpring;\n    }\n    return ease;\n};\n\nexport { getDefaultTransition };\n","import { getValueTransition, GroupPlaybackControls } from 'motion-dom';\nimport { secondsToMilliseconds } from 'motion-utils';\nimport { frame } from '../../frameloop/frame.mjs';\nimport { MotionGlobalConfig } from '../../utils/GlobalConfig.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { AcceleratedAnimation } from '../animators/AcceleratedAnimation.mjs';\nimport { MainThreadAnimation } from '../animators/MainThreadAnimation.mjs';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    let options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: \"easeOut\",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n        },\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        options = {\n            ...options,\n            ...getDefaultTransition(name, options),\n        };\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    if (options.duration) {\n        options.duration = secondsToMilliseconds(options.duration);\n    }\n    if (options.repeatDelay) {\n        options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n    }\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        options.duration = 0;\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (instantAnimationState.current ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        options.duration = 0;\n        options.delay = 0;\n    }\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            // We still want to return some animation controls here rather\n            // than returning undefined\n            return new GroupPlaybackControls([]);\n        }\n    }\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\n        return new AcceleratedAnimation(options);\n    }\n    else {\n        return new MainThreadAnimation(options);\n    }\n};\n\nexport { animateMotionValue };\n","/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\n    return !!Object.keys(transition).length;\n}\n\nexport { isTransitionDefined };\n","import { getValueTransition } from 'motion-dom';\nimport { positionalKeys } from '../../render/html/utils/keys-position.mjs';\nimport { setTarget } from '../../render/utils/setters.mjs';\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\nimport { getOptimisedAppearId } from '../optimized-appear/get-appear-id.mjs';\nimport { animateMotionValue } from './motion-value.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\n\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\nfunction animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {\n    var _a;\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\n    if (transitionOverride)\n        transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type &&\n        visualElement.animationState &&\n        visualElement.animationState.getState()[type];\n    for (const key in target) {\n        const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);\n        const valueTarget = target[key];\n        if (valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        const valueTransition = {\n            delay,\n            ...getValueTransition(transition || {}, key),\n        };\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */\n        let isHandoff = false;\n        if (window.MotionHandoffAnimation) {\n            const appearId = getOptimisedAppearId(visualElement);\n            if (appearId) {\n                const startTime = window.MotionHandoffAnimation(appearId, key, frame);\n                if (startTime !== null) {\n                    valueTransition.startTime = startTime;\n                    isHandoff = true;\n                }\n            }\n        }\n        addValueToWillChange(visualElement, key);\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key)\n            ? { type: false }\n            : valueTransition, visualElement, isHandoff));\n        const animation = value.animation;\n        if (animation) {\n            animations.push(animation);\n        }\n    }\n    if (transitionEnd) {\n        Promise.all(animations).then(() => {\n            frame.update(() => {\n                transitionEnd && setTarget(visualElement, transitionEnd);\n            });\n        });\n    }\n    return animations;\n}\n\nexport { animateTarget };\n","import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\n\nfunction animateVariant(visualElement, variant, options = {}) {\n    var _a;\n    const resolved = resolveVariant(visualElement, variant, options.type === \"exit\"\n        ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\n        : undefined);\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getAnimation = resolved\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\n        : () => Promise.resolve();\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size\n        ? (forwardDelay = 0) => {\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : () => Promise.resolve();\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    const { when } = transition;\n    if (when) {\n        const [first, last] = when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation];\n        return first().then(() => last());\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n    const animations = [];\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    const generateStaggerDuration = staggerDirection === 1\n        ? (i = 0) => i * staggerChildren\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach((child, i) => {\n        child.notify(\"AnimationStart\", variant);\n        animations.push(animateVariant(child, variant, {\n            ...options,\n            delay: delayChildren + generateStaggerDuration(i),\n        }).then(() => child.notify(\"AnimationComplete\", variant)));\n    });\n    return Promise.all(animations);\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n\nexport { animateVariant, sortByTreeOrder };\n","import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\nimport { animateVariant } from './visual-element-variant.mjs';\n\nfunction animateVisualElement(visualElement, definition, options = {}) {\n    visualElement.notify(\"AnimationStart\", definition);\n    let animation;\n    if (Array.isArray(definition)) {\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        const resolvedDefinition = typeof definition === \"function\"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));\n    }\n    return animation.then(() => {\n        visualElement.notify(\"AnimationComplete\", definition);\n    });\n}\n\nexport { animateVisualElement };\n","import { camelToDash } from '../../render/dom/utils/camel-to-dash.mjs';\n\nconst optimizedAppearDataId = \"framerAppearId\";\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\n\nexport { optimizedAppearDataAttribute, optimizedAppearDataId };\n","import { optimizedAppearDataAttribute } from './data-id.mjs';\n\nfunction getOptimisedAppearId(visualElement) {\n    return visualElement.props[optimizedAppearDataAttribute];\n}\n\nexport { getOptimisedAppearId };\n","function isAnimationControls(v) {\n    return (v !== null &&\n        typeof v === \"object\" &&\n        typeof v.start === \"function\");\n}\n\nexport { isAnimationControls };\n","const isKeyframesTarget = (v) => {\n    return Array.isArray(v);\n};\n\nexport { isKeyframesTarget };\n","import { isZeroValueString } from '../../utils/is-zero-value-string.mjs';\n\nfunction isNone(value) {\n    if (typeof value === \"number\") {\n        return value === 0;\n    }\n    else if (value !== null) {\n        return value === \"none\" || value === \"0\" || isZeroValueString(value);\n    }\n    else {\n        return true;\n    }\n}\n\nexport { isNone };\n","import { useContext, useId, useEffect, useCallback } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nfunction usePresence(subscribe = true) {\n    const context = useContext(PresenceContext);\n    if (context === null)\n        return [true, null];\n    const { isPresent, onExitComplete, register } = context;\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n    const id = useId();\n    useEffect(() => {\n        if (subscribe)\n            register(id);\n    }, [subscribe]);\n    const safeToRemove = useCallback(() => subscribe && onExitComplete && onExitComplete(id), [id, onExitComplete, subscribe]);\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\nfunction useIsPresent() {\n    return isPresent(useContext(PresenceContext));\n}\nfunction isPresent(context) {\n    return context === null ? true : context.isPresent;\n}\n\nexport { isPresent, useIsPresent, usePresence };\n","\"use client\";\nimport { createContext } from 'react';\n\nconst LayoutGroupContext = createContext({});\n\nexport { LayoutGroupContext };\n","\"use client\";\nimport { createContext } from 'react';\n\nconst LazyContext = createContext({ strict: false });\n\nexport { LazyContext };\n","\"use client\";\nimport { createContext } from 'react';\n\n/**\n * @public\n */\nconst MotionConfigContext = createContext({\n    transformPagePoint: (p) => p,\n    isStatic: false,\n    reducedMotion: \"never\",\n});\n\nexport { MotionConfigContext };\n","import { useContext, useMemo } from 'react';\nimport { MotionContext } from './index.mjs';\nimport { getCurrentTreeVariants } from './utils.mjs';\n\nfunction useCreateMotionContext(props) {\n    const { initial, animate } = getCurrentTreeVariants(props, useContext(MotionContext));\n    return useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\nexport { useCreateMotionContext };\n","import { isVariantLabel } from '../../render/utils/is-variant-label.mjs';\nimport { isControllingVariants } from '../../render/utils/is-controlling-variants.mjs';\n\nfunction getCurrentTreeVariants(props, context) {\n    if (isControllingVariants(props)) {\n        const { initial, animate } = props;\n        return {\n            initial: initial === false || isVariantLabel(initial)\n                ? initial\n                : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined,\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\n\nexport { getCurrentTreeVariants };\n","\"use client\";\nimport { createContext } from 'react';\n\nconst MotionContext = createContext({});\n\nexport { MotionContext };\n","\"use client\";\nimport { createContext } from 'react';\n\n/**\n * @public\n */\nconst PresenceContext = createContext(null);\n\nexport { PresenceContext };\n","\"use client\";\nimport { createContext } from 'react';\n\n/**\n * Internal, exported only for usage in Framer\n */\nconst SwitchLayoutGroupContext = createContext({});\n\nexport { SwitchLayoutGroupContext };\n"],"names":["animateSingleValue","value","keyframes","options","motionValue$1","start","animation","isAnimatable","name","Array","isArray","complex","test","startsWith","isNotNull","getFinalKeyframe","repeat","repeatType","finalKeyframe","resolvedKeyframes","filter","index","length","undefined","BaseAnimation","constructor","autoplay","delay","type","repeatDelay","this","isStopped","hasAttemptedResolve","createdAt","now","updateFinishedPromise","calcStartTime","resolvedAt","resolved","_resolved","onKeyframesResolved","velocity","onComplete","onUpdate","isGenerator","originKeyframe","targetKeyframe","isOriginAnimatable","isTargetAnimatable","current","i","hasKeyframesChanged","canAnimate","resolveFinishedPromise","duration","resolvedAnimation","initPlayback","onPostResolved","then","resolve","reject","currentFinishedPromise","flatten","ease","Promise","calcGeneratorVelocity","resolveValue","t","prevT","Math","max","springDefaults","granular","default","safeMin","findSpring","bounce","mass","envelope","derivative","dampingRatio","clamp","undampedFreq","exponentialDecay","delta","a","b","calcAngularFreq","c","exp","d","e","pow","f","g","initialGuess","result","rootIterations","approximateRoot","isNaN","stiffness","damping","sqrt","durationKeys","physicsKeys","isSpringType","keys","some","key","spring","optionsOrVisualDuration","visualDuration","restSpeed","restDelta","origin","target","state","done","isResolvedFromDuration","springOptions","root","PI","derived","getSpringOptions","initialVelocity","initialDelta","undampedAngularFreq","isGranularScale","abs","resolveSpring","angularFreq","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","generator","calculatedDuration","next","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","toString","easing","progress","inertia","power","timeConstant","bounceDamping","bounceStiffness","modifyTarget","nearestBoundary","v","amplitude","ideal","calcDelta","calcLatest","applyFriction","latest","timeReachedBoundary","spring$1","checkCatchBoundary","hasUpdatedFrame","defaultEasing","values","map","splice","keyframeValues","times","easingFunctions","absoluteTimes","mapTimeToKeyframe","interpolate","frameloopDriver","update","passTimestamp","timestamp","stop","isProcessing","generators","decay","tween","percentToProgress","percent","MainThreadAnimation","super","holdTime","cancelTime","currentTime","playbackSpeed","pendingPlayState","startTime","resolver","cancel","teardown","onStop","motionValue","element","KeyframeResolver$1","KeyframeResolver","scheduleResolve","Object","assign","keyframes$1","generatorFactory","mapPercentToKeyframes","mirroredGenerator","pipe","mix","reverse","resolvedDuration","totalDuration","play","pause","tick","sample","speed","round","timeWithoutDelay","isInDelayPhase","elapsed","frameGenerator","currentIteration","floor","iterationProgress","Boolean","isAnimationFinished","finish","time","newTime","driver","newSpeed","hasChanged","isScheduled","resume","onPlay","_a","complete","stopDriver","acceleratedValues","Set","supportsWaapi","hasOwnProperty","call","Element","prototype","unsupportedEasingFunctions","anticipate","backInOut","circInOut","AcceleratedAnimation","DOMKeyframesResolver","owner","pregeneratedAnimation","sampleAnimation","pregeneratedKeyframes","push","pregenerateKeyframes","valueName","keyframeOptions","offset","animate","fill","iterations","direction","startWaapiAnimation","pendingTimeline","onfinish","set","playbackRate","playState","attachTimeline","timeline","noop","sampleTime","setWithVelocity","supports","HTMLElement","transformTemplate","getProps","has","underDampedSpring","keyframesTransition","getDefaultTransition","valueKey","animateMotionValue","transition","isHandoff","valueTransition","getVelocity","when","_delay","delayChildren","staggerChildren","staggerDirection","from","isTransitionDefined","shouldSkip","skipAnimations","get","shouldBlockAnimation","protectedKeys","needsAnimating","shouldBlock","animateTarget","visualElement","targetAndTransition","transitionOverride","transitionEnd","animations","animationTypeState","animationState","getState","getValue","latestValues","valueTarget","window","MotionHandoffAnimation","appearId","shouldReduceMotion","all","animateVariant","variant","presenceContext","custom","getAnimation","getChildAnimations","variantChildren","size","forwardDelay","maxStaggerDuration","generateStaggerDuration","sort","sortByTreeOrder","forEach","child","notify","animateChildren","first","last","sortNodePosition","animateVisualElement","definition","resolvedDefinition","optimizedAppearDataAttribute","getOptimisedAppearId","props","isAnimationControls","isKeyframesTarget","isNone","usePresence","subscribe","context","useContext","isPresent","onExitComplete","register","id","useId","useEffect","safeToRemove","useCallback","LayoutGroupContext","createContext","LazyContext","strict","MotionConfigContext","transformPagePoint","p","isStatic","reducedMotion","useCreateMotionContext","initial","inherit","getCurrentTreeVariants","MotionContext","useMemo","variantLabelsAsDependency","prop","join","PresenceContext","SwitchLayoutGroupContext"],"sourceRoot":""}