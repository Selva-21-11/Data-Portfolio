{"version":3,"file":"287.84ae4e02c963e1d34f00.js","mappings":"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","sources":["webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/utils/supports/scroll-timeline.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/animation/controls/BaseGroup.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/animation/controls/Group.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/animation/utils/get-value-transition.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/animation/generators/utils/calc-duration.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/animation/generators/utils/is-generator.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/animation/waapi/utils/attach-timeline.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/utils/is-bezier-definition.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/utils/supports/flags.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/utils/supports/memo.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/utils/supports/linear-easing.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/animation/waapi/utils/linear.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/animation/waapi/utils/easing.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/gestures/drag/state/is-active.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/gestures/utils/setup.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/utils/resolve-elements.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/gestures/hover.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/gestures/utils/is-node-or-child.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/gestures/press/utils/is-keyboard-accessible.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/gestures/press/utils/state.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/gestures/press/utils/keyboard.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/gestures/press/index.mjs","webpack://my-3d-portfolio/./node_modules/motion-dom/dist/es/gestures/drag/state/set-active.mjs","webpack://my-3d-portfolio/./node_modules/motion-utils/dist/es/errors.mjs","webpack://my-3d-portfolio/./node_modules/motion-utils/dist/es/memo.mjs","webpack://my-3d-portfolio/./node_modules/motion-utils/dist/es/noop.mjs","webpack://my-3d-portfolio/./node_modules/motion-utils/dist/es/progress.mjs","webpack://my-3d-portfolio/./node_modules/motion-utils/dist/es/time-conversion.mjs"],"sourcesContent":["import { memo } from 'motion-utils';\n\nconst supportsScrollTimeline = memo(() => window.ScrollTimeline !== undefined);\n\nexport { supportsScrollTimeline };\n","import { supportsScrollTimeline } from '../../utils/supports/scroll-timeline.mjs';\n\nclass BaseGroupPlaybackControls {\n    constructor(animations) {\n        // Bound to accomodate common `return animation.stop` pattern\n        this.stop = () => this.runAll(\"stop\");\n        this.animations = animations.filter(Boolean);\n    }\n    get finished() {\n        // Support for new finished Promise and legacy thennable API\n        return Promise.all(this.animations.map((animation) => \"finished\" in animation ? animation.finished : animation));\n    }\n    /**\n     * TODO: Filter out cancelled or stopped animations before returning\n     */\n    getAll(propName) {\n        return this.animations[0][propName];\n    }\n    setAll(propName, newValue) {\n        for (let i = 0; i < this.animations.length; i++) {\n            this.animations[i][propName] = newValue;\n        }\n    }\n    attachTimeline(timeline, fallback) {\n        const subscriptions = this.animations.map((animation) => {\n            if (supportsScrollTimeline() && animation.attachTimeline) {\n                return animation.attachTimeline(timeline);\n            }\n            else if (typeof fallback === \"function\") {\n                return fallback(animation);\n            }\n        });\n        return () => {\n            subscriptions.forEach((cancel, i) => {\n                cancel && cancel();\n                this.animations[i].stop();\n            });\n        };\n    }\n    get time() {\n        return this.getAll(\"time\");\n    }\n    set time(time) {\n        this.setAll(\"time\", time);\n    }\n    get speed() {\n        return this.getAll(\"speed\");\n    }\n    set speed(speed) {\n        this.setAll(\"speed\", speed);\n    }\n    get startTime() {\n        return this.getAll(\"startTime\");\n    }\n    get duration() {\n        let max = 0;\n        for (let i = 0; i < this.animations.length; i++) {\n            max = Math.max(max, this.animations[i].duration);\n        }\n        return max;\n    }\n    runAll(methodName) {\n        this.animations.forEach((controls) => controls[methodName]());\n    }\n    flatten() {\n        this.runAll(\"flatten\");\n    }\n    play() {\n        this.runAll(\"play\");\n    }\n    pause() {\n        this.runAll(\"pause\");\n    }\n    cancel() {\n        this.runAll(\"cancel\");\n    }\n    complete() {\n        this.runAll(\"complete\");\n    }\n}\n\nexport { BaseGroupPlaybackControls };\n","import { BaseGroupPlaybackControls } from './BaseGroup.mjs';\n\n/**\n * TODO: This is a temporary class to support the legacy\n * thennable API\n */\nclass GroupPlaybackControls extends BaseGroupPlaybackControls {\n    then(onResolve, onReject) {\n        return Promise.all(this.animations).then(onResolve).catch(onReject);\n    }\n}\n\nexport { GroupPlaybackControls };\n","function getValueTransition(transition, key) {\n    return transition\n        ? transition[key] ||\n            transition[\"default\"] ||\n            transition\n        : undefined;\n}\n\nexport { getValueTransition };\n","/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxGeneratorDuration = 20000;\nfunction calcGeneratorDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while (!state.done && duration < maxGeneratorDuration) {\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration >= maxGeneratorDuration ? Infinity : duration;\n}\n\nexport { calcGeneratorDuration, maxGeneratorDuration };\n","function isGenerator(type) {\n    return typeof type === \"function\";\n}\n\nexport { isGenerator };\n","function attachTimeline(animation, timeline) {\n    animation.timeline = timeline;\n    animation.onfinish = null;\n}\n\nexport { attachTimeline };\n","const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === \"number\";\n\nexport { isBezierDefinition };\n","/**\n * Add the ability for test suites to manually set support flags\n * to better test more environments.\n */\nconst supportsFlags = {\n    linearEasing: undefined,\n};\n\nexport { supportsFlags };\n","import { memo } from 'motion-utils';\nimport { supportsFlags } from './flags.mjs';\n\nfunction memoSupports(callback, supportsFlag) {\n    const memoized = memo(callback);\n    return () => { var _a; return (_a = supportsFlags[supportsFlag]) !== null && _a !== void 0 ? _a : memoized(); };\n}\n\nexport { memoSupports };\n","import { memoSupports } from './memo.mjs';\n\nconst supportsLinearEasing = /*@__PURE__*/ memoSupports(() => {\n    try {\n        document\n            .createElement(\"div\")\n            .animate({ opacity: 0 }, { easing: \"linear(0, 1)\" });\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}, \"linearEasing\");\n\nexport { supportsLinearEasing };\n","import { progress } from 'motion-utils';\n\nconst generateLinearEasing = (easing, duration, // as milliseconds\nresolution = 10 // as milliseconds\n) => {\n    let points = \"\";\n    const numPoints = Math.max(Math.round(duration / resolution), 2);\n    for (let i = 0; i < numPoints; i++) {\n        points += easing(progress(0, numPoints - 1, i)) + \", \";\n    }\n    return `linear(${points.substring(0, points.length - 2)})`;\n};\n\nexport { generateLinearEasing };\n","import { isBezierDefinition } from '../../../utils/is-bezier-definition.mjs';\nimport { supportsLinearEasing } from '../../../utils/supports/linear-easing.mjs';\nimport { generateLinearEasing } from './linear.mjs';\n\nfunction isWaapiSupportedEasing(easing) {\n    return Boolean((typeof easing === \"function\" && supportsLinearEasing()) ||\n        !easing ||\n        (typeof easing === \"string\" &&\n            (easing in supportedWaapiEasing || supportsLinearEasing())) ||\n        isBezierDefinition(easing) ||\n        (Array.isArray(easing) && easing.every(isWaapiSupportedEasing)));\n}\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\nconst supportedWaapiEasing = {\n    linear: \"linear\",\n    ease: \"ease\",\n    easeIn: \"ease-in\",\n    easeOut: \"ease-out\",\n    easeInOut: \"ease-in-out\",\n    circIn: /*@__PURE__*/ cubicBezierAsString([0, 0.65, 0.55, 1]),\n    circOut: /*@__PURE__*/ cubicBezierAsString([0.55, 0, 1, 0.45]),\n    backIn: /*@__PURE__*/ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\n    backOut: /*@__PURE__*/ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),\n};\nfunction mapEasingToNativeEasing(easing, duration) {\n    if (!easing) {\n        return undefined;\n    }\n    else if (typeof easing === \"function\" && supportsLinearEasing()) {\n        return generateLinearEasing(easing, duration);\n    }\n    else if (isBezierDefinition(easing)) {\n        return cubicBezierAsString(easing);\n    }\n    else if (Array.isArray(easing)) {\n        return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) ||\n            supportedWaapiEasing.easeOut);\n    }\n    else {\n        return supportedWaapiEasing[easing];\n    }\n}\n\nexport { cubicBezierAsString, isWaapiSupportedEasing, mapEasingToNativeEasing, supportedWaapiEasing };\n","const isDragging = {\n    x: false,\n    y: false,\n};\nfunction isDragActive() {\n    return isDragging.x || isDragging.y;\n}\n\nexport { isDragActive, isDragging };\n","import { resolveElements } from '../../utils/resolve-elements.mjs';\n\nfunction setupGesture(elementOrSelector, options) {\n    const elements = resolveElements(elementOrSelector);\n    const gestureAbortController = new AbortController();\n    const eventOptions = {\n        passive: true,\n        ...options,\n        signal: gestureAbortController.signal,\n    };\n    const cancel = () => gestureAbortController.abort();\n    return [elements, eventOptions, cancel];\n}\n\nexport { setupGesture };\n","function resolveElements(elementOrSelector, scope, selectorCache) {\n    var _a;\n    if (elementOrSelector instanceof Element) {\n        return [elementOrSelector];\n    }\n    else if (typeof elementOrSelector === \"string\") {\n        let root = document;\n        if (scope) {\n            // TODO: Refactor to utils package\n            // invariant(\n            //     Boolean(scope.current),\n            //     \"Scope provided, but no element detected.\"\n            // )\n            root = scope.current;\n        }\n        const elements = (_a = selectorCache === null || selectorCache === void 0 ? void 0 : selectorCache[elementOrSelector]) !== null && _a !== void 0 ? _a : root.querySelectorAll(elementOrSelector);\n        return elements ? Array.from(elements) : [];\n    }\n    return Array.from(elementOrSelector);\n}\n\nexport { resolveElements };\n","import { isDragActive } from './drag/state/is-active.mjs';\nimport { setupGesture } from './utils/setup.mjs';\n\n/**\n * Filter out events that are not pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction filterEvents(callback) {\n    return (event) => {\n        if (event.pointerType === \"touch\" || isDragActive())\n            return;\n        callback(event);\n    };\n}\n/**\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\n *\n * @public\n */\nfunction hover(elementOrSelector, onHoverStart, options = {}) {\n    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);\n    const onPointerEnter = filterEvents((enterEvent) => {\n        const { target } = enterEvent;\n        const onHoverEnd = onHoverStart(enterEvent);\n        if (typeof onHoverEnd !== \"function\" || !target)\n            return;\n        const onPointerLeave = filterEvents((leaveEvent) => {\n            onHoverEnd(leaveEvent);\n            target.removeEventListener(\"pointerleave\", onPointerLeave);\n        });\n        target.addEventListener(\"pointerleave\", onPointerLeave, eventOptions);\n    });\n    elements.forEach((element) => {\n        element.addEventListener(\"pointerenter\", onPointerEnter, eventOptions);\n    });\n    return cancel;\n}\n\nexport { hover };\n","/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nconst isNodeOrChild = (parent, child) => {\n    if (!child) {\n        return false;\n    }\n    else if (parent === child) {\n        return true;\n    }\n    else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\n\nexport { isNodeOrChild };\n","const isPrimaryPointer = (event) => {\n    if (event.pointerType === \"mouse\") {\n        return typeof event.button !== \"number\" || event.button <= 0;\n    }\n    else {\n        /**\n         * isPrimary is true for all mice buttons, whereas every touch point\n         * is regarded as its own input. So subsequent concurrent touch points\n         * will be false.\n         *\n         * Specifically match against false here as incomplete versions of\n         * PointerEvents in very old browser might have it set as undefined.\n         */\n        return event.isPrimary !== false;\n    }\n};\n\nexport { isPrimaryPointer };\n","const focusableElements = new Set([\n    \"BUTTON\",\n    \"INPUT\",\n    \"SELECT\",\n    \"TEXTAREA\",\n    \"A\",\n]);\nfunction isElementKeyboardAccessible(element) {\n    return (focusableElements.has(element.tagName) ||\n        element.tabIndex !== -1);\n}\n\nexport { isElementKeyboardAccessible };\n","const isPressing = new WeakSet();\n\nexport { isPressing };\n","import { isPressing } from './state.mjs';\n\n/**\n * Filter out events that are not \"Enter\" keys.\n */\nfunction filterEvents(callback) {\n    return (event) => {\n        if (event.key !== \"Enter\")\n            return;\n        callback(event);\n    };\n}\nfunction firePointerEvent(target, type) {\n    target.dispatchEvent(new PointerEvent(\"pointer\" + type, { isPrimary: true, bubbles: true }));\n}\nconst enableKeyboardPress = (focusEvent, eventOptions) => {\n    const element = focusEvent.currentTarget;\n    if (!element)\n        return;\n    const handleKeydown = filterEvents(() => {\n        if (isPressing.has(element))\n            return;\n        firePointerEvent(element, \"down\");\n        const handleKeyup = filterEvents(() => {\n            firePointerEvent(element, \"up\");\n        });\n        const handleBlur = () => firePointerEvent(element, \"cancel\");\n        element.addEventListener(\"keyup\", handleKeyup, eventOptions);\n        element.addEventListener(\"blur\", handleBlur, eventOptions);\n    });\n    element.addEventListener(\"keydown\", handleKeydown, eventOptions);\n    /**\n     * Add an event listener that fires on blur to remove the keydown events.\n     */\n    element.addEventListener(\"blur\", () => element.removeEventListener(\"keydown\", handleKeydown), eventOptions);\n};\n\nexport { enableKeyboardPress };\n","import { isDragActive } from '../drag/state/is-active.mjs';\nimport { isNodeOrChild } from '../utils/is-node-or-child.mjs';\nimport { isPrimaryPointer } from '../utils/is-primary-pointer.mjs';\nimport { setupGesture } from '../utils/setup.mjs';\nimport { isElementKeyboardAccessible } from './utils/is-keyboard-accessible.mjs';\nimport { enableKeyboardPress } from './utils/keyboard.mjs';\nimport { isPressing } from './utils/state.mjs';\n\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction isValidPressEvent(event) {\n    return isPrimaryPointer(event) && !isDragActive();\n}\n/**\n * Create a press gesture.\n *\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\n *\n * This is different to a browser's `\"click\"` event, which does\n * respond to keyboards but only for the `\"click\"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\nfunction press(elementOrSelector, onPressStart, options = {}) {\n    const [elements, eventOptions, cancelEvents] = setupGesture(elementOrSelector, options);\n    const startPress = (startEvent) => {\n        const element = startEvent.currentTarget;\n        if (!isValidPressEvent(startEvent) || isPressing.has(element))\n            return;\n        isPressing.add(element);\n        const onPressEnd = onPressStart(startEvent);\n        const onPointerEnd = (endEvent, success) => {\n            window.removeEventListener(\"pointerup\", onPointerUp);\n            window.removeEventListener(\"pointercancel\", onPointerCancel);\n            if (!isValidPressEvent(endEvent) || !isPressing.has(element)) {\n                return;\n            }\n            isPressing.delete(element);\n            if (typeof onPressEnd === \"function\") {\n                onPressEnd(endEvent, { success });\n            }\n        };\n        const onPointerUp = (upEvent) => {\n            onPointerEnd(upEvent, options.useGlobalTarget ||\n                isNodeOrChild(element, upEvent.target));\n        };\n        const onPointerCancel = (cancelEvent) => {\n            onPointerEnd(cancelEvent, false);\n        };\n        window.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n        window.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\n    };\n    elements.forEach((element) => {\n        if (!isElementKeyboardAccessible(element) &&\n            element.getAttribute(\"tabindex\") === null) {\n            element.tabIndex = 0;\n        }\n        const target = options.useGlobalTarget ? window : element;\n        target.addEventListener(\"pointerdown\", startPress, eventOptions);\n        element.addEventListener(\"focus\", (event) => enableKeyboardPress(event, eventOptions), eventOptions);\n    });\n    return cancelEvents;\n}\n\nexport { press };\n","import { isDragging } from './is-active.mjs';\n\nfunction setDragLock(axis) {\n    if (axis === \"x\" || axis === \"y\") {\n        if (isDragging[axis]) {\n            return null;\n        }\n        else {\n            isDragging[axis] = true;\n            return () => {\n                isDragging[axis] = false;\n            };\n        }\n    }\n    else {\n        if (isDragging.x || isDragging.y) {\n            return null;\n        }\n        else {\n            isDragging.x = isDragging.y = true;\n            return () => {\n                isDragging.x = isDragging.y = false;\n            };\n        }\n    }\n}\n\nexport { setDragLock };\n","import { noop } from './noop.mjs';\n\nlet warning = noop;\nlet invariant = noop;\nif (process.env.NODE_ENV !== \"production\") {\n    warning = (check, message) => {\n        if (!check && typeof console !== \"undefined\") {\n            console.warn(message);\n        }\n    };\n    invariant = (check, message) => {\n        if (!check) {\n            throw new Error(message);\n        }\n    };\n}\n\nexport { invariant, warning };\n","/*#__NO_SIDE_EFFECTS__*/\nfunction memo(callback) {\n    let result;\n    return () => {\n        if (result === undefined)\n            result = callback();\n        return result;\n    };\n}\n\nexport { memo };\n","/*#__NO_SIDE_EFFECTS__*/\nconst noop = (any) => any;\n\nexport { noop };\n","/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\n/*#__NO_SIDE_EFFECTS__*/\nconst progress = (from, to, value) => {\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nexport { progress };\n","/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n/*#__NO_SIDE_EFFECTS__*/\nconst secondsToMilliseconds = (seconds) => seconds * 1000;\n/*#__NO_SIDE_EFFECTS__*/\nconst millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\n\nexport { millisecondsToSeconds, secondsToMilliseconds };\n"],"names":["supportsScrollTimeline","memo","undefined","window","ScrollTimeline","constructor","animations","this","stop","runAll","filter","Boolean","finished","Promise","all","map","animation","getAll","propName","setAll","newValue","i","length","attachTimeline","timeline","fallback","subscriptions","forEach","cancel","time","speed","startTime","duration","max","Math","methodName","controls","flatten","play","pause","complete","GroupPlaybackControls","then","onResolve","onReject","catch","transition","key","maxGeneratorDuration","calcGeneratorDuration","generator","state","next","done","Infinity","isGenerator","type","onfinish","isBezierDefinition","easing","Array","isArray","supportsFlags","linearEasing","memoSupports","callback","supportsFlag","memoized","_a","supportsLinearEasing","document","createElement","animate","opacity","e","generateLinearEasing","resolution","points","numPoints","round","progress","substring","isWaapiSupportedEasing","supportedWaapiEasing","every","cubicBezierAsString","a","b","c","d","linear","ease","easeIn","easeOut","easeInOut","circIn","circOut","backIn","backOut","segmentEasing","isDragging","x","y","isDragActive","setupGesture","elementOrSelector","options","elements","scope","selectorCache","Element","root","current","querySelectorAll","from","resolveElements","gestureAbortController","AbortController","passive","signal","abort","filterEvents","event","pointerType","hover","onHoverStart","eventOptions","onPointerEnter","enterEvent","target","onHoverEnd","onPointerLeave","leaveEvent","removeEventListener","addEventListener","element","isNodeOrChild","parent","child","parentElement","isPrimaryPointer","button","isPrimary","focusableElements","Set","isPressing","WeakSet","firePointerEvent","dispatchEvent","PointerEvent","bubbles","enableKeyboardPress","focusEvent","currentTarget","handleKeydown","has","handleKeyup","isValidPressEvent","press","onPressStart","cancelEvents","startPress","startEvent","add","onPressEnd","onPointerEnd","endEvent","success","onPointerUp","onPointerCancel","delete","upEvent","useGlobalTarget","cancelEvent","tagName","tabIndex","isElementKeyboardAccessible","getAttribute","setDragLock","axis","warning","invariant","result","noop","any","to","value","toFromDifference","secondsToMilliseconds","seconds","millisecondsToSeconds","milliseconds"],"sourceRoot":""}