{"version":3,"file":"758.84f9363589e941de0f22.js","mappings":"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","sources":["webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/anticipate.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/back.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/circ.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/ease.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/modifiers/mirror.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/modifiers/reverse.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/utils/is-easing-array.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/utils/map.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/events/add-dom-event.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/events/add-pointer-event.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/events/event-info.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/frameloop/batcher.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/frameloop/render-step.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/frameloop/frame.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/frameloop/microtask.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/frameloop/sync-time.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/gestures/drag/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/gestures/focus.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/gestures/hover.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/gestures/pan/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/gestures/press.mjs"],"sourcesContent":["import { backIn } from './back.mjs';\n\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n\nexport { anticipate };\n","import { cubicBezier } from './cubic-bezier.mjs';\nimport { mirrorEasing } from './modifiers/mirror.mjs';\nimport { reverseEasing } from './modifiers/reverse.mjs';\n\nconst backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = /*@__PURE__*/ reverseEasing(backOut);\nconst backInOut = /*@__PURE__*/ mirrorEasing(backIn);\n\nexport { backIn, backInOut, backOut };\n","import { mirrorEasing } from './modifiers/mirror.mjs';\nimport { reverseEasing } from './modifiers/reverse.mjs';\n\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circIn);\n\nexport { circIn, circInOut, circOut };\n","import { noop } from 'motion-utils';\n\n/*\n  Bezier function generator\n  This has been modified from Gaëtan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\n    t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noop;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };\n","import { cubicBezier } from './cubic-bezier.mjs';\n\nconst easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);\nconst easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);\nconst easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);\n\nexport { easeIn, easeInOut, easeOut };\n","// Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\nexport { mirrorEasing };\n","// Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\n\nexport { reverseEasing };\n","const isEasingArray = (ease) => {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\nexport { isEasingArray };\n","import { isBezierDefinition } from 'motion-dom';\nimport { invariant, noop } from 'motion-utils';\nimport { anticipate } from '../anticipate.mjs';\nimport { backIn, backInOut, backOut } from '../back.mjs';\nimport { circIn, circInOut, circOut } from '../circ.mjs';\nimport { cubicBezier } from '../cubic-bezier.mjs';\nimport { easeIn, easeInOut, easeOut } from '../ease.mjs';\n\nconst easingLookup = {\n    linear: noop,\n    easeIn,\n    easeInOut,\n    easeOut,\n    circIn,\n    circInOut,\n    circOut,\n    backIn,\n    backInOut,\n    backOut,\n    anticipate,\n};\nconst easingDefinitionToFunction = (definition) => {\n    if (isBezierDefinition(definition)) {\n        // If cubic bezier definition, create bezier curve\n        invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n        const [x1, y1, x2, y2] = definition;\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === \"string\") {\n        // Else lookup from table\n        invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\n        return easingLookup[definition];\n    }\n    return definition;\n};\n\nexport { easingDefinitionToFunction };\n","function addDomEvent(target, eventName, handler, options = { passive: true }) {\n    target.addEventListener(eventName, handler, options);\n    return () => target.removeEventListener(eventName, handler);\n}\n\nexport { addDomEvent };\n","import { addDomEvent } from './add-dom-event.mjs';\nimport { addPointerInfo } from './event-info.mjs';\n\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, eventName, addPointerInfo(handler), options);\n}\n\nexport { addPointerEvent };\n","import { isPrimaryPointer } from 'motion-dom';\n\nfunction extractEventInfo(event) {\n    return {\n        point: {\n            x: event.pageX,\n            y: event.pageY,\n        },\n    };\n}\nconst addPointerInfo = (handler) => {\n    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));\n};\n\nexport { addPointerInfo, extractEventInfo };\n","import { MotionGlobalConfig } from '../utils/GlobalConfig.mjs';\nimport { createRenderStep } from './render-step.mjs';\n\nconst stepsOrder = [\n    \"read\", // Read\n    \"resolveKeyframes\", // Write/Read/Write/Read\n    \"update\", // Compute\n    \"preRender\", // Compute\n    \"render\", // Write\n    \"postRender\", // Compute\n];\nconst maxElapsed = 40;\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n    let runNextFrame = false;\n    let useDefaultElapsed = true;\n    const state = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    const flagRunNextFrame = () => (runNextFrame = true);\n    const steps = stepsOrder.reduce((acc, key) => {\n        acc[key] = createRenderStep(flagRunNextFrame);\n        return acc;\n    }, {});\n    const { read, resolveKeyframes, update, preRender, render, postRender } = steps;\n    const processBatch = () => {\n        const timestamp = MotionGlobalConfig.useManualTiming\n            ? state.timestamp\n            : performance.now();\n        runNextFrame = false;\n        state.delta = useDefaultElapsed\n            ? 1000 / 60\n            : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\n        state.timestamp = timestamp;\n        state.isProcessing = true;\n        // Unrolled render loop for better per-frame performance\n        read.process(state);\n        resolveKeyframes.process(state);\n        update.process(state);\n        preRender.process(state);\n        render.process(state);\n        postRender.process(state);\n        state.isProcessing = false;\n        if (runNextFrame && allowKeepAlive) {\n            useDefaultElapsed = false;\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const wake = () => {\n        runNextFrame = true;\n        useDefaultElapsed = true;\n        if (!state.isProcessing) {\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const schedule = stepsOrder.reduce((acc, key) => {\n        const step = steps[key];\n        acc[key] = (process, keepAlive = false, immediate = false) => {\n            if (!runNextFrame)\n                wake();\n            return step.schedule(process, keepAlive, immediate);\n        };\n        return acc;\n    }, {});\n    const cancel = (process) => {\n        for (let i = 0; i < stepsOrder.length; i++) {\n            steps[stepsOrder[i]].cancel(process);\n        }\n    };\n    return { schedule, cancel, state, steps };\n}\n\nexport { createRenderBatcher, stepsOrder };\n","function createRenderStep(runNextFrame) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Set();\n    let nextFrame = new Set();\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    let latestFrameData = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    function triggerCallback(callback) {\n        if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n        }\n        callback(latestFrameData);\n    }\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (!queue.has(callback))\n                queue.add(callback);\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.delete(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            latestFrameData = frameData;\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Execute this frame\n            thisFrame.forEach(triggerCallback);\n            // Clear the frame so no callbacks remain. This is to avoid\n            // memory leaks should this render step not run for a while.\n            thisFrame.clear();\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nexport { createRenderStep };\n","import { noop } from 'motion-utils';\nimport { createRenderBatcher } from './batcher.mjs';\n\nconst { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : noop, true);\n\nexport { cancelFrame, frame, frameData, frameSteps };\n","import { createRenderBatcher } from './batcher.mjs';\n\nconst { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);\n\nexport { cancelMicrotask, microtask };\n","import { MotionGlobalConfig } from '../utils/GlobalConfig.mjs';\nimport { frameData } from './frame.mjs';\n\nlet now;\nfunction clearTime() {\n    now = undefined;\n}\n/**\n * An eventloop-synchronous alternative to performance.now().\n *\n * Ensures that time measurements remain consistent within a synchronous context.\n * Usually calling performance.now() twice within the same synchronous context\n * will return different values which isn't useful for animations when we're usually\n * trying to sync animations to the same frame.\n */\nconst time = {\n    now: () => {\n        if (now === undefined) {\n            time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming\n                ? frameData.timestamp\n                : performance.now());\n        }\n        return now;\n    },\n    set: (newTime) => {\n        now = newTime;\n        queueMicrotask(clearTime);\n    },\n};\n\nexport { time };\n","import { progress } from 'motion-utils';\nimport { calcLength } from '../../../projection/geometry/delta-calc.mjs';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { mixNumber } from '../../../utils/mix/number.mjs';\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, { min, max }, elastic) {\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber(min, point, elastic.min)\n            : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber(max, point, elastic.max)\n            : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined\n            ? axis.max + max - (axis.max - axis.min)\n            : undefined,\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    let min = constraintsAxis.min - layoutAxis.min;\n    let max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        [min, max] = [max, min];\n    }\n    return { min, max };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    let origin = 0.5;\n    const sourceLength = calcLength(source);\n    const targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = progress(source.min, source.max - targetLength, target.min);\n    }\n    return clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n    const relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nconst defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic = defaultElastic) {\n    if (dragElastic === false) {\n        dragElastic = 0;\n    }\n    else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    return typeof dragElastic === \"number\"\n        ? dragElastic\n        : dragElastic[label] || 0;\n}\n\nexport { applyConstraints, calcOrigin, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };\n","import { invariant } from 'motion-utils';\nimport { setDragLock } from 'motion-dom';\nimport { PanSession } from '../pan/PanSession.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { applyConstraints, calcRelativeConstraints, resolveDragElastic, rebaseAxisConstraints, calcViewportConstraints, calcOrigin, defaultElastic } from './utils/constraints.mjs';\nimport { createBox } from '../../projection/geometry/models.mjs';\nimport { eachAxis } from '../../projection/utils/each-axis.mjs';\nimport { measurePageBox } from '../../projection/utils/measure.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { convertBoxToBoundingBox, convertBoundingBoxToBox } from '../../projection/geometry/conversion.mjs';\nimport { addDomEvent } from '../../events/add-dom-event.mjs';\nimport { calcLength } from '../../projection/geometry/delta-calc.mjs';\nimport { mixNumber } from '../../utils/mix/number.mjs';\nimport { percent } from '../../value/types/numbers/units.mjs';\nimport { animateMotionValue } from '../../animation/interfaces/motion-value.mjs';\nimport { getContextWindow } from '../../utils/get-context-window.mjs';\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\n\nconst elementDragControls = new WeakMap();\n/**\n *\n */\n// let latestPointerEvent: PointerEvent\nclass VisualElementDragControls {\n    constructor(visualElement) {\n        this.openDragLock = null;\n        this.isDragging = false;\n        this.currentDirection = null;\n        this.originPoint = { x: 0, y: 0 };\n        /**\n         * The permitted boundaries of travel, in pixels.\n         */\n        this.constraints = false;\n        this.hasMutatedConstraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         */\n        this.elastic = createBox();\n        this.visualElement = visualElement;\n    }\n    start(originEvent, { snapToCursor = false } = {}) {\n        /**\n         * Don't start dragging if this component is exiting\n         */\n        const { presenceContext } = this.visualElement;\n        if (presenceContext && presenceContext.isPresent === false)\n            return;\n        const onSessionStart = (event) => {\n            const { dragSnapToOrigin } = this.getProps();\n            // Stop or pause any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();\n            if (snapToCursor) {\n                this.snapToCursor(extractEventInfo(event).point);\n            }\n        };\n        const onStart = (event, info) => {\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            const { drag, dragPropagation, onDragStart } = this.getProps();\n            if (drag && !dragPropagation) {\n                if (this.openDragLock)\n                    this.openDragLock();\n                this.openDragLock = setDragLock(drag);\n                // If we don 't have the lock, don't start dragging\n                if (!this.openDragLock)\n                    return;\n            }\n            this.isDragging = true;\n            this.currentDirection = null;\n            this.resolveConstraints();\n            if (this.visualElement.projection) {\n                this.visualElement.projection.isAnimationBlocked = true;\n                this.visualElement.projection.target = undefined;\n            }\n            /**\n             * Record gesture origin\n             */\n            eachAxis((axis) => {\n                let current = this.getAxisMotionValue(axis).get() || 0;\n                /**\n                 * If the MotionValue is a percentage value convert to px\n                 */\n                if (percent.test(current)) {\n                    const { projection } = this.visualElement;\n                    if (projection && projection.layout) {\n                        const measuredAxis = projection.layout.layoutBox[axis];\n                        if (measuredAxis) {\n                            const length = calcLength(measuredAxis);\n                            current = length * (parseFloat(current) / 100);\n                        }\n                    }\n                }\n                this.originPoint[axis] = current;\n            });\n            // Fire onDragStart event\n            if (onDragStart) {\n                frame.postRender(() => onDragStart(event, info));\n            }\n            addValueToWillChange(this.visualElement, \"transform\");\n            const { animationState } = this.visualElement;\n            animationState && animationState.setActive(\"whileDrag\", true);\n        };\n        const onMove = (event, info) => {\n            // latestPointerEvent = event\n            const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !this.openDragLock)\n                return;\n            const { offset } = info;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && this.currentDirection === null) {\n                this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (this.currentDirection !== null) {\n                    onDirectionLock && onDirectionLock(this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            this.updateAxis(\"x\", info.point, offset);\n            this.updateAxis(\"y\", info.point, offset);\n            /**\n             * Ideally we would leave the renderer to fire naturally at the end of\n             * this frame but if the element is about to change layout as the result\n             * of a re-render we want to ensure the browser can read the latest\n             * bounding box to ensure the pointer and element don't fall out of sync.\n             */\n            this.visualElement.render();\n            /**\n             * This must fire after the render call as it might trigger a state\n             * change which itself might trigger a layout update.\n             */\n            onDrag && onDrag(event, info);\n        };\n        const onSessionEnd = (event, info) => this.stop(event, info);\n        const resumeAnimation = () => eachAxis((axis) => {\n            var _a;\n            return this.getAnimationState(axis) === \"paused\" &&\n                ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());\n        });\n        const { dragSnapToOrigin } = this.getProps();\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart,\n            onStart,\n            onMove,\n            onSessionEnd,\n            resumeAnimation,\n        }, {\n            transformPagePoint: this.visualElement.getTransformPagePoint(),\n            dragSnapToOrigin,\n            contextWindow: getContextWindow(this.visualElement),\n        });\n    }\n    stop(event, info) {\n        const isDragging = this.isDragging;\n        this.cancel();\n        if (!isDragging)\n            return;\n        const { velocity } = info;\n        this.startAnimation(velocity);\n        const { onDragEnd } = this.getProps();\n        if (onDragEnd) {\n            frame.postRender(() => onDragEnd(event, info));\n        }\n    }\n    cancel() {\n        this.isDragging = false;\n        const { projection, animationState } = this.visualElement;\n        if (projection) {\n            projection.isAnimationBlocked = false;\n        }\n        this.panSession && this.panSession.end();\n        this.panSession = undefined;\n        const { dragPropagation } = this.getProps();\n        if (!dragPropagation && this.openDragLock) {\n            this.openDragLock();\n            this.openDragLock = null;\n        }\n        animationState && animationState.setActive(\"whileDrag\", false);\n    }\n    updateAxis(axis, _point, offset) {\n        const { drag } = this.getProps();\n        // If we're not dragging this axis, do an early return.\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection))\n            return;\n        const axisValue = this.getAxisMotionValue(axis);\n        let next = this.originPoint[axis] + offset[axis];\n        // Apply constraints\n        if (this.constraints && this.constraints[axis]) {\n            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n        }\n        axisValue.set(next);\n    }\n    resolveConstraints() {\n        var _a;\n        const { dragConstraints, dragElastic } = this.getProps();\n        const layout = this.visualElement.projection &&\n            !this.visualElement.projection.layout\n            ? this.visualElement.projection.measure(false)\n            : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;\n        const prevConstraints = this.constraints;\n        if (dragConstraints && isRefObject(dragConstraints)) {\n            if (!this.constraints) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        }\n        else {\n            if (dragConstraints && layout) {\n                this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\n            }\n            else {\n                this.constraints = false;\n            }\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */\n        if (prevConstraints !== this.constraints &&\n            layout &&\n            this.constraints &&\n            !this.hasMutatedConstraints) {\n            eachAxis((axis) => {\n                if (this.constraints !== false &&\n                    this.getAxisMotionValue(axis)) {\n                    this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\n                }\n            });\n        }\n    }\n    resolveRefConstraints() {\n        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();\n        if (!constraints || !isRefObject(constraints))\n            return false;\n        const constraintsElement = constraints.current;\n        invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n        const { projection } = this.visualElement;\n        // TODO\n        if (!projection || !projection.layout)\n            return false;\n        const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    }\n    startAnimation(velocity) {\n        const { drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = this.getProps();\n        const constraints = this.constraints || {};\n        const momentumAnimations = eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, this.currentDirection)) {\n                return;\n            }\n            let transition = (constraints && constraints[axis]) || {};\n            if (dragSnapToOrigin)\n                transition = { min: 0, max: 0 };\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            const bounceStiffness = dragElastic ? 200 : 1000000;\n            const bounceDamping = dragElastic ? 40 : 10000000;\n            const inertia = {\n                type: \"inertia\",\n                velocity: dragMomentum ? velocity[axis] : 0,\n                bounceStiffness,\n                bounceDamping,\n                timeConstant: 750,\n                restDelta: 1,\n                restSpeed: 10,\n                ...dragTransition,\n                ...transition,\n            };\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return this.startAxisValueAnimation(axis, inertia);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n    }\n    startAxisValueAnimation(axis, transition) {\n        const axisValue = this.getAxisMotionValue(axis);\n        addValueToWillChange(this.visualElement, axis);\n        return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));\n    }\n    stopAnimation() {\n        eachAxis((axis) => this.getAxisMotionValue(axis).stop());\n    }\n    pauseAnimation() {\n        eachAxis((axis) => { var _a; return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause(); });\n    }\n    getAnimationState(axis) {\n        var _a;\n        return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;\n    }\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    getAxisMotionValue(axis) {\n        const dragKey = `_drag${axis.toUpperCase()}`;\n        const props = this.visualElement.getProps();\n        const externalMotionValue = props[dragKey];\n        return externalMotionValue\n            ? externalMotionValue\n            : this.visualElement.getValue(axis, (props.initial\n                ? props.initial[axis]\n                : undefined) || 0);\n    }\n    snapToCursor(point) {\n        eachAxis((axis) => {\n            const { drag } = this.getProps();\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, this.currentDirection))\n                return;\n            const { projection } = this.visualElement;\n            const axisValue = this.getAxisMotionValue(axis);\n            if (projection && projection.layout) {\n                const { min, max } = projection.layout.layoutBox[axis];\n                axisValue.set(point[axis] - mixNumber(min, max, 0.5));\n            }\n        });\n    }\n    /**\n     * When the viewport resizes we want to check if the measured constraints\n     * have changed and, if so, reposition the element within those new constraints\n     * relative to where it was before the resize.\n     */\n    scalePositionWithinConstraints() {\n        if (!this.visualElement.current)\n            return;\n        const { drag, dragConstraints } = this.getProps();\n        const { projection } = this.visualElement;\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints)\n            return;\n        /**\n         * Stop current animations as there can be visual glitching if we try to do\n         * this mid-animation\n         */\n        this.stopAnimation();\n        /**\n         * Record the relative position of the dragged element relative to the\n         * constraints box and save as a progress value.\n         */\n        const boxProgress = { x: 0, y: 0 };\n        eachAxis((axis) => {\n            const axisValue = this.getAxisMotionValue(axis);\n            if (axisValue && this.constraints !== false) {\n                const latest = axisValue.get();\n                boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);\n            }\n        });\n        /**\n         * Update the layout of this element and resolve the latest drag constraints\n         */\n        const { transformTemplate } = this.visualElement.getProps();\n        this.visualElement.current.style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\";\n        projection.root && projection.root.updateScroll();\n        projection.updateLayout();\n        this.resolveConstraints();\n        /**\n         * For each axis, calculate the current progress of the layout axis\n         * within the new constraints.\n         */\n        eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, null))\n                return;\n            /**\n             * Calculate a new transform based on the previous box progress\n             */\n            const axisValue = this.getAxisMotionValue(axis);\n            const { min, max } = this.constraints[axis];\n            axisValue.set(mixNumber(min, max, boxProgress[axis]));\n        });\n    }\n    addListeners() {\n        if (!this.visualElement.current)\n            return;\n        elementDragControls.set(this.visualElement, this);\n        const element = this.visualElement.current;\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        const stopPointerListener = addPointerEvent(element, \"pointerdown\", (event) => {\n            const { drag, dragListener = true } = this.getProps();\n            drag && dragListener && this.start(event);\n        });\n        const measureDragConstraints = () => {\n            const { dragConstraints } = this.getProps();\n            if (isRefObject(dragConstraints) && dragConstraints.current) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        };\n        const { projection } = this.visualElement;\n        const stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n        if (projection && !projection.layout) {\n            projection.root && projection.root.updateScroll();\n            projection.updateLayout();\n        }\n        frame.read(measureDragConstraints);\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        const stopResizeListener = addDomEvent(window, \"resize\", () => this.scalePositionWithinConstraints());\n        /**\n         * If the element's layout changes, calculate the delta and apply that to\n         * the drag gesture's origin point.\n         */\n        const stopLayoutUpdateListener = projection.addEventListener(\"didUpdate\", (({ delta, hasLayoutChanged }) => {\n            if (this.isDragging && hasLayoutChanged) {\n                eachAxis((axis) => {\n                    const motionValue = this.getAxisMotionValue(axis);\n                    if (!motionValue)\n                        return;\n                    this.originPoint[axis] += delta[axis].translate;\n                    motionValue.set(motionValue.get() + delta[axis].translate);\n                });\n                this.visualElement.render();\n            }\n        }));\n        return () => {\n            stopResizeListener();\n            stopPointerListener();\n            stopMeasureLayoutListener();\n            stopLayoutUpdateListener && stopLayoutUpdateListener();\n        };\n    }\n    getProps() {\n        const props = this.visualElement.getProps();\n        const { drag = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true, } = props;\n        return {\n            ...props,\n            drag,\n            dragDirectionLock,\n            dragPropagation,\n            dragConstraints,\n            dragElastic,\n            dragMomentum,\n        };\n    }\n}\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold = 10) {\n    let direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\n\nexport { VisualElementDragControls, elementDragControls };\n","import { Feature } from '../../motion/features/Feature.mjs';\nimport { noop } from 'motion-utils';\nimport { VisualElementDragControls } from './VisualElementDragControls.mjs';\n\nclass DragGesture extends Feature {\n    constructor(node) {\n        super(node);\n        this.removeGroupControls = noop;\n        this.removeListeners = noop;\n        this.controls = new VisualElementDragControls(node);\n    }\n    mount() {\n        // If we've been provided a DragControls for manual control over the drag gesture,\n        // subscribe this component to it on mount.\n        const { dragControls } = this.node.getProps();\n        if (dragControls) {\n            this.removeGroupControls = dragControls.subscribe(this.controls);\n        }\n        this.removeListeners = this.controls.addListeners() || noop;\n    }\n    unmount() {\n        this.removeGroupControls();\n        this.removeListeners();\n    }\n}\n\nexport { DragGesture };\n","import { addDomEvent } from '../events/add-dom-event.mjs';\nimport { Feature } from '../motion/features/Feature.mjs';\nimport { pipe } from '../utils/pipe.mjs';\n\nclass FocusGesture extends Feature {\n    constructor() {\n        super(...arguments);\n        this.isActive = false;\n    }\n    onFocus() {\n        let isFocusVisible = false;\n        /**\n         * If this element doesn't match focus-visible then don't\n         * apply whileHover. But, if matches throws that focus-visible\n         * is not a valid selector then in that browser outline styles will be applied\n         * to the element by default and we want to match that behaviour with whileFocus.\n         */\n        try {\n            isFocusVisible = this.node.current.matches(\":focus-visible\");\n        }\n        catch (e) {\n            isFocusVisible = true;\n        }\n        if (!isFocusVisible || !this.node.animationState)\n            return;\n        this.node.animationState.setActive(\"whileFocus\", true);\n        this.isActive = true;\n    }\n    onBlur() {\n        if (!this.isActive || !this.node.animationState)\n            return;\n        this.node.animationState.setActive(\"whileFocus\", false);\n        this.isActive = false;\n    }\n    mount() {\n        this.unmount = pipe(addDomEvent(this.node.current, \"focus\", () => this.onFocus()), addDomEvent(this.node.current, \"blur\", () => this.onBlur()));\n    }\n    unmount() { }\n}\n\nexport { FocusGesture };\n","import { Feature } from '../motion/features/Feature.mjs';\nimport { hover } from 'motion-dom';\nimport { extractEventInfo } from '../events/event-info.mjs';\nimport { frame } from '../frameloop/frame.mjs';\n\nfunction handleHoverEvent(node, event, lifecycle) {\n    const { props } = node;\n    if (node.animationState && props.whileHover) {\n        node.animationState.setActive(\"whileHover\", lifecycle === \"Start\");\n    }\n    const eventName = (\"onHover\" + lifecycle);\n    const callback = props[eventName];\n    if (callback) {\n        frame.postRender(() => callback(event, extractEventInfo(event)));\n    }\n}\nclass HoverGesture extends Feature {\n    mount() {\n        const { current } = this.node;\n        if (!current)\n            return;\n        this.unmount = hover(current, (startEvent) => {\n            handleHoverEvent(this.node, startEvent, \"Start\");\n            return (endEvent) => handleHoverEvent(this.node, endEvent, \"End\");\n        });\n    }\n    unmount() { }\n}\n\nexport { HoverGesture };\n","import { isPrimaryPointer } from 'motion-dom';\nimport { secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { frame, cancelFrame, frameData } from '../../frameloop/frame.mjs';\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        /**\n         * @internal\n         */\n        this.contextWindow = window;\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({ ...point, timestamp });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            frame.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            this.end();\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n            if (this.dragSnapToOrigin)\n                resumeAnimation && resumeAnimation();\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const panInfo = getPanInfo(event.type === \"pointercancel\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event))\n            return;\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        this.contextWindow = contextWindow || window;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [{ ...point, timestamp }];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelFrame(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n","import { PanSession } from './PanSession.mjs';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { Feature } from '../../motion/features/Feature.mjs';\nimport { noop } from 'motion-utils';\nimport { getContextWindow } from '../../utils/get-context-window.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\n\nconst asyncHandler = (handler) => (event, info) => {\n    if (handler) {\n        frame.postRender(() => handler(event, info));\n    }\n};\nclass PanGesture extends Feature {\n    constructor() {\n        super(...arguments);\n        this.removePointerDownListener = noop;\n    }\n    onPointerDown(pointerDownEvent) {\n        this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {\n            transformPagePoint: this.node.getTransformPagePoint(),\n            contextWindow: getContextWindow(this.node),\n        });\n    }\n    createPanHandlers() {\n        const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();\n        return {\n            onSessionStart: asyncHandler(onPanSessionStart),\n            onStart: asyncHandler(onPanStart),\n            onMove: onPan,\n            onEnd: (event, info) => {\n                delete this.session;\n                if (onPanEnd) {\n                    frame.postRender(() => onPanEnd(event, info));\n                }\n            },\n        };\n    }\n    mount() {\n        this.removePointerDownListener = addPointerEvent(this.node.current, \"pointerdown\", (event) => this.onPointerDown(event));\n    }\n    update() {\n        this.session && this.session.updateHandlers(this.createPanHandlers());\n    }\n    unmount() {\n        this.removePointerDownListener();\n        this.session && this.session.end();\n    }\n}\n\nexport { PanGesture };\n","import { Feature } from '../motion/features/Feature.mjs';\nimport { press } from 'motion-dom';\nimport { extractEventInfo } from '../events/event-info.mjs';\nimport { frame } from '../frameloop/frame.mjs';\n\nfunction handlePressEvent(node, event, lifecycle) {\n    const { props } = node;\n    if (node.animationState && props.whileTap) {\n        node.animationState.setActive(\"whileTap\", lifecycle === \"Start\");\n    }\n    const eventName = (\"onTap\" + (lifecycle === \"End\" ? \"\" : lifecycle));\n    const callback = props[eventName];\n    if (callback) {\n        frame.postRender(() => callback(event, extractEventInfo(event)));\n    }\n}\nclass PressGesture extends Feature {\n    mount() {\n        const { current } = this.node;\n        if (!current)\n            return;\n        this.unmount = press(current, (startEvent) => {\n            handlePressEvent(this.node, startEvent, \"Start\");\n            return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? \"End\" : \"Cancel\");\n        }, { useGlobalTarget: this.node.props.globalTapTarget });\n    }\n    unmount() { }\n}\n\nexport { PressGesture };\n"],"names":["anticipate","p","Math","pow","backOut","backIn","backInOut","circIn","sin","acos","circOut","circInOut","calcBezier","t","a1","a2","subdivisionPrecision","subdivisionMaxIterations","cubicBezier","mX1","mY1","mX2","mY2","getTForX","aX","x","lowerBound","upperBound","currentX","currentT","i","abs","binarySubdivide","easeIn","easeOut","easeInOut","mirrorEasing","easing","reverseEasing","isEasingArray","ease","Array","isArray","easingLookup","linear","easingDefinitionToFunction","definition","length","x1","y1","x2","y2","undefined","addDomEvent","target","eventName","handler","options","passive","addEventListener","removeEventListener","addPointerEvent","extractEventInfo","event","point","pageX","y","pageY","addPointerInfo","stepsOrder","maxElapsed","createRenderBatcher","scheduleNextBatch","allowKeepAlive","runNextFrame","useDefaultElapsed","state","delta","timestamp","isProcessing","flagRunNextFrame","steps","reduce","acc","key","thisFrame","Set","nextFrame","flushNextFrame","toKeepAlive","WeakSet","latestFrameData","triggerCallback","callback","has","step","schedule","keepAlive","immediate","queue","add","cancel","delete","process","frameData","forEach","clear","createRenderStep","read","resolveKeyframes","update","preRender","render","postRender","processBatch","useManualTiming","performance","now","max","min","frame","cancelFrame","frameSteps","requestAnimationFrame","microtask","cancelMicrotask","queueMicrotask","clearTime","time","set","newTime","calcRelativeAxisConstraints","axis","calcViewportAxisConstraints","layoutAxis","constraintsAxis","defaultElastic","resolveAxisElastic","dragElastic","minLabel","maxLabel","resolvePointElastic","label","elementDragControls","WeakMap","VisualElementDragControls","constructor","visualElement","this","openDragLock","isDragging","currentDirection","originPoint","constraints","hasMutatedConstraints","elastic","start","originEvent","snapToCursor","presenceContext","isPresent","dragSnapToOrigin","getProps","panSession","PanSession","onSessionStart","pauseAnimation","stopAnimation","e","onStart","info","drag","dragPropagation","onDragStart","resolveConstraints","projection","isAnimationBlocked","current","getAxisMotionValue","get","test","layout","measuredAxis","layoutBox","parseFloat","animationState","setActive","onMove","dragDirectionLock","onDirectionLock","onDrag","offset","lockThreshold","direction","getCurrentDirection","updateAxis","onSessionEnd","stop","resumeAnimation","_a","getAnimationState","animation","play","transformPagePoint","getTransformPagePoint","contextWindow","velocity","startAnimation","onDragEnd","end","_point","shouldDrag","axisValue","next","applyConstraints","dragConstraints","measure","prevConstraints","resolveRefConstraints","top","left","bottom","right","calcRelativeConstraints","resolveDragElastic","relativeConstraints","rebaseAxisConstraints","onMeasureDragConstraints","constraintsElement","constraintsBox","root","measuredConstraints","calcViewportConstraints","userConstraints","dragMomentum","dragTransition","onDragTransitionEnd","momentumAnimations","transition","bounceStiffness","bounceDamping","inertia","type","timeConstant","restDelta","restSpeed","startAxisValueAnimation","Promise","all","then","pause","dragKey","toUpperCase","props","externalMotionValue","getValue","initial","scalePositionWithinConstraints","boxProgress","latest","source","origin","sourceLength","targetLength","progress","clamp","calcOrigin","transformTemplate","style","transform","updateScroll","updateLayout","addListeners","element","stopPointerListener","dragListener","measureDragConstraints","stopMeasureLayoutListener","stopResizeListener","window","stopLayoutUpdateListener","hasLayoutChanged","motionValue","translate","DragGesture","Feature","node","super","removeGroupControls","noop","removeListeners","controls","mount","dragControls","subscribe","unmount","FocusGesture","arguments","isActive","onFocus","isFocusVisible","matches","onBlur","handleHoverEvent","lifecycle","whileHover","HoverGesture","startEvent","endEvent","handlers","lastMoveEvent","lastMoveEventInfo","updatePoint","getPanInfo","history","isPanStarted","isDistancePastThreshold","push","handlePointerMove","transformPoint","handlePointerUp","onEnd","panInfo","initialInfo","updateHandlers","subtractPoint","a","b","lastDevicePoint","startDevicePoint","getVelocity","timeDelta","timestampedPoint","lastPoint","currentVelocity","Infinity","asyncHandler","PanGesture","removePointerDownListener","onPointerDown","pointerDownEvent","session","createPanHandlers","onPanSessionStart","onPanStart","onPan","onPanEnd","handlePressEvent","whileTap","PressGesture","success","useGlobalTarget","globalTapTarget"],"sourceRoot":""}