{"version":3,"file":"736.ed6e37f04d69cd90b33b.js","mappings":"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","sources":["webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animate/single-value.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/utils/can-animate.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/spring/defaults.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/inertia.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/drivers/driver-frameloop.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/utils/accelerated-values.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/waapi/utils/supports-waapi.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/waapi/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-transition-defined.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-none.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/LazyContext.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/MotionContext/create.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/MotionContext/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/PresenceContext.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs"],"sourcesContent":["import { motionValue } from '../../value/index.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\nimport { animateMotionValue } from '../interfaces/motion-value.mjs';\r\n\r\nfunction animateSingleValue(value, keyframes, options) {\r\n    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\r\n    motionValue$1.start(animateMotionValue(\"\", motionValue$1, keyframes, options));\r\n    return motionValue$1.animation;\r\n}\r\n\r\nexport { animateSingleValue };\r\n","import { complex } from '../../value/types/complex/index.mjs';\r\n\r\n/**\r\n * Check if a value is animatable. Examples:\r\n *\r\n * ✅: 100, \"100px\", \"#fff\"\r\n * ❌: \"block\", \"url(2.jpg)\"\r\n * @param value\r\n *\r\n * @internal\r\n */\r\nconst isAnimatable = (value, name) => {\r\n    // If the list of keys tat might be non-animatable grows, replace with Set\r\n    if (name === \"zIndex\")\r\n        return false;\r\n    // If it's a number or a keyframes array, we can animate it. We might at some point\r\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\r\n    // but for now lets leave it like this for performance reasons\r\n    if (typeof value === \"number\" || Array.isArray(value))\r\n        return true;\r\n    if (typeof value === \"string\" && // It's animatable if we have a string\r\n        (complex.test(value) || value === \"0\") && // And it contains numbers and/or colors\r\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\r\n    ) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\nexport { isAnimatable };\r\n","const isNotNull = (value) => value !== null;\r\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }, finalKeyframe) {\r\n    const resolvedKeyframes = keyframes.filter(isNotNull);\r\n    const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1\r\n        ? 0\r\n        : resolvedKeyframes.length - 1;\r\n    return !index || finalKeyframe === undefined\r\n        ? resolvedKeyframes[index]\r\n        : finalKeyframe;\r\n}\r\n\r\nexport { getFinalKeyframe };\r\n","import { time } from '../../frameloop/sync-time.mjs';\r\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\r\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\r\nimport { canAnimate } from './utils/can-animate.mjs';\r\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\r\n\r\n/**\r\n * Maximum time allowed between an animation being created and it being\r\n * resolved for us to use the latter as the start time.\r\n *\r\n * This is to ensure that while we prefer to \"start\" an animation as soon\r\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\r\n * between these two moments.\r\n */\r\nconst MAX_RESOLVE_DELAY = 40;\r\nclass BaseAnimation {\r\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }) {\r\n        // Track whether the animation has been stopped. Stopped animations won't restart.\r\n        this.isStopped = false;\r\n        this.hasAttemptedResolve = false;\r\n        this.createdAt = time.now();\r\n        this.options = {\r\n            autoplay,\r\n            delay,\r\n            type,\r\n            repeat,\r\n            repeatDelay,\r\n            repeatType,\r\n            ...options,\r\n        };\r\n        this.updateFinishedPromise();\r\n    }\r\n    /**\r\n     * This method uses the createdAt and resolvedAt to calculate the\r\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\r\n     * as the following frame would then be the first frame of the animation in\r\n     * progress, which would feel snappier.\r\n     *\r\n     * However, if there's a delay (main thread work) between the creation of\r\n     * the animation and the first commited frame, we prefer to use resolvedAt\r\n     * to avoid a sudden jump into the animation.\r\n     */\r\n    calcStartTime() {\r\n        if (!this.resolvedAt)\r\n            return this.createdAt;\r\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\r\n            ? this.resolvedAt\r\n            : this.createdAt;\r\n    }\r\n    /**\r\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\r\n     * this.resolved will synchronously flush all pending keyframe resolvers.\r\n     * This is a deoptimisation, but at its worst still batches read/writes.\r\n     */\r\n    get resolved() {\r\n        if (!this._resolved && !this.hasAttemptedResolve) {\r\n            flushKeyframeResolvers();\r\n        }\r\n        return this._resolved;\r\n    }\r\n    /**\r\n     * A method to be called when the keyframes resolver completes. This method\r\n     * will check if its possible to run the animation and, if not, skip it.\r\n     * Otherwise, it will call initPlayback on the implementing class.\r\n     */\r\n    onKeyframesResolved(keyframes, finalKeyframe) {\r\n        this.resolvedAt = time.now();\r\n        this.hasAttemptedResolve = true;\r\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\r\n        /**\r\n         * If we can't animate this value with the resolved keyframes\r\n         * then we should complete it immediately.\r\n         */\r\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\r\n            // Finish immediately\r\n            if (instantAnimationState.current || !delay) {\r\n                onUpdate &&\r\n                    onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\r\n                onComplete && onComplete();\r\n                this.resolveFinishedPromise();\r\n                return;\r\n            }\r\n            // Finish after a delay\r\n            else {\r\n                this.options.duration = 0;\r\n            }\r\n        }\r\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\r\n        if (resolvedAnimation === false)\r\n            return;\r\n        this._resolved = {\r\n            keyframes,\r\n            finalKeyframe,\r\n            ...resolvedAnimation,\r\n        };\r\n        this.onPostResolved();\r\n    }\r\n    onPostResolved() { }\r\n    /**\r\n     * Allows the returned animation to be awaited or promise-chained. Currently\r\n     * resolves when the animation finishes at all but in a future update could/should\r\n     * reject if its cancels.\r\n     */\r\n    then(resolve, reject) {\r\n        return this.currentFinishedPromise.then(resolve, reject);\r\n    }\r\n    flatten() {\r\n        this.options.type = \"keyframes\";\r\n        this.options.ease = \"linear\";\r\n    }\r\n    updateFinishedPromise() {\r\n        this.currentFinishedPromise = new Promise((resolve) => {\r\n            this.resolveFinishedPromise = resolve;\r\n        });\r\n    }\r\n}\r\n\r\nexport { BaseAnimation };\r\n","import { isGenerator } from 'motion-dom';\r\nimport { warning } from 'motion-utils';\r\nimport { isAnimatable } from '../../utils/is-animatable.mjs';\r\n\r\nfunction hasKeyframesChanged(keyframes) {\r\n    const current = keyframes[0];\r\n    if (keyframes.length === 1)\r\n        return true;\r\n    for (let i = 0; i < keyframes.length; i++) {\r\n        if (keyframes[i] !== current)\r\n            return true;\r\n    }\r\n}\r\nfunction canAnimate(keyframes, name, type, velocity) {\r\n    /**\r\n     * Check if we're able to animate between the start and end keyframes,\r\n     * and throw a warning if we're attempting to animate between one that's\r\n     * animatable and another that isn't.\r\n     */\r\n    const originKeyframe = keyframes[0];\r\n    if (originKeyframe === null)\r\n        return false;\r\n    /**\r\n     * These aren't traditionally animatable but we do support them.\r\n     * In future we could look into making this more generic or replacing\r\n     * this function with mix() === mixImmediate\r\n     */\r\n    if (name === \"display\" || name === \"visibility\")\r\n        return true;\r\n    const targetKeyframe = keyframes[keyframes.length - 1];\r\n    const isOriginAnimatable = isAnimatable(originKeyframe, name);\r\n    const isTargetAnimatable = isAnimatable(targetKeyframe, name);\r\n    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\r\n    // Always skip if any of these are true\r\n    if (!isOriginAnimatable || !isTargetAnimatable) {\r\n        return false;\r\n    }\r\n    return (hasKeyframesChanged(keyframes) ||\r\n        ((type === \"spring\" || isGenerator(type)) && velocity));\r\n}\r\n\r\nexport { canAnimate };\r\n","import { velocityPerSecond } from '../../../utils/velocity-per-second.mjs';\r\n\r\nconst velocitySampleDuration = 5; // ms\r\nfunction calcGeneratorVelocity(resolveValue, t, current) {\r\n    const prevT = Math.max(t - velocitySampleDuration, 0);\r\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\r\n}\r\n\r\nexport { calcGeneratorVelocity };\r\n","const springDefaults = {\r\n    // Default spring physics\r\n    stiffness: 100,\r\n    damping: 10,\r\n    mass: 1.0,\r\n    velocity: 0.0,\r\n    // Default duration/bounce-based options\r\n    duration: 800, // in ms\r\n    bounce: 0.3,\r\n    visualDuration: 0.3, // in seconds\r\n    // Rest thresholds\r\n    restSpeed: {\r\n        granular: 0.01,\r\n        default: 2,\r\n    },\r\n    restDelta: {\r\n        granular: 0.005,\r\n        default: 0.5,\r\n    },\r\n    // Limits\r\n    minDuration: 0.01, // in seconds\r\n    maxDuration: 10.0, // in seconds\r\n    minDamping: 0.05,\r\n    maxDamping: 1,\r\n};\r\n\r\nexport { springDefaults };\r\n","import { warning, secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\r\nimport { clamp } from '../../../utils/clamp.mjs';\r\nimport { springDefaults } from './defaults.mjs';\r\n\r\nconst safeMin = 0.001;\r\nfunction findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {\r\n    let envelope;\r\n    let derivative;\r\n    warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), \"Spring duration must be 10 seconds or less\");\r\n    let dampingRatio = 1 - bounce;\r\n    /**\r\n     * Restrict dampingRatio and duration to within acceptable ranges.\r\n     */\r\n    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);\r\n    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));\r\n    if (dampingRatio < 1) {\r\n        /**\r\n         * Underdamped spring\r\n         */\r\n        envelope = (undampedFreq) => {\r\n            const exponentialDecay = undampedFreq * dampingRatio;\r\n            const delta = exponentialDecay * duration;\r\n            const a = exponentialDecay - velocity;\r\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\r\n            const c = Math.exp(-delta);\r\n            return safeMin - (a / b) * c;\r\n        };\r\n        derivative = (undampedFreq) => {\r\n            const exponentialDecay = undampedFreq * dampingRatio;\r\n            const delta = exponentialDecay * duration;\r\n            const d = delta * velocity + velocity;\r\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\r\n            const f = Math.exp(-delta);\r\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\r\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\r\n            return (factor * ((d - e) * f)) / g;\r\n        };\r\n    }\r\n    else {\r\n        /**\r\n         * Critically-damped spring\r\n         */\r\n        envelope = (undampedFreq) => {\r\n            const a = Math.exp(-undampedFreq * duration);\r\n            const b = (undampedFreq - velocity) * duration + 1;\r\n            return -safeMin + a * b;\r\n        };\r\n        derivative = (undampedFreq) => {\r\n            const a = Math.exp(-undampedFreq * duration);\r\n            const b = (velocity - undampedFreq) * (duration * duration);\r\n            return a * b;\r\n        };\r\n    }\r\n    const initialGuess = 5 / duration;\r\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\r\n    duration = secondsToMilliseconds(duration);\r\n    if (isNaN(undampedFreq)) {\r\n        return {\r\n            stiffness: springDefaults.stiffness,\r\n            damping: springDefaults.damping,\r\n            duration,\r\n        };\r\n    }\r\n    else {\r\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\r\n        return {\r\n            stiffness,\r\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\r\n            duration,\r\n        };\r\n    }\r\n}\r\nconst rootIterations = 12;\r\nfunction approximateRoot(envelope, derivative, initialGuess) {\r\n    let result = initialGuess;\r\n    for (let i = 1; i < rootIterations; i++) {\r\n        result = result - envelope(result) / derivative(result);\r\n    }\r\n    return result;\r\n}\r\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\r\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\r\n}\r\n\r\nexport { calcAngularFreq, findSpring };\r\n","import { calcGeneratorDuration, maxGeneratorDuration, generateLinearEasing } from 'motion-dom';\r\nimport { millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\r\nimport { clamp } from '../../../utils/clamp.mjs';\r\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\r\nimport { springDefaults } from './defaults.mjs';\r\nimport { findSpring, calcAngularFreq } from './find.mjs';\r\n\r\nconst durationKeys = [\"duration\", \"bounce\"];\r\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\r\nfunction isSpringType(options, keys) {\r\n    return keys.some((key) => options[key] !== undefined);\r\n}\r\nfunction getSpringOptions(options) {\r\n    let springOptions = {\r\n        velocity: springDefaults.velocity,\r\n        stiffness: springDefaults.stiffness,\r\n        damping: springDefaults.damping,\r\n        mass: springDefaults.mass,\r\n        isResolvedFromDuration: false,\r\n        ...options,\r\n    };\r\n    // stiffness/damping/mass overrides duration/bounce\r\n    if (!isSpringType(options, physicsKeys) &&\r\n        isSpringType(options, durationKeys)) {\r\n        if (options.visualDuration) {\r\n            const visualDuration = options.visualDuration;\r\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\r\n            const stiffness = root * root;\r\n            const damping = 2 *\r\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\r\n                Math.sqrt(stiffness);\r\n            springOptions = {\r\n                ...springOptions,\r\n                mass: springDefaults.mass,\r\n                stiffness,\r\n                damping,\r\n            };\r\n        }\r\n        else {\r\n            const derived = findSpring(options);\r\n            springOptions = {\r\n                ...springOptions,\r\n                ...derived,\r\n                mass: springDefaults.mass,\r\n            };\r\n            springOptions.isResolvedFromDuration = true;\r\n        }\r\n    }\r\n    return springOptions;\r\n}\r\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\r\n    const options = typeof optionsOrVisualDuration !== \"object\"\r\n        ? {\r\n            visualDuration: optionsOrVisualDuration,\r\n            keyframes: [0, 1],\r\n            bounce,\r\n        }\r\n        : optionsOrVisualDuration;\r\n    let { restSpeed, restDelta } = options;\r\n    const origin = options.keyframes[0];\r\n    const target = options.keyframes[options.keyframes.length - 1];\r\n    /**\r\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\r\n     * to reduce GC during animation.\r\n     */\r\n    const state = { done: false, value: origin };\r\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\r\n        ...options,\r\n        velocity: -millisecondsToSeconds(options.velocity || 0),\r\n    });\r\n    const initialVelocity = velocity || 0.0;\r\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\r\n    const initialDelta = target - origin;\r\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\r\n    /**\r\n     * If we're working on a granular scale, use smaller defaults for determining\r\n     * when the spring is finished.\r\n     *\r\n     * These defaults have been selected emprically based on what strikes a good\r\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\r\n     */\r\n    const isGranularScale = Math.abs(initialDelta) < 5;\r\n    restSpeed || (restSpeed = isGranularScale\r\n        ? springDefaults.restSpeed.granular\r\n        : springDefaults.restSpeed.default);\r\n    restDelta || (restDelta = isGranularScale\r\n        ? springDefaults.restDelta.granular\r\n        : springDefaults.restDelta.default);\r\n    let resolveSpring;\r\n    if (dampingRatio < 1) {\r\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\r\n        // Underdamped spring\r\n        resolveSpring = (t) => {\r\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\r\n            return (target -\r\n                envelope *\r\n                    (((initialVelocity +\r\n                        dampingRatio * undampedAngularFreq * initialDelta) /\r\n                        angularFreq) *\r\n                        Math.sin(angularFreq * t) +\r\n                        initialDelta * Math.cos(angularFreq * t)));\r\n        };\r\n    }\r\n    else if (dampingRatio === 1) {\r\n        // Critically damped spring\r\n        resolveSpring = (t) => target -\r\n            Math.exp(-undampedAngularFreq * t) *\r\n                (initialDelta +\r\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\r\n    }\r\n    else {\r\n        // Overdamped spring\r\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\r\n        resolveSpring = (t) => {\r\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\r\n            // When performing sinh or cosh values can hit Infinity so we cap them here\r\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\r\n            return (target -\r\n                (envelope *\r\n                    ((initialVelocity +\r\n                        dampingRatio * undampedAngularFreq * initialDelta) *\r\n                        Math.sinh(freqForT) +\r\n                        dampedAngularFreq *\r\n                            initialDelta *\r\n                            Math.cosh(freqForT))) /\r\n                    dampedAngularFreq);\r\n        };\r\n    }\r\n    const generator = {\r\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\r\n        next: (t) => {\r\n            const current = resolveSpring(t);\r\n            if (!isResolvedFromDuration) {\r\n                let currentVelocity = 0.0;\r\n                /**\r\n                 * We only need to calculate velocity for under-damped springs\r\n                 * as over- and critically-damped springs can't overshoot, so\r\n                 * checking only for displacement is enough.\r\n                 */\r\n                if (dampingRatio < 1) {\r\n                    currentVelocity =\r\n                        t === 0\r\n                            ? secondsToMilliseconds(initialVelocity)\r\n                            : calcGeneratorVelocity(resolveSpring, t, current);\r\n                }\r\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\r\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\r\n                state.done =\r\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\r\n            }\r\n            else {\r\n                state.done = t >= duration;\r\n            }\r\n            state.value = state.done ? target : current;\r\n            return state;\r\n        },\r\n        toString: () => {\r\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\r\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\r\n            return calculatedDuration + \"ms \" + easing;\r\n        },\r\n    };\r\n    return generator;\r\n}\r\n\r\nexport { spring };\r\n","import { spring } from './spring/index.mjs';\r\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\r\n\r\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\r\n    const origin = keyframes[0];\r\n    const state = {\r\n        done: false,\r\n        value: origin,\r\n    };\r\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\r\n    const nearestBoundary = (v) => {\r\n        if (min === undefined)\r\n            return max;\r\n        if (max === undefined)\r\n            return min;\r\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\r\n    };\r\n    let amplitude = power * velocity;\r\n    const ideal = origin + amplitude;\r\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\r\n    /**\r\n     * If the target has changed we need to re-calculate the amplitude, otherwise\r\n     * the animation will start from the wrong position.\r\n     */\r\n    if (target !== ideal)\r\n        amplitude = target - origin;\r\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\r\n    const calcLatest = (t) => target + calcDelta(t);\r\n    const applyFriction = (t) => {\r\n        const delta = calcDelta(t);\r\n        const latest = calcLatest(t);\r\n        state.done = Math.abs(delta) <= restDelta;\r\n        state.value = state.done ? target : latest;\r\n    };\r\n    /**\r\n     * Ideally this would resolve for t in a stateless way, we could\r\n     * do that by always precalculating the animation but as we know\r\n     * this will be done anyway we can assume that spring will\r\n     * be discovered during that.\r\n     */\r\n    let timeReachedBoundary;\r\n    let spring$1;\r\n    const checkCatchBoundary = (t) => {\r\n        if (!isOutOfBounds(state.value))\r\n            return;\r\n        timeReachedBoundary = t;\r\n        spring$1 = spring({\r\n            keyframes: [state.value, nearestBoundary(state.value)],\r\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\r\n            damping: bounceDamping,\r\n            stiffness: bounceStiffness,\r\n            restDelta,\r\n            restSpeed,\r\n        });\r\n    };\r\n    checkCatchBoundary(0);\r\n    return {\r\n        calculatedDuration: null,\r\n        next: (t) => {\r\n            /**\r\n             * We need to resolve the friction to figure out if we need a\r\n             * spring but we don't want to do this twice per frame. So here\r\n             * we flag if we updated for this frame and later if we did\r\n             * we can skip doing it again.\r\n             */\r\n            let hasUpdatedFrame = false;\r\n            if (!spring$1 && timeReachedBoundary === undefined) {\r\n                hasUpdatedFrame = true;\r\n                applyFriction(t);\r\n                checkCatchBoundary(t);\r\n            }\r\n            /**\r\n             * If we have a spring and the provided t is beyond the moment the friction\r\n             * animation crossed the min/max boundary, use the spring.\r\n             */\r\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\r\n                return spring$1.next(t - timeReachedBoundary);\r\n            }\r\n            else {\r\n                !hasUpdatedFrame && applyFriction(t);\r\n                return state;\r\n            }\r\n        },\r\n    };\r\n}\r\n\r\nexport { inertia };\r\n","import { easeInOut } from '../../easing/ease.mjs';\r\nimport { isEasingArray } from '../../easing/utils/is-easing-array.mjs';\r\nimport { easingDefinitionToFunction } from '../../easing/utils/map.mjs';\r\nimport { interpolate } from '../../utils/interpolate.mjs';\r\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\r\nimport { convertOffsetToTimes } from '../../utils/offsets/time.mjs';\r\n\r\nfunction defaultEasing(values, easing) {\r\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\r\n}\r\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = \"easeInOut\", }) {\r\n    /**\r\n     * Easing functions can be externally defined as strings. Here we convert them\r\n     * into actual functions.\r\n     */\r\n    const easingFunctions = isEasingArray(ease)\r\n        ? ease.map(easingDefinitionToFunction)\r\n        : easingDefinitionToFunction(ease);\r\n    /**\r\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\r\n     * to reduce GC during animation.\r\n     */\r\n    const state = {\r\n        done: false,\r\n        value: keyframeValues[0],\r\n    };\r\n    /**\r\n     * Create a times array based on the provided 0-1 offsets\r\n     */\r\n    const absoluteTimes = convertOffsetToTimes(\r\n    // Only use the provided offsets if they're the correct length\r\n    // TODO Maybe we should warn here if there's a length mismatch\r\n    times && times.length === keyframeValues.length\r\n        ? times\r\n        : defaultOffset(keyframeValues), duration);\r\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\r\n        ease: Array.isArray(easingFunctions)\r\n            ? easingFunctions\r\n            : defaultEasing(keyframeValues, easingFunctions),\r\n    });\r\n    return {\r\n        calculatedDuration: duration,\r\n        next: (t) => {\r\n            state.value = mapTimeToKeyframe(t);\r\n            state.done = t >= duration;\r\n            return state;\r\n        },\r\n    };\r\n}\r\n\r\nexport { defaultEasing, keyframes };\r\n","import { time } from '../../../frameloop/sync-time.mjs';\r\nimport { frame, cancelFrame, frameData } from '../../../frameloop/frame.mjs';\r\n\r\nconst frameloopDriver = (update) => {\r\n    const passTimestamp = ({ timestamp }) => update(timestamp);\r\n    return {\r\n        start: () => frame.update(passTimestamp, true),\r\n        stop: () => cancelFrame(passTimestamp),\r\n        /**\r\n         * If we're processing this frame we can use the\r\n         * framelocked timestamp to keep things in sync.\r\n         */\r\n        now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),\r\n    };\r\n};\r\n\r\nexport { frameloopDriver };\r\n","import { isGenerator, calcGeneratorDuration } from 'motion-dom';\r\nimport { invariant, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\r\nimport { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\r\nimport { clamp } from '../../utils/clamp.mjs';\r\nimport { mix } from '../../utils/mix/index.mjs';\r\nimport { pipe } from '../../utils/pipe.mjs';\r\nimport { inertia } from '../generators/inertia.mjs';\r\nimport { keyframes } from '../generators/keyframes.mjs';\r\nimport { spring } from '../generators/spring/index.mjs';\r\nimport { BaseAnimation } from './BaseAnimation.mjs';\r\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\r\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\r\n\r\nconst generators = {\r\n    decay: inertia,\r\n    inertia,\r\n    tween: keyframes,\r\n    keyframes: keyframes,\r\n    spring,\r\n};\r\nconst percentToProgress = (percent) => percent / 100;\r\n/**\r\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\r\n * features we expose publically. Mostly the compatibility is to ensure visual identity\r\n * between both WAAPI and main thread animations.\r\n */\r\nclass MainThreadAnimation extends BaseAnimation {\r\n    constructor(options) {\r\n        super(options);\r\n        /**\r\n         * The time at which the animation was paused.\r\n         */\r\n        this.holdTime = null;\r\n        /**\r\n         * The time at which the animation was cancelled.\r\n         */\r\n        this.cancelTime = null;\r\n        /**\r\n         * The current time of the animation.\r\n         */\r\n        this.currentTime = 0;\r\n        /**\r\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\r\n         */\r\n        this.playbackSpeed = 1;\r\n        /**\r\n         * The state of the animation to apply when the animation is resolved. This\r\n         * allows calls to the public API to control the animation before it is resolved,\r\n         * without us having to resolve it first.\r\n         */\r\n        this.pendingPlayState = \"running\";\r\n        /**\r\n         * The time at which the animation was started.\r\n         */\r\n        this.startTime = null;\r\n        this.state = \"idle\";\r\n        /**\r\n         * This method is bound to the instance to fix a pattern where\r\n         * animation.stop is returned as a reference from a useEffect.\r\n         */\r\n        this.stop = () => {\r\n            this.resolver.cancel();\r\n            this.isStopped = true;\r\n            if (this.state === \"idle\")\r\n                return;\r\n            this.teardown();\r\n            const { onStop } = this.options;\r\n            onStop && onStop();\r\n        };\r\n        const { name, motionValue, element, keyframes } = this.options;\r\n        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\r\n        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\r\n        this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\r\n        this.resolver.scheduleResolve();\r\n    }\r\n    flatten() {\r\n        super.flatten();\r\n        // If we've already resolved the animation, re-initialise it\r\n        if (this._resolved) {\r\n            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));\r\n        }\r\n    }\r\n    initPlayback(keyframes$1) {\r\n        const { type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;\r\n        const generatorFactory = isGenerator(type)\r\n            ? type\r\n            : generators[type] || keyframes;\r\n        /**\r\n         * If our generator doesn't support mixing numbers, we need to replace keyframes with\r\n         * [0, 100] and then make a function that maps that to the actual keyframes.\r\n         *\r\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\r\n         */\r\n        let mapPercentToKeyframes;\r\n        let mirroredGenerator;\r\n        if (generatorFactory !== keyframes &&\r\n            typeof keyframes$1[0] !== \"number\") {\r\n            if (process.env.NODE_ENV !== \"production\") {\r\n                invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\r\n            }\r\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\r\n            keyframes$1 = [0, 100];\r\n        }\r\n        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\r\n        /**\r\n         * If we have a mirror repeat type we need to create a second generator that outputs the\r\n         * mirrored (not reversed) animation and later ping pong between the two generators.\r\n         */\r\n        if (repeatType === \"mirror\") {\r\n            mirroredGenerator = generatorFactory({\r\n                ...this.options,\r\n                keyframes: [...keyframes$1].reverse(),\r\n                velocity: -velocity,\r\n            });\r\n        }\r\n        /**\r\n         * If duration is undefined and we have repeat options,\r\n         * we need to calculate a duration from the generator.\r\n         *\r\n         * We set it to the generator itself to cache the duration.\r\n         * Any timeline resolver will need to have already precalculated\r\n         * the duration by this step.\r\n         */\r\n        if (generator.calculatedDuration === null) {\r\n            generator.calculatedDuration = calcGeneratorDuration(generator);\r\n        }\r\n        const { calculatedDuration } = generator;\r\n        const resolvedDuration = calculatedDuration + repeatDelay;\r\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\r\n        return {\r\n            generator,\r\n            mirroredGenerator,\r\n            mapPercentToKeyframes,\r\n            calculatedDuration,\r\n            resolvedDuration,\r\n            totalDuration,\r\n        };\r\n    }\r\n    onPostResolved() {\r\n        const { autoplay = true } = this.options;\r\n        this.play();\r\n        if (this.pendingPlayState === \"paused\" || !autoplay) {\r\n            this.pause();\r\n        }\r\n        else {\r\n            this.state = this.pendingPlayState;\r\n        }\r\n    }\r\n    tick(timestamp, sample = false) {\r\n        const { resolved } = this;\r\n        // If the animations has failed to resolve, return the final keyframe.\r\n        if (!resolved) {\r\n            const { keyframes } = this.options;\r\n            return { done: true, value: keyframes[keyframes.length - 1] };\r\n        }\r\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;\r\n        if (this.startTime === null)\r\n            return generator.next(0);\r\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\r\n        /**\r\n         * requestAnimationFrame timestamps can come through as lower than\r\n         * the startTime as set by performance.now(). Here we prevent this,\r\n         * though in the future it could be possible to make setting startTime\r\n         * a pending operation that gets resolved here.\r\n         */\r\n        if (this.speed > 0) {\r\n            this.startTime = Math.min(this.startTime, timestamp);\r\n        }\r\n        else if (this.speed < 0) {\r\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\r\n        }\r\n        // Update currentTime\r\n        if (sample) {\r\n            this.currentTime = timestamp;\r\n        }\r\n        else if (this.holdTime !== null) {\r\n            this.currentTime = this.holdTime;\r\n        }\r\n        else {\r\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\r\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\r\n            // example.\r\n            this.currentTime =\r\n                Math.round(timestamp - this.startTime) * this.speed;\r\n        }\r\n        // Rebase on delay\r\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\r\n        const isInDelayPhase = this.speed >= 0\r\n            ? timeWithoutDelay < 0\r\n            : timeWithoutDelay > totalDuration;\r\n        this.currentTime = Math.max(timeWithoutDelay, 0);\r\n        // If this animation has finished, set the current time  to the total duration.\r\n        if (this.state === \"finished\" && this.holdTime === null) {\r\n            this.currentTime = totalDuration;\r\n        }\r\n        let elapsed = this.currentTime;\r\n        let frameGenerator = generator;\r\n        if (repeat) {\r\n            /**\r\n             * Get the current progress (0-1) of the animation. If t is >\r\n             * than duration we'll get values like 2.5 (midway through the\r\n             * third iteration)\r\n             */\r\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\r\n            /**\r\n             * Get the current iteration (0 indexed). For instance the floor of\r\n             * 2.5 is 2.\r\n             */\r\n            let currentIteration = Math.floor(progress);\r\n            /**\r\n             * Get the current progress of the iteration by taking the remainder\r\n             * so 2.5 is 0.5 through iteration 2\r\n             */\r\n            let iterationProgress = progress % 1.0;\r\n            /**\r\n             * If iteration progress is 1 we count that as the end\r\n             * of the previous iteration.\r\n             */\r\n            if (!iterationProgress && progress >= 1) {\r\n                iterationProgress = 1;\r\n            }\r\n            iterationProgress === 1 && currentIteration--;\r\n            currentIteration = Math.min(currentIteration, repeat + 1);\r\n            /**\r\n             * Reverse progress if we're not running in \"normal\" direction\r\n             */\r\n            const isOddIteration = Boolean(currentIteration % 2);\r\n            if (isOddIteration) {\r\n                if (repeatType === \"reverse\") {\r\n                    iterationProgress = 1 - iterationProgress;\r\n                    if (repeatDelay) {\r\n                        iterationProgress -= repeatDelay / resolvedDuration;\r\n                    }\r\n                }\r\n                else if (repeatType === \"mirror\") {\r\n                    frameGenerator = mirroredGenerator;\r\n                }\r\n            }\r\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\r\n        }\r\n        /**\r\n         * If we're in negative time, set state as the initial keyframe.\r\n         * This prevents delay: x, duration: 0 animations from finishing\r\n         * instantly.\r\n         */\r\n        const state = isInDelayPhase\r\n            ? { done: false, value: keyframes[0] }\r\n            : frameGenerator.next(elapsed);\r\n        if (mapPercentToKeyframes) {\r\n            state.value = mapPercentToKeyframes(state.value);\r\n        }\r\n        let { done } = state;\r\n        if (!isInDelayPhase && calculatedDuration !== null) {\r\n            done =\r\n                this.speed >= 0\r\n                    ? this.currentTime >= totalDuration\r\n                    : this.currentTime <= 0;\r\n        }\r\n        const isAnimationFinished = this.holdTime === null &&\r\n            (this.state === \"finished\" || (this.state === \"running\" && done));\r\n        if (isAnimationFinished && finalKeyframe !== undefined) {\r\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\r\n        }\r\n        if (onUpdate) {\r\n            onUpdate(state.value);\r\n        }\r\n        if (isAnimationFinished) {\r\n            this.finish();\r\n        }\r\n        return state;\r\n    }\r\n    get duration() {\r\n        const { resolved } = this;\r\n        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\r\n    }\r\n    get time() {\r\n        return millisecondsToSeconds(this.currentTime);\r\n    }\r\n    set time(newTime) {\r\n        newTime = secondsToMilliseconds(newTime);\r\n        this.currentTime = newTime;\r\n        if (this.holdTime !== null || this.speed === 0) {\r\n            this.holdTime = newTime;\r\n        }\r\n        else if (this.driver) {\r\n            this.startTime = this.driver.now() - newTime / this.speed;\r\n        }\r\n    }\r\n    get speed() {\r\n        return this.playbackSpeed;\r\n    }\r\n    set speed(newSpeed) {\r\n        const hasChanged = this.playbackSpeed !== newSpeed;\r\n        this.playbackSpeed = newSpeed;\r\n        if (hasChanged) {\r\n            this.time = millisecondsToSeconds(this.currentTime);\r\n        }\r\n    }\r\n    play() {\r\n        if (!this.resolver.isScheduled) {\r\n            this.resolver.resume();\r\n        }\r\n        if (!this._resolved) {\r\n            this.pendingPlayState = \"running\";\r\n            return;\r\n        }\r\n        if (this.isStopped)\r\n            return;\r\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\r\n        if (!this.driver) {\r\n            this.driver = driver((timestamp) => this.tick(timestamp));\r\n        }\r\n        onPlay && onPlay();\r\n        const now = this.driver.now();\r\n        if (this.holdTime !== null) {\r\n            this.startTime = now - this.holdTime;\r\n        }\r\n        else if (!this.startTime) {\r\n            this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\r\n        }\r\n        else if (this.state === \"finished\") {\r\n            this.startTime = now;\r\n        }\r\n        if (this.state === \"finished\") {\r\n            this.updateFinishedPromise();\r\n        }\r\n        this.cancelTime = this.startTime;\r\n        this.holdTime = null;\r\n        /**\r\n         * Set playState to running only after we've used it in\r\n         * the previous logic.\r\n         */\r\n        this.state = \"running\";\r\n        this.driver.start();\r\n    }\r\n    pause() {\r\n        var _a;\r\n        if (!this._resolved) {\r\n            this.pendingPlayState = \"paused\";\r\n            return;\r\n        }\r\n        this.state = \"paused\";\r\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    complete() {\r\n        if (this.state !== \"running\") {\r\n            this.play();\r\n        }\r\n        this.pendingPlayState = this.state = \"finished\";\r\n        this.holdTime = null;\r\n    }\r\n    finish() {\r\n        this.teardown();\r\n        this.state = \"finished\";\r\n        const { onComplete } = this.options;\r\n        onComplete && onComplete();\r\n    }\r\n    cancel() {\r\n        if (this.cancelTime !== null) {\r\n            this.tick(this.cancelTime);\r\n        }\r\n        this.teardown();\r\n        this.updateFinishedPromise();\r\n    }\r\n    teardown() {\r\n        this.state = \"idle\";\r\n        this.stopDriver();\r\n        this.resolveFinishedPromise();\r\n        this.updateFinishedPromise();\r\n        this.startTime = this.cancelTime = null;\r\n        this.resolver.cancel();\r\n    }\r\n    stopDriver() {\r\n        if (!this.driver)\r\n            return;\r\n        this.driver.stop();\r\n        this.driver = undefined;\r\n    }\r\n    sample(time) {\r\n        this.startTime = 0;\r\n        return this.tick(time, true);\r\n    }\r\n}\r\n// Legacy interface\r\nfunction animateValue(options) {\r\n    return new MainThreadAnimation(options);\r\n}\r\n\r\nexport { MainThreadAnimation, animateValue };\r\n","/**\r\n * A list of values that can be hardware-accelerated.\r\n */\r\nconst acceleratedValues = new Set([\r\n    \"opacity\",\r\n    \"clipPath\",\r\n    \"filter\",\r\n    \"transform\",\r\n    // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\r\n    // or until we implement support for linear() easing.\r\n    // \"background-color\"\r\n]);\r\n\r\nexport { acceleratedValues };\r\n","import { memo } from 'motion-utils';\r\n\r\nconst supportsWaapi = /*@__PURE__*/ memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\r\n\r\nexport { supportsWaapi };\r\n","import { supportsLinearEasing, attachTimeline, isGenerator, isWaapiSupportedEasing } from 'motion-dom';\r\nimport { millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\r\nimport { anticipate } from '../../easing/anticipate.mjs';\r\nimport { backInOut } from '../../easing/back.mjs';\r\nimport { circInOut } from '../../easing/circ.mjs';\r\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\r\nimport { BaseAnimation } from './BaseAnimation.mjs';\r\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\r\nimport { acceleratedValues } from './utils/accelerated-values.mjs';\r\nimport { startWaapiAnimation } from './waapi/index.mjs';\r\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\r\nimport { supportsWaapi } from './waapi/utils/supports-waapi.mjs';\r\n\r\n/**\r\n * 10ms is chosen here as it strikes a balance between smooth\r\n * results (more than one keyframe per frame at 60fps) and\r\n * keyframe quantity.\r\n */\r\nconst sampleDelta = 10; //ms\r\n/**\r\n * Implement a practical max duration for keyframe generation\r\n * to prevent infinite loops\r\n */\r\nconst maxDuration = 20000;\r\n/**\r\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\r\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\r\n * handing off.\r\n */\r\nfunction requiresPregeneratedKeyframes(options) {\r\n    return (isGenerator(options.type) ||\r\n        options.type === \"spring\" ||\r\n        !isWaapiSupportedEasing(options.ease));\r\n}\r\nfunction pregenerateKeyframes(keyframes, options) {\r\n    /**\r\n     * Create a main-thread animation to pregenerate keyframes.\r\n     * We sample this at regular intervals to generate keyframes that we then\r\n     * linearly interpolate between.\r\n     */\r\n    const sampleAnimation = new MainThreadAnimation({\r\n        ...options,\r\n        keyframes,\r\n        repeat: 0,\r\n        delay: 0,\r\n        isGenerator: true,\r\n    });\r\n    let state = { done: false, value: keyframes[0] };\r\n    const pregeneratedKeyframes = [];\r\n    /**\r\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\r\n     * we're heading for an infinite loop.\r\n     */\r\n    let t = 0;\r\n    while (!state.done && t < maxDuration) {\r\n        state = sampleAnimation.sample(t);\r\n        pregeneratedKeyframes.push(state.value);\r\n        t += sampleDelta;\r\n    }\r\n    return {\r\n        times: undefined,\r\n        keyframes: pregeneratedKeyframes,\r\n        duration: t - sampleDelta,\r\n        ease: \"linear\",\r\n    };\r\n}\r\nconst unsupportedEasingFunctions = {\r\n    anticipate,\r\n    backInOut,\r\n    circInOut,\r\n};\r\nfunction isUnsupportedEase(key) {\r\n    return key in unsupportedEasingFunctions;\r\n}\r\nclass AcceleratedAnimation extends BaseAnimation {\r\n    constructor(options) {\r\n        super(options);\r\n        const { name, motionValue, element, keyframes } = this.options;\r\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\r\n        this.resolver.scheduleResolve();\r\n    }\r\n    initPlayback(keyframes, finalKeyframe) {\r\n        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;\r\n        /**\r\n         * If element has since been unmounted, return false to indicate\r\n         * the animation failed to initialised.\r\n         */\r\n        if (!motionValue.owner || !motionValue.owner.current) {\r\n            return false;\r\n        }\r\n        /**\r\n         * If the user has provided an easing function name that isn't supported\r\n         * by WAAPI (like \"anticipate\"), we need to provide the corressponding\r\n         * function. This will later get converted to a linear() easing function.\r\n         */\r\n        if (typeof ease === \"string\" &&\r\n            supportsLinearEasing() &&\r\n            isUnsupportedEase(ease)) {\r\n            ease = unsupportedEasingFunctions[ease];\r\n        }\r\n        /**\r\n         * If this animation needs pre-generated keyframes then generate.\r\n         */\r\n        if (requiresPregeneratedKeyframes(this.options)) {\r\n            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;\r\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\r\n            keyframes = pregeneratedAnimation.keyframes;\r\n            // If this is a very short animation, ensure we have\r\n            // at least two keyframes to animate between as older browsers\r\n            // can't animate between a single keyframe.\r\n            if (keyframes.length === 1) {\r\n                keyframes[1] = keyframes[0];\r\n            }\r\n            duration = pregeneratedAnimation.duration;\r\n            times = pregeneratedAnimation.times;\r\n            ease = pregeneratedAnimation.ease;\r\n            type = \"keyframes\";\r\n        }\r\n        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\r\n        // Override the browser calculated startTime with one synchronised to other JS\r\n        // and WAAPI animations starting this event loop.\r\n        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\r\n        if (this.pendingTimeline) {\r\n            attachTimeline(animation, this.pendingTimeline);\r\n            this.pendingTimeline = undefined;\r\n        }\r\n        else {\r\n            /**\r\n             * Prefer the `onfinish` prop as it's more widely supported than\r\n             * the `finished` promise.\r\n             *\r\n             * Here, we synchronously set the provided MotionValue to the end\r\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\r\n             * be removed from the element which would then revert to its old styles.\r\n             */\r\n            animation.onfinish = () => {\r\n                const { onComplete } = this.options;\r\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\r\n                onComplete && onComplete();\r\n                this.cancel();\r\n                this.resolveFinishedPromise();\r\n            };\r\n        }\r\n        return {\r\n            animation,\r\n            duration,\r\n            times,\r\n            type,\r\n            ease,\r\n            keyframes: keyframes,\r\n        };\r\n    }\r\n    get duration() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return 0;\r\n        const { duration } = resolved;\r\n        return millisecondsToSeconds(duration);\r\n    }\r\n    get time() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return 0;\r\n        const { animation } = resolved;\r\n        return millisecondsToSeconds(animation.currentTime || 0);\r\n    }\r\n    set time(newTime) {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation } = resolved;\r\n        animation.currentTime = secondsToMilliseconds(newTime);\r\n    }\r\n    get speed() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return 1;\r\n        const { animation } = resolved;\r\n        return animation.playbackRate;\r\n    }\r\n    set speed(newSpeed) {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation } = resolved;\r\n        animation.playbackRate = newSpeed;\r\n    }\r\n    get state() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return \"idle\";\r\n        const { animation } = resolved;\r\n        return animation.playState;\r\n    }\r\n    get startTime() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return null;\r\n        const { animation } = resolved;\r\n        // Coerce to number as TypeScript incorrectly types this\r\n        // as CSSNumberish\r\n        return animation.startTime;\r\n    }\r\n    /**\r\n     * Replace the default DocumentTimeline with another AnimationTimeline.\r\n     * Currently used for scroll animations.\r\n     */\r\n    attachTimeline(timeline) {\r\n        if (!this._resolved) {\r\n            this.pendingTimeline = timeline;\r\n        }\r\n        else {\r\n            const { resolved } = this;\r\n            if (!resolved)\r\n                return noop;\r\n            const { animation } = resolved;\r\n            attachTimeline(animation, timeline);\r\n        }\r\n        return noop;\r\n    }\r\n    play() {\r\n        if (this.isStopped)\r\n            return;\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation } = resolved;\r\n        if (animation.playState === \"finished\") {\r\n            this.updateFinishedPromise();\r\n        }\r\n        animation.play();\r\n    }\r\n    pause() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation } = resolved;\r\n        animation.pause();\r\n    }\r\n    stop() {\r\n        this.resolver.cancel();\r\n        this.isStopped = true;\r\n        if (this.state === \"idle\")\r\n            return;\r\n        this.resolveFinishedPromise();\r\n        this.updateFinishedPromise();\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation, keyframes, duration, type, ease, times } = resolved;\r\n        if (animation.playState === \"idle\" ||\r\n            animation.playState === \"finished\") {\r\n            return;\r\n        }\r\n        /**\r\n         * WAAPI doesn't natively have any interruption capabilities.\r\n         *\r\n         * Rather than read commited styles back out of the DOM, we can\r\n         * create a renderless JS animation and sample it twice to calculate\r\n         * its current value, \"previous\" value, and therefore allow\r\n         * Motion to calculate velocity for any subsequent animation.\r\n         */\r\n        if (this.time) {\r\n            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\r\n            const sampleAnimation = new MainThreadAnimation({\r\n                ...options,\r\n                keyframes,\r\n                duration,\r\n                type,\r\n                ease,\r\n                times,\r\n                isGenerator: true,\r\n            });\r\n            const sampleTime = secondsToMilliseconds(this.time);\r\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\r\n        }\r\n        const { onStop } = this.options;\r\n        onStop && onStop();\r\n        this.cancel();\r\n    }\r\n    complete() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        resolved.animation.finish();\r\n    }\r\n    cancel() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        resolved.animation.cancel();\r\n    }\r\n    static supports(options) {\r\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\r\n        if (!motionValue ||\r\n            !motionValue.owner ||\r\n            !(motionValue.owner.current instanceof HTMLElement)) {\r\n            return false;\r\n        }\r\n        const { onUpdate, transformTemplate } = motionValue.owner.getProps();\r\n        return (supportsWaapi() &&\r\n            name &&\r\n            acceleratedValues.has(name) &&\r\n            /**\r\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\r\n             * no way to read the value from WAAPI every frame.\r\n             */\r\n            !onUpdate &&\r\n            !transformTemplate &&\r\n            !repeatDelay &&\r\n            repeatType !== \"mirror\" &&\r\n            damping !== 0 &&\r\n            type !== \"inertia\");\r\n    }\r\n}\r\n\r\nexport { AcceleratedAnimation };\r\n","import { mapEasingToNativeEasing } from 'motion-dom';\r\n\r\nfunction startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = \"loop\", ease = \"easeInOut\", times, } = {}) {\r\n    const keyframeOptions = { [valueName]: keyframes };\r\n    if (times)\r\n        keyframeOptions.offset = times;\r\n    const easing = mapEasingToNativeEasing(ease, duration);\r\n    /**\r\n     * If this is an easing array, apply to keyframes, not animation as a whole\r\n     */\r\n    if (Array.isArray(easing))\r\n        keyframeOptions.easing = easing;\r\n    return element.animate(keyframeOptions, {\r\n        delay,\r\n        duration,\r\n        easing: !Array.isArray(easing) ? easing : \"linear\",\r\n        fill: \"both\",\r\n        iterations: repeat + 1,\r\n        direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\",\r\n    });\r\n}\r\n\r\nexport { startWaapiAnimation };\r\n","import { transformProps } from '../../render/html/utils/keys-transform.mjs';\r\n\r\nconst underDampedSpring = {\r\n    type: \"spring\",\r\n    stiffness: 500,\r\n    damping: 25,\r\n    restSpeed: 10,\r\n};\r\nconst criticallyDampedSpring = (target) => ({\r\n    type: \"spring\",\r\n    stiffness: 550,\r\n    damping: target === 0 ? 2 * Math.sqrt(550) : 30,\r\n    restSpeed: 10,\r\n});\r\nconst keyframesTransition = {\r\n    type: \"keyframes\",\r\n    duration: 0.8,\r\n};\r\n/**\r\n * Default easing curve is a slightly shallower version of\r\n * the default browser easing curve.\r\n */\r\nconst ease = {\r\n    type: \"keyframes\",\r\n    ease: [0.25, 0.1, 0.35, 1],\r\n    duration: 0.3,\r\n};\r\nconst getDefaultTransition = (valueKey, { keyframes }) => {\r\n    if (keyframes.length > 2) {\r\n        return keyframesTransition;\r\n    }\r\n    else if (transformProps.has(valueKey)) {\r\n        return valueKey.startsWith(\"scale\")\r\n            ? criticallyDampedSpring(keyframes[1])\r\n            : underDampedSpring;\r\n    }\r\n    return ease;\r\n};\r\n\r\nexport { getDefaultTransition };\r\n","import { getValueTransition, GroupPlaybackControls } from 'motion-dom';\r\nimport { secondsToMilliseconds } from 'motion-utils';\r\nimport { frame } from '../../frameloop/frame.mjs';\r\nimport { MotionGlobalConfig } from '../../utils/GlobalConfig.mjs';\r\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\r\nimport { AcceleratedAnimation } from '../animators/AcceleratedAnimation.mjs';\r\nimport { MainThreadAnimation } from '../animators/MainThreadAnimation.mjs';\r\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\r\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\r\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\r\n\r\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\r\n    const valueTransition = getValueTransition(transition, name) || {};\r\n    /**\r\n     * Most transition values are currently completely overwritten by value-specific\r\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\r\n     * delay actually does inherit from the root transition if not value-specific.\r\n     */\r\n    const delay = valueTransition.delay || transition.delay || 0;\r\n    /**\r\n     * Elapsed isn't a public transition option but can be passed through from\r\n     * optimized appear effects in milliseconds.\r\n     */\r\n    let { elapsed = 0 } = transition;\r\n    elapsed = elapsed - secondsToMilliseconds(delay);\r\n    let options = {\r\n        keyframes: Array.isArray(target) ? target : [null, target],\r\n        ease: \"easeOut\",\r\n        velocity: value.getVelocity(),\r\n        ...valueTransition,\r\n        delay: -elapsed,\r\n        onUpdate: (v) => {\r\n            value.set(v);\r\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\r\n        },\r\n        onComplete: () => {\r\n            onComplete();\r\n            valueTransition.onComplete && valueTransition.onComplete();\r\n        },\r\n        name,\r\n        motionValue: value,\r\n        element: isHandoff ? undefined : element,\r\n    };\r\n    /**\r\n     * If there's no transition defined for this value, we can generate\r\n     * unqiue transition settings for this value.\r\n     */\r\n    if (!isTransitionDefined(valueTransition)) {\r\n        options = {\r\n            ...options,\r\n            ...getDefaultTransition(name, options),\r\n        };\r\n    }\r\n    /**\r\n     * Both WAAPI and our internal animation functions use durations\r\n     * as defined by milliseconds, while our external API defines them\r\n     * as seconds.\r\n     */\r\n    if (options.duration) {\r\n        options.duration = secondsToMilliseconds(options.duration);\r\n    }\r\n    if (options.repeatDelay) {\r\n        options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\r\n    }\r\n    if (options.from !== undefined) {\r\n        options.keyframes[0] = options.from;\r\n    }\r\n    let shouldSkip = false;\r\n    if (options.type === false ||\r\n        (options.duration === 0 && !options.repeatDelay)) {\r\n        options.duration = 0;\r\n        if (options.delay === 0) {\r\n            shouldSkip = true;\r\n        }\r\n    }\r\n    if (instantAnimationState.current ||\r\n        MotionGlobalConfig.skipAnimations) {\r\n        shouldSkip = true;\r\n        options.duration = 0;\r\n        options.delay = 0;\r\n    }\r\n    /**\r\n     * If we can or must skip creating the animation, and apply only\r\n     * the final keyframe, do so. We also check once keyframes are resolved but\r\n     * this early check prevents the need to create an animation at all.\r\n     */\r\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\r\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\r\n        if (finalKeyframe !== undefined) {\r\n            frame.update(() => {\r\n                options.onUpdate(finalKeyframe);\r\n                options.onComplete();\r\n            });\r\n            // We still want to return some animation controls here rather\r\n            // than returning undefined\r\n            return new GroupPlaybackControls([]);\r\n        }\r\n    }\r\n    /**\r\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\r\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\r\n     * optimised animation.\r\n     */\r\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\r\n        return new AcceleratedAnimation(options);\r\n    }\r\n    else {\r\n        return new MainThreadAnimation(options);\r\n    }\r\n};\r\n\r\nexport { animateMotionValue };\r\n","/**\r\n * Decide whether a transition is defined on a given Transition.\r\n * This filters out orchestration options and returns true\r\n * if any options are left.\r\n */\r\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\r\n    return !!Object.keys(transition).length;\r\n}\r\n\r\nexport { isTransitionDefined };\r\n","import { getValueTransition } from 'motion-dom';\r\nimport { positionalKeys } from '../../render/html/utils/keys-position.mjs';\r\nimport { setTarget } from '../../render/utils/setters.mjs';\r\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\r\nimport { getOptimisedAppearId } from '../optimized-appear/get-appear-id.mjs';\r\nimport { animateMotionValue } from './motion-value.mjs';\r\nimport { frame } from '../../frameloop/frame.mjs';\r\n\r\n/**\r\n * Decide whether we should block this animation. Previously, we achieved this\r\n * just by checking whether the key was listed in protectedKeys, but this\r\n * posed problems if an animation was triggered by afterChildren and protectedKeys\r\n * had been set to true in the meantime.\r\n */\r\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\r\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\r\n    needsAnimating[key] = false;\r\n    return shouldBlock;\r\n}\r\nfunction animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {\r\n    var _a;\r\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\r\n    if (transitionOverride)\r\n        transition = transitionOverride;\r\n    const animations = [];\r\n    const animationTypeState = type &&\r\n        visualElement.animationState &&\r\n        visualElement.animationState.getState()[type];\r\n    for (const key in target) {\r\n        const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);\r\n        const valueTarget = target[key];\r\n        if (valueTarget === undefined ||\r\n            (animationTypeState &&\r\n                shouldBlockAnimation(animationTypeState, key))) {\r\n            continue;\r\n        }\r\n        const valueTransition = {\r\n            delay,\r\n            ...getValueTransition(transition || {}, key),\r\n        };\r\n        /**\r\n         * If this is the first time a value is being animated, check\r\n         * to see if we're handling off from an existing animation.\r\n         */\r\n        let isHandoff = false;\r\n        if (window.MotionHandoffAnimation) {\r\n            const appearId = getOptimisedAppearId(visualElement);\r\n            if (appearId) {\r\n                const startTime = window.MotionHandoffAnimation(appearId, key, frame);\r\n                if (startTime !== null) {\r\n                    valueTransition.startTime = startTime;\r\n                    isHandoff = true;\r\n                }\r\n            }\r\n        }\r\n        addValueToWillChange(visualElement, key);\r\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key)\r\n            ? { type: false }\r\n            : valueTransition, visualElement, isHandoff));\r\n        const animation = value.animation;\r\n        if (animation) {\r\n            animations.push(animation);\r\n        }\r\n    }\r\n    if (transitionEnd) {\r\n        Promise.all(animations).then(() => {\r\n            frame.update(() => {\r\n                transitionEnd && setTarget(visualElement, transitionEnd);\r\n            });\r\n        });\r\n    }\r\n    return animations;\r\n}\r\n\r\nexport { animateTarget };\r\n","import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\r\nimport { animateTarget } from './visual-element-target.mjs';\r\n\r\nfunction animateVariant(visualElement, variant, options = {}) {\r\n    var _a;\r\n    const resolved = resolveVariant(visualElement, variant, options.type === \"exit\"\r\n        ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\r\n        : undefined);\r\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\r\n    if (options.transitionOverride) {\r\n        transition = options.transitionOverride;\r\n    }\r\n    /**\r\n     * If we have a variant, create a callback that runs it as an animation.\r\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n     */\r\n    const getAnimation = resolved\r\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\r\n        : () => Promise.resolve();\r\n    /**\r\n     * If we have children, create a callback that runs all their animations.\r\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n     */\r\n    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size\r\n        ? (forwardDelay = 0) => {\r\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\r\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\r\n        }\r\n        : () => Promise.resolve();\r\n    /**\r\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\r\n     * this animation or all children animations before playing the other.\r\n     */\r\n    const { when } = transition;\r\n    if (when) {\r\n        const [first, last] = when === \"beforeChildren\"\r\n            ? [getAnimation, getChildAnimations]\r\n            : [getChildAnimations, getAnimation];\r\n        return first().then(() => last());\r\n    }\r\n    else {\r\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\r\n    }\r\n}\r\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\r\n    const animations = [];\r\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\r\n    const generateStaggerDuration = staggerDirection === 1\r\n        ? (i = 0) => i * staggerChildren\r\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\r\n    Array.from(visualElement.variantChildren)\r\n        .sort(sortByTreeOrder)\r\n        .forEach((child, i) => {\r\n        child.notify(\"AnimationStart\", variant);\r\n        animations.push(animateVariant(child, variant, {\r\n            ...options,\r\n            delay: delayChildren + generateStaggerDuration(i),\r\n        }).then(() => child.notify(\"AnimationComplete\", variant)));\r\n    });\r\n    return Promise.all(animations);\r\n}\r\nfunction sortByTreeOrder(a, b) {\r\n    return a.sortNodePosition(b);\r\n}\r\n\r\nexport { animateVariant, sortByTreeOrder };\r\n","import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\r\nimport { animateTarget } from './visual-element-target.mjs';\r\nimport { animateVariant } from './visual-element-variant.mjs';\r\n\r\nfunction animateVisualElement(visualElement, definition, options = {}) {\r\n    visualElement.notify(\"AnimationStart\", definition);\r\n    let animation;\r\n    if (Array.isArray(definition)) {\r\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\r\n        animation = Promise.all(animations);\r\n    }\r\n    else if (typeof definition === \"string\") {\r\n        animation = animateVariant(visualElement, definition, options);\r\n    }\r\n    else {\r\n        const resolvedDefinition = typeof definition === \"function\"\r\n            ? resolveVariant(visualElement, definition, options.custom)\r\n            : definition;\r\n        animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));\r\n    }\r\n    return animation.then(() => {\r\n        visualElement.notify(\"AnimationComplete\", definition);\r\n    });\r\n}\r\n\r\nexport { animateVisualElement };\r\n","import { camelToDash } from '../../render/dom/utils/camel-to-dash.mjs';\r\n\r\nconst optimizedAppearDataId = \"framerAppearId\";\r\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\r\n\r\nexport { optimizedAppearDataAttribute, optimizedAppearDataId };\r\n","import { optimizedAppearDataAttribute } from './data-id.mjs';\r\n\r\nfunction getOptimisedAppearId(visualElement) {\r\n    return visualElement.props[optimizedAppearDataAttribute];\r\n}\r\n\r\nexport { getOptimisedAppearId };\r\n","function isAnimationControls(v) {\r\n    return (v !== null &&\r\n        typeof v === \"object\" &&\r\n        typeof v.start === \"function\");\r\n}\r\n\r\nexport { isAnimationControls };\r\n","const isKeyframesTarget = (v) => {\r\n    return Array.isArray(v);\r\n};\r\n\r\nexport { isKeyframesTarget };\r\n","import { isZeroValueString } from '../../utils/is-zero-value-string.mjs';\r\n\r\nfunction isNone(value) {\r\n    if (typeof value === \"number\") {\r\n        return value === 0;\r\n    }\r\n    else if (value !== null) {\r\n        return value === \"none\" || value === \"0\" || isZeroValueString(value);\r\n    }\r\n    else {\r\n        return true;\r\n    }\r\n}\r\n\r\nexport { isNone };\r\n","import { useContext, useId, useEffect, useCallback } from 'react';\r\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\r\n\r\n/**\r\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\r\n * to access information about whether it's still present in the React tree.\r\n *\r\n * ```jsx\r\n * import { usePresence } from \"framer-motion\"\r\n *\r\n * export const Component = () => {\r\n *   const [isPresent, safeToRemove] = usePresence()\r\n *\r\n *   useEffect(() => {\r\n *     !isPresent && setTimeout(safeToRemove, 1000)\r\n *   }, [isPresent])\r\n *\r\n *   return <div />\r\n * }\r\n * ```\r\n *\r\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\r\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\r\n *\r\n * @public\r\n */\r\nfunction usePresence(subscribe = true) {\r\n    const context = useContext(PresenceContext);\r\n    if (context === null)\r\n        return [true, null];\r\n    const { isPresent, onExitComplete, register } = context;\r\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\r\n    // either be null or non-null for the lifespan of the component.\r\n    const id = useId();\r\n    useEffect(() => {\r\n        if (subscribe)\r\n            register(id);\r\n    }, [subscribe]);\r\n    const safeToRemove = useCallback(() => subscribe && onExitComplete && onExitComplete(id), [id, onExitComplete, subscribe]);\r\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\r\n}\r\n/**\r\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\r\n * There is no `safeToRemove` function.\r\n *\r\n * ```jsx\r\n * import { useIsPresent } from \"framer-motion\"\r\n *\r\n * export const Component = () => {\r\n *   const isPresent = useIsPresent()\r\n *\r\n *   useEffect(() => {\r\n *     !isPresent && console.log(\"I've been removed!\")\r\n *   }, [isPresent])\r\n *\r\n *   return <div />\r\n * }\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction useIsPresent() {\r\n    return isPresent(useContext(PresenceContext));\r\n}\r\nfunction isPresent(context) {\r\n    return context === null ? true : context.isPresent;\r\n}\r\n\r\nexport { isPresent, useIsPresent, usePresence };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\nconst LayoutGroupContext = createContext({});\r\n\r\nexport { LayoutGroupContext };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\nconst LazyContext = createContext({ strict: false });\r\n\r\nexport { LazyContext };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\n/**\r\n * @public\r\n */\r\nconst MotionConfigContext = createContext({\r\n    transformPagePoint: (p) => p,\r\n    isStatic: false,\r\n    reducedMotion: \"never\",\r\n});\r\n\r\nexport { MotionConfigContext };\r\n","import { useContext, useMemo } from 'react';\r\nimport { MotionContext } from './index.mjs';\r\nimport { getCurrentTreeVariants } from './utils.mjs';\r\n\r\nfunction useCreateMotionContext(props) {\r\n    const { initial, animate } = getCurrentTreeVariants(props, useContext(MotionContext));\r\n    return useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);\r\n}\r\nfunction variantLabelsAsDependency(prop) {\r\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\r\n}\r\n\r\nexport { useCreateMotionContext };\r\n","import { isVariantLabel } from '../../render/utils/is-variant-label.mjs';\r\nimport { isControllingVariants } from '../../render/utils/is-controlling-variants.mjs';\r\n\r\nfunction getCurrentTreeVariants(props, context) {\r\n    if (isControllingVariants(props)) {\r\n        const { initial, animate } = props;\r\n        return {\r\n            initial: initial === false || isVariantLabel(initial)\r\n                ? initial\r\n                : undefined,\r\n            animate: isVariantLabel(animate) ? animate : undefined,\r\n        };\r\n    }\r\n    return props.inherit !== false ? context : {};\r\n}\r\n\r\nexport { getCurrentTreeVariants };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\nconst MotionContext = createContext({});\r\n\r\nexport { MotionContext };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\n/**\r\n * @public\r\n */\r\nconst PresenceContext = createContext(null);\r\n\r\nexport { PresenceContext };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\n/**\r\n * Internal, exported only for usage in Framer\r\n */\r\nconst SwitchLayoutGroupContext = createContext({});\r\n\r\nexport { SwitchLayoutGroupContext };\r\n"],"names":["animateSingleValue","value","keyframes","options","motionValue$1","start","animation","isAnimatable","name","Array","isArray","complex","test","startsWith","isNotNull","getFinalKeyframe","repeat","repeatType","finalKeyframe","resolvedKeyframes","filter","index","length","undefined","BaseAnimation","constructor","autoplay","delay","type","repeatDelay","this","isStopped","hasAttemptedResolve","createdAt","now","updateFinishedPromise","calcStartTime","resolvedAt","resolved","_resolved","onKeyframesResolved","velocity","onComplete","onUpdate","isGenerator","originKeyframe","targetKeyframe","isOriginAnimatable","isTargetAnimatable","current","i","hasKeyframesChanged","canAnimate","resolveFinishedPromise","duration","resolvedAnimation","initPlayback","onPostResolved","then","resolve","reject","currentFinishedPromise","flatten","ease","Promise","calcGeneratorVelocity","resolveValue","t","prevT","Math","max","springDefaults","granular","default","safeMin","findSpring","bounce","mass","envelope","derivative","dampingRatio","clamp","undampedFreq","exponentialDecay","delta","a","b","calcAngularFreq","c","exp","d","e","pow","f","g","initialGuess","result","rootIterations","approximateRoot","isNaN","stiffness","damping","sqrt","durationKeys","physicsKeys","isSpringType","keys","some","key","spring","optionsOrVisualDuration","visualDuration","restSpeed","restDelta","origin","target","state","done","isResolvedFromDuration","springOptions","root","PI","derived","getSpringOptions","initialVelocity","initialDelta","undampedAngularFreq","isGranularScale","abs","resolveSpring","angularFreq","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","generator","calculatedDuration","next","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","toString","easing","progress","inertia","power","timeConstant","bounceDamping","bounceStiffness","modifyTarget","nearestBoundary","v","amplitude","ideal","calcDelta","calcLatest","applyFriction","latest","timeReachedBoundary","spring$1","checkCatchBoundary","hasUpdatedFrame","defaultEasing","values","map","splice","keyframeValues","times","easingFunctions","absoluteTimes","mapTimeToKeyframe","interpolate","frameloopDriver","update","passTimestamp","timestamp","stop","isProcessing","generators","decay","tween","percentToProgress","percent","MainThreadAnimation","super","holdTime","cancelTime","currentTime","playbackSpeed","pendingPlayState","startTime","resolver","cancel","teardown","onStop","motionValue","element","KeyframeResolver$1","KeyframeResolver","scheduleResolve","Object","assign","keyframes$1","generatorFactory","mapPercentToKeyframes","mirroredGenerator","pipe","mix","reverse","resolvedDuration","totalDuration","play","pause","tick","sample","speed","round","timeWithoutDelay","isInDelayPhase","elapsed","frameGenerator","currentIteration","floor","iterationProgress","Boolean","isAnimationFinished","finish","time","newTime","driver","newSpeed","hasChanged","isScheduled","resume","onPlay","_a","complete","stopDriver","acceleratedValues","Set","supportsWaapi","hasOwnProperty","call","Element","prototype","unsupportedEasingFunctions","anticipate","backInOut","circInOut","AcceleratedAnimation","DOMKeyframesResolver","owner","pregeneratedAnimation","sampleAnimation","pregeneratedKeyframes","push","pregenerateKeyframes","valueName","keyframeOptions","offset","animate","fill","iterations","direction","startWaapiAnimation","pendingTimeline","onfinish","set","playbackRate","playState","attachTimeline","timeline","noop","sampleTime","setWithVelocity","supports","HTMLElement","transformTemplate","getProps","has","underDampedSpring","keyframesTransition","getDefaultTransition","valueKey","animateMotionValue","transition","isHandoff","valueTransition","getVelocity","when","_delay","delayChildren","staggerChildren","staggerDirection","from","isTransitionDefined","shouldSkip","skipAnimations","get","shouldBlockAnimation","protectedKeys","needsAnimating","shouldBlock","animateTarget","visualElement","targetAndTransition","transitionOverride","transitionEnd","animations","animationTypeState","animationState","getState","getValue","latestValues","valueTarget","window","MotionHandoffAnimation","appearId","shouldReduceMotion","all","animateVariant","variant","presenceContext","custom","getAnimation","getChildAnimations","variantChildren","size","forwardDelay","maxStaggerDuration","generateStaggerDuration","sort","sortByTreeOrder","forEach","child","notify","animateChildren","first","last","sortNodePosition","animateVisualElement","definition","resolvedDefinition","optimizedAppearDataAttribute","getOptimisedAppearId","props","isAnimationControls","isKeyframesTarget","isNone","usePresence","subscribe","context","useContext","isPresent","onExitComplete","register","id","useId","useEffect","safeToRemove","useCallback","LayoutGroupContext","createContext","LazyContext","strict","MotionConfigContext","transformPagePoint","p","isStatic","reducedMotion","useCreateMotionContext","initial","inherit","getCurrentTreeVariants","MotionContext","useMemo","variantLabelsAsDependency","prop","join","PresenceContext","SwitchLayoutGroupContext"],"sourceRoot":""}