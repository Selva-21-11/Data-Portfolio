{"version":3,"file":"402.2f8e72f2a1022db32a62.js","mappings":"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","sources":["webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/Feature.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/animation/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/animations.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/definitions.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/drag.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/gestures.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/layout.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/utils/symbol.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/load-features.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs"],"sourcesContent":["class Feature {\r\n    constructor(node) {\r\n        this.isMounted = false;\r\n        this.node = node;\r\n    }\r\n    update() { }\r\n}\r\n\r\nexport { Feature };\r\n","import { isAnimationControls } from '../../../animation/utils/is-animation-controls.mjs';\r\nimport { createAnimationState } from '../../../render/utils/animation-state.mjs';\r\nimport { Feature } from '../Feature.mjs';\r\n\r\nclass AnimationFeature extends Feature {\r\n    /**\r\n     * We dynamically generate the AnimationState manager as it contains a reference\r\n     * to the underlying animation library. We only want to load that if we load this,\r\n     * so people can optionally code split it out using the `m` component.\r\n     */\r\n    constructor(node) {\r\n        super(node);\r\n        node.animationState || (node.animationState = createAnimationState(node));\r\n    }\r\n    updateAnimationControlsSubscription() {\r\n        const { animate } = this.node.getProps();\r\n        if (isAnimationControls(animate)) {\r\n            this.unmountControls = animate.subscribe(this.node);\r\n        }\r\n    }\r\n    /**\r\n     * Subscribe any provided AnimationControls to the component's VisualElement\r\n     */\r\n    mount() {\r\n        this.updateAnimationControlsSubscription();\r\n    }\r\n    update() {\r\n        const { animate } = this.node.getProps();\r\n        const { animate: prevAnimate } = this.node.prevProps || {};\r\n        if (animate !== prevAnimate) {\r\n            this.updateAnimationControlsSubscription();\r\n        }\r\n    }\r\n    unmount() {\r\n        var _a;\r\n        this.node.animationState.reset();\r\n        (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);\r\n    }\r\n}\r\n\r\nexport { AnimationFeature };\r\n","import { Feature } from '../Feature.mjs';\r\n\r\nlet id = 0;\r\nclass ExitAnimationFeature extends Feature {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.id = id++;\r\n    }\r\n    update() {\r\n        if (!this.node.presenceContext)\r\n            return;\r\n        const { isPresent, onExitComplete } = this.node.presenceContext;\r\n        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};\r\n        if (!this.node.animationState || isPresent === prevIsPresent) {\r\n            return;\r\n        }\r\n        const exitAnimation = this.node.animationState.setActive(\"exit\", !isPresent);\r\n        if (onExitComplete && !isPresent) {\r\n            exitAnimation.then(() => onExitComplete(this.id));\r\n        }\r\n    }\r\n    mount() {\r\n        const { register } = this.node.presenceContext || {};\r\n        if (register) {\r\n            this.unmount = register(this.id);\r\n        }\r\n    }\r\n    unmount() { }\r\n}\r\n\r\nexport { ExitAnimationFeature };\r\n","import { AnimationFeature } from './animation/index.mjs';\r\nimport { ExitAnimationFeature } from './animation/exit.mjs';\r\n\r\nconst animations = {\r\n    animation: {\r\n        Feature: AnimationFeature,\r\n    },\r\n    exit: {\r\n        Feature: ExitAnimationFeature,\r\n    },\r\n};\r\n\r\nexport { animations };\r\n","const featureProps = {\r\n    animation: [\r\n        \"animate\",\r\n        \"variants\",\r\n        \"whileHover\",\r\n        \"whileTap\",\r\n        \"exit\",\r\n        \"whileInView\",\r\n        \"whileFocus\",\r\n        \"whileDrag\",\r\n    ],\r\n    exit: [\"exit\"],\r\n    drag: [\"drag\", \"dragControls\"],\r\n    focus: [\"whileFocus\"],\r\n    hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\r\n    tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\r\n    pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\r\n    inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\r\n    layout: [\"layout\", \"layoutId\"],\r\n};\r\nconst featureDefinitions = {};\r\nfor (const key in featureProps) {\r\n    featureDefinitions[key] = {\r\n        isEnabled: (props) => featureProps[key].some((name) => !!props[name]),\r\n    };\r\n}\r\n\r\nexport { featureDefinitions };\r\n","import { DragGesture } from '../../gestures/drag/index.mjs';\r\nimport { PanGesture } from '../../gestures/pan/index.mjs';\r\nimport { MeasureLayout } from './layout/MeasureLayout.mjs';\r\nimport { HTMLProjectionNode } from '../../projection/node/HTMLProjectionNode.mjs';\r\n\r\nconst drag = {\r\n    pan: {\r\n        Feature: PanGesture,\r\n    },\r\n    drag: {\r\n        Feature: DragGesture,\r\n        ProjectionNode: HTMLProjectionNode,\r\n        MeasureLayout,\r\n    },\r\n};\r\n\r\nexport { drag };\r\n","/**\r\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\r\n * element, so even though these handlers might all be triggered by different\r\n * observers, we can keep them in the same map.\r\n */\r\nconst observerCallbacks = new WeakMap();\r\n/**\r\n * Multiple observers can be created for multiple element/document roots. Each with\r\n * different settings. So here we store dictionaries of observers to each root,\r\n * using serialised settings (threshold/margin) as lookup keys.\r\n */\r\nconst observers = new WeakMap();\r\nconst fireObserverCallback = (entry) => {\r\n    const callback = observerCallbacks.get(entry.target);\r\n    callback && callback(entry);\r\n};\r\nconst fireAllObserverCallbacks = (entries) => {\r\n    entries.forEach(fireObserverCallback);\r\n};\r\nfunction initIntersectionObserver({ root, ...options }) {\r\n    const lookupRoot = root || document;\r\n    /**\r\n     * If we don't have an observer lookup map for this root, create one.\r\n     */\r\n    if (!observers.has(lookupRoot)) {\r\n        observers.set(lookupRoot, {});\r\n    }\r\n    const rootObservers = observers.get(lookupRoot);\r\n    const key = JSON.stringify(options);\r\n    /**\r\n     * If we don't have an observer for this combination of root and settings,\r\n     * create one.\r\n     */\r\n    if (!rootObservers[key]) {\r\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });\r\n    }\r\n    return rootObservers[key];\r\n}\r\nfunction observeIntersection(element, options, callback) {\r\n    const rootInteresectionObserver = initIntersectionObserver(options);\r\n    observerCallbacks.set(element, callback);\r\n    rootInteresectionObserver.observe(element);\r\n    return () => {\r\n        observerCallbacks.delete(element);\r\n        rootInteresectionObserver.unobserve(element);\r\n    };\r\n}\r\n\r\nexport { observeIntersection };\r\n","import { Feature } from '../Feature.mjs';\r\nimport { observeIntersection } from './observers.mjs';\r\n\r\nconst thresholdNames = {\r\n    some: 0,\r\n    all: 1,\r\n};\r\nclass InViewFeature extends Feature {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.hasEnteredView = false;\r\n        this.isInView = false;\r\n    }\r\n    startObserver() {\r\n        this.unmount();\r\n        const { viewport = {} } = this.node.getProps();\r\n        const { root, margin: rootMargin, amount = \"some\", once } = viewport;\r\n        const options = {\r\n            root: root ? root.current : undefined,\r\n            rootMargin,\r\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\r\n        };\r\n        const onIntersectionUpdate = (entry) => {\r\n            const { isIntersecting } = entry;\r\n            /**\r\n             * If there's been no change in the viewport state, early return.\r\n             */\r\n            if (this.isInView === isIntersecting)\r\n                return;\r\n            this.isInView = isIntersecting;\r\n            /**\r\n             * Handle hasEnteredView. If this is only meant to run once, and\r\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\r\n             */\r\n            if (once && !isIntersecting && this.hasEnteredView) {\r\n                return;\r\n            }\r\n            else if (isIntersecting) {\r\n                this.hasEnteredView = true;\r\n            }\r\n            if (this.node.animationState) {\r\n                this.node.animationState.setActive(\"whileInView\", isIntersecting);\r\n            }\r\n            /**\r\n             * Use the latest committed props rather than the ones in scope\r\n             * when this observer is created\r\n             */\r\n            const { onViewportEnter, onViewportLeave } = this.node.getProps();\r\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave;\r\n            callback && callback(entry);\r\n        };\r\n        return observeIntersection(this.node.current, options, onIntersectionUpdate);\r\n    }\r\n    mount() {\r\n        this.startObserver();\r\n    }\r\n    update() {\r\n        if (typeof IntersectionObserver === \"undefined\")\r\n            return;\r\n        const { props, prevProps } = this.node;\r\n        const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\r\n        if (hasOptionsChanged) {\r\n            this.startObserver();\r\n        }\r\n    }\r\n    unmount() { }\r\n}\r\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\r\n    return (name) => viewport[name] !== prevViewport[name];\r\n}\r\n\r\nexport { InViewFeature };\r\n","import { HoverGesture } from '../../gestures/hover.mjs';\r\nimport { FocusGesture } from '../../gestures/focus.mjs';\r\nimport { PressGesture } from '../../gestures/press.mjs';\r\nimport { InViewFeature } from './viewport/index.mjs';\r\n\r\nconst gestureAnimations = {\r\n    inView: {\r\n        Feature: InViewFeature,\r\n    },\r\n    tap: {\r\n        Feature: PressGesture,\r\n    },\r\n    focus: {\r\n        Feature: FocusGesture,\r\n    },\r\n    hover: {\r\n        Feature: HoverGesture,\r\n    },\r\n};\r\n\r\nexport { gestureAnimations };\r\n","import { HTMLProjectionNode } from '../../projection/node/HTMLProjectionNode.mjs';\r\nimport { MeasureLayout } from './layout/MeasureLayout.mjs';\r\n\r\nconst layout = {\r\n    layout: {\r\n        ProjectionNode: HTMLProjectionNode,\r\n        MeasureLayout,\r\n    },\r\n};\r\n\r\nexport { layout };\r\n","\"use client\";\r\nimport { jsx } from 'react/jsx-runtime';\r\nimport { useContext, Component } from 'react';\r\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\r\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\r\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\r\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\r\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\r\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\r\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\r\nimport { microtask } from '../../../frameloop/microtask.mjs';\r\nimport { frame } from '../../../frameloop/frame.mjs';\r\n\r\nclass MeasureLayoutWithContext extends Component {\r\n    /**\r\n     * This only mounts projection nodes for components that\r\n     * need measuring, we might want to do it for all components\r\n     * in order to incorporate transforms\r\n     */\r\n    componentDidMount() {\r\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\r\n        const { projection } = visualElement;\r\n        addScaleCorrector(defaultScaleCorrectors);\r\n        if (projection) {\r\n            if (layoutGroup.group)\r\n                layoutGroup.group.add(projection);\r\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\r\n                switchLayoutGroup.register(projection);\r\n            }\r\n            projection.root.didUpdate();\r\n            projection.addEventListener(\"animationComplete\", () => {\r\n                this.safeToRemove();\r\n            });\r\n            projection.setOptions({\r\n                ...projection.options,\r\n                onExitComplete: () => this.safeToRemove(),\r\n            });\r\n        }\r\n        globalProjectionState.hasEverUpdated = true;\r\n    }\r\n    getSnapshotBeforeUpdate(prevProps) {\r\n        const { layoutDependency, visualElement, drag, isPresent } = this.props;\r\n        const projection = visualElement.projection;\r\n        if (!projection)\r\n            return null;\r\n        /**\r\n         * TODO: We use this data in relegate to determine whether to\r\n         * promote a previous element. There's no guarantee its presence data\r\n         * will have updated by this point - if a bug like this arises it will\r\n         * have to be that we markForRelegation and then find a new lead some other way,\r\n         * perhaps in didUpdate\r\n         */\r\n        projection.isPresent = isPresent;\r\n        if (drag ||\r\n            prevProps.layoutDependency !== layoutDependency ||\r\n            layoutDependency === undefined) {\r\n            projection.willUpdate();\r\n        }\r\n        else {\r\n            this.safeToRemove();\r\n        }\r\n        if (prevProps.isPresent !== isPresent) {\r\n            if (isPresent) {\r\n                projection.promote();\r\n            }\r\n            else if (!projection.relegate()) {\r\n                /**\r\n                 * If there's another stack member taking over from this one,\r\n                 * it's in charge of the exit animation and therefore should\r\n                 * be in charge of the safe to remove. Otherwise we call it here.\r\n                 */\r\n                frame.postRender(() => {\r\n                    const stack = projection.getStack();\r\n                    if (!stack || !stack.members.length) {\r\n                        this.safeToRemove();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    componentDidUpdate() {\r\n        const { projection } = this.props.visualElement;\r\n        if (projection) {\r\n            projection.root.didUpdate();\r\n            microtask.postRender(() => {\r\n                if (!projection.currentAnimation && projection.isLead()) {\r\n                    this.safeToRemove();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    componentWillUnmount() {\r\n        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;\r\n        const { projection } = visualElement;\r\n        if (projection) {\r\n            projection.scheduleCheckAfterUnmount();\r\n            if (layoutGroup && layoutGroup.group)\r\n                layoutGroup.group.remove(projection);\r\n            if (promoteContext && promoteContext.deregister)\r\n                promoteContext.deregister(projection);\r\n        }\r\n    }\r\n    safeToRemove() {\r\n        const { safeToRemove } = this.props;\r\n        safeToRemove && safeToRemove();\r\n    }\r\n    render() {\r\n        return null;\r\n    }\r\n}\r\nfunction MeasureLayout(props) {\r\n    const [isPresent, safeToRemove] = usePresence();\r\n    const layoutGroup = useContext(LayoutGroupContext);\r\n    return (jsx(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));\r\n}\r\nconst defaultScaleCorrectors = {\r\n    borderRadius: {\r\n        ...correctBorderRadius,\r\n        applyTo: [\r\n            \"borderTopLeftRadius\",\r\n            \"borderTopRightRadius\",\r\n            \"borderBottomLeftRadius\",\r\n            \"borderBottomRightRadius\",\r\n        ],\r\n    },\r\n    borderTopLeftRadius: correctBorderRadius,\r\n    borderTopRightRadius: correctBorderRadius,\r\n    borderBottomLeftRadius: correctBorderRadius,\r\n    borderBottomRightRadius: correctBorderRadius,\r\n    boxShadow: correctBoxShadow,\r\n};\r\n\r\nexport { MeasureLayout };\r\n","const motionComponentSymbol = Symbol.for(\"motionComponentSymbol\");\r\n\r\nexport { motionComponentSymbol };\r\n","import { useCallback } from 'react';\r\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\r\n\r\n/**\r\n * Creates a ref function that, when called, hydrates the provided\r\n * external ref and VisualElement.\r\n */\r\nfunction useMotionRef(visualState, visualElement, externalRef) {\r\n    return useCallback((instance) => {\r\n        if (instance) {\r\n            visualState.onMount && visualState.onMount(instance);\r\n        }\r\n        if (visualElement) {\r\n            if (instance) {\r\n                visualElement.mount(instance);\r\n            }\r\n            else {\r\n                visualElement.unmount();\r\n            }\r\n        }\r\n        if (externalRef) {\r\n            if (typeof externalRef === \"function\") {\r\n                externalRef(instance);\r\n            }\r\n            else if (isRefObject(externalRef)) {\r\n                externalRef.current = instance;\r\n            }\r\n        }\r\n    }, \r\n    /**\r\n     * Only pass a new ref callback to React if we've received a visual element\r\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\r\n     * or other dependencies change.\r\n     */\r\n    [visualElement]);\r\n}\r\n\r\nexport { useMotionRef };\r\n","import { useContext, useRef, useInsertionEffect, useEffect } from 'react';\r\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\r\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\r\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\r\nimport { LazyContext } from '../../context/LazyContext.mjs';\r\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\r\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\r\nimport { microtask } from '../../frameloop/microtask.mjs';\r\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\r\nimport { SwitchLayoutGroupContext } from '../../context/SwitchLayoutGroupContext.mjs';\r\n\r\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\r\n    var _a, _b;\r\n    const { visualElement: parent } = useContext(MotionContext);\r\n    const lazyContext = useContext(LazyContext);\r\n    const presenceContext = useContext(PresenceContext);\r\n    const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;\r\n    const visualElementRef = useRef(null);\r\n    /**\r\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\r\n     */\r\n    createVisualElement = createVisualElement || lazyContext.renderer;\r\n    if (!visualElementRef.current && createVisualElement) {\r\n        visualElementRef.current = createVisualElement(Component, {\r\n            visualState,\r\n            parent,\r\n            props,\r\n            presenceContext,\r\n            blockInitialAnimation: presenceContext\r\n                ? presenceContext.initial === false\r\n                : false,\r\n            reducedMotionConfig,\r\n        });\r\n    }\r\n    const visualElement = visualElementRef.current;\r\n    /**\r\n     * Load Motion gesture and animation features. These are rendered as renderless\r\n     * components so each feature can optionally make use of React lifecycle methods.\r\n     */\r\n    const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\r\n    if (visualElement &&\r\n        !visualElement.projection &&\r\n        ProjectionNodeConstructor &&\r\n        (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\r\n        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\r\n    }\r\n    const isMounted = useRef(false);\r\n    useInsertionEffect(() => {\r\n        /**\r\n         * Check the component has already mounted before calling\r\n         * `update` unnecessarily. This ensures we skip the initial update.\r\n         */\r\n        if (visualElement && isMounted.current) {\r\n            visualElement.update(props, presenceContext);\r\n        }\r\n    });\r\n    /**\r\n     * Cache this value as we want to know whether HandoffAppearAnimations\r\n     * was present on initial render - it will be deleted after this.\r\n     */\r\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\r\n    const wantsHandoff = useRef(Boolean(optimisedAppearId) &&\r\n        !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) &&\r\n        ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));\r\n    useIsomorphicLayoutEffect(() => {\r\n        if (!visualElement)\r\n            return;\r\n        isMounted.current = true;\r\n        window.MotionIsMounted = true;\r\n        visualElement.updateFeatures();\r\n        microtask.render(visualElement.render);\r\n        /**\r\n         * Ideally this function would always run in a useEffect.\r\n         *\r\n         * However, if we have optimised appear animations to handoff from,\r\n         * it needs to happen synchronously to ensure there's no flash of\r\n         * incorrect styles in the event of a hydration error.\r\n         *\r\n         * So if we detect a situtation where optimised appear animations\r\n         * are running, we use useLayoutEffect to trigger animations.\r\n         */\r\n        if (wantsHandoff.current && visualElement.animationState) {\r\n            visualElement.animationState.animateChanges();\r\n        }\r\n    });\r\n    useEffect(() => {\r\n        if (!visualElement)\r\n            return;\r\n        if (!wantsHandoff.current && visualElement.animationState) {\r\n            visualElement.animationState.animateChanges();\r\n        }\r\n        if (wantsHandoff.current) {\r\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\r\n            queueMicrotask(() => {\r\n                var _a;\r\n                (_a = window.MotionHandoffMarkAsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId);\r\n            });\r\n            wantsHandoff.current = false;\r\n        }\r\n    });\r\n    return visualElement;\r\n}\r\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\r\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, } = props;\r\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"]\r\n        ? undefined\r\n        : getClosestProjectingNode(visualElement.parent));\r\n    visualElement.projection.setOptions({\r\n        layoutId,\r\n        layout,\r\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\r\n        visualElement,\r\n        /**\r\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\r\n         * to update by the time layout animations run.\r\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\r\n         * ensuring it gets called if there's no potential layout animations.\r\n         *\r\n         */\r\n        animationType: typeof layout === \"string\" ? layout : \"both\",\r\n        initialPromotionConfig,\r\n        layoutScroll,\r\n        layoutRoot,\r\n    });\r\n}\r\nfunction getClosestProjectingNode(visualElement) {\r\n    if (!visualElement)\r\n        return undefined;\r\n    return visualElement.options.allowProjection !== false\r\n        ? visualElement.projection\r\n        : getClosestProjectingNode(visualElement.parent);\r\n}\r\n\r\nexport { useVisualElement };\r\n","\"use client\";\r\nimport { jsxs, jsx } from 'react/jsx-runtime';\r\nimport { warning, invariant } from 'motion-utils';\r\nimport { forwardRef, useContext } from 'react';\r\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\r\nimport { LazyContext } from '../context/LazyContext.mjs';\r\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\r\nimport { MotionContext } from '../context/MotionContext/index.mjs';\r\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\r\nimport { isBrowser } from '../utils/is-browser.mjs';\r\nimport { featureDefinitions } from './features/definitions.mjs';\r\nimport { loadFeatures } from './features/load-features.mjs';\r\nimport { motionComponentSymbol } from './utils/symbol.mjs';\r\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\r\nimport { useVisualElement } from './utils/use-visual-element.mjs';\r\n\r\n/**\r\n * Create a `motion` component.\r\n *\r\n * This function accepts a Component argument, which can be either a string (ie \"div\"\r\n * for `motion.div`), or an actual React component.\r\n *\r\n * Alongside this is a config option which provides a way of rendering the provided\r\n * component \"offline\", or outside the React render cycle.\r\n */\r\nfunction createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component, }) {\r\n    var _a, _b;\r\n    preloadedFeatures && loadFeatures(preloadedFeatures);\r\n    function MotionComponent(props, externalRef) {\r\n        /**\r\n         * If we need to measure the element we load this functionality in a\r\n         * separate class component in order to gain access to getSnapshotBeforeUpdate.\r\n         */\r\n        let MeasureLayout;\r\n        const configAndProps = {\r\n            ...useContext(MotionConfigContext),\r\n            ...props,\r\n            layoutId: useLayoutId(props),\r\n        };\r\n        const { isStatic } = configAndProps;\r\n        const context = useCreateMotionContext(props);\r\n        const visualState = useVisualState(props, isStatic);\r\n        if (!isStatic && isBrowser) {\r\n            useStrictMode(configAndProps, preloadedFeatures);\r\n            const layoutProjection = getProjectionFunctionality(configAndProps);\r\n            MeasureLayout = layoutProjection.MeasureLayout;\r\n            /**\r\n             * Create a VisualElement for this component. A VisualElement provides a common\r\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\r\n             * providing a way of rendering to these APIs outside of the React render loop\r\n             * for more performant animations and interactions\r\n             */\r\n            context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);\r\n        }\r\n        /**\r\n         * The mount order and hierarchy is specific to ensure our element ref\r\n         * is hydrated by the time features fire their effects.\r\n         */\r\n        return (jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? (jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] }));\r\n    }\r\n    MotionComponent.displayName = `motion.${typeof Component === \"string\"\r\n        ? Component\r\n        : `create(${(_b = (_a = Component.displayName) !== null && _a !== void 0 ? _a : Component.name) !== null && _b !== void 0 ? _b : \"\"})`}`;\r\n    const ForwardRefMotionComponent = forwardRef(MotionComponent);\r\n    ForwardRefMotionComponent[motionComponentSymbol] = Component;\r\n    return ForwardRefMotionComponent;\r\n}\r\nfunction useLayoutId({ layoutId }) {\r\n    const layoutGroupId = useContext(LayoutGroupContext).id;\r\n    return layoutGroupId && layoutId !== undefined\r\n        ? layoutGroupId + \"-\" + layoutId\r\n        : layoutId;\r\n}\r\nfunction useStrictMode(configAndProps, preloadedFeatures) {\r\n    const isStrict = useContext(LazyContext).strict;\r\n    /**\r\n     * If we're in development mode, check to make sure we're not rendering a motion component\r\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\r\n     */\r\n    if (process.env.NODE_ENV !== \"production\" &&\r\n        preloadedFeatures &&\r\n        isStrict) {\r\n        const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\r\n        configAndProps.ignoreStrict\r\n            ? warning(false, strictMessage)\r\n            : invariant(false, strictMessage);\r\n    }\r\n}\r\nfunction getProjectionFunctionality(props) {\r\n    const { drag, layout } = featureDefinitions;\r\n    if (!drag && !layout)\r\n        return {};\r\n    const combined = { ...drag, ...layout };\r\n    return {\r\n        MeasureLayout: (drag === null || drag === void 0 ? void 0 : drag.isEnabled(props)) || (layout === null || layout === void 0 ? void 0 : layout.isEnabled(props))\r\n            ? combined.MeasureLayout\r\n            : undefined,\r\n        ProjectionNode: combined.ProjectionNode,\r\n    };\r\n}\r\n\r\nexport { createRendererMotionComponent };\r\n","import { featureDefinitions } from './definitions.mjs';\r\n\r\nfunction loadFeatures(features) {\r\n    for (const key in features) {\r\n        featureDefinitions[key] = {\r\n            ...featureDefinitions[key],\r\n            ...features[key],\r\n        };\r\n    }\r\n}\r\n\r\nexport { loadFeatures };\r\n","import { scaleCorrectors } from '../../projection/styles/scale-correction.mjs';\r\nimport { transformProps } from '../../render/html/utils/keys-transform.mjs';\r\n\r\nfunction isForcedMotionValue(key, { layout, layoutId }) {\r\n    return (transformProps.has(key) ||\r\n        key.startsWith(\"origin\") ||\r\n        ((layout || layoutId !== undefined) &&\r\n            (!!scaleCorrectors[key] || key === \"opacity\")));\r\n}\r\n\r\nexport { isForcedMotionValue };\r\n","import { useContext } from 'react';\r\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\r\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\r\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\r\nimport { isControllingVariants, isVariantNode } from '../../render/utils/is-controlling-variants.mjs';\r\nimport { resolveVariantFromProps } from '../../render/utils/resolve-variants.mjs';\r\nimport { useConstant } from '../../utils/use-constant.mjs';\r\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\r\n\r\nfunction makeState({ scrapeMotionValuesFromProps, createRenderState, onUpdate, }, props, context, presenceContext) {\r\n    const state = {\r\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\r\n        renderState: createRenderState(),\r\n    };\r\n    if (onUpdate) {\r\n        /**\r\n         * onMount works without the VisualElement because it could be\r\n         * called before the VisualElement payload has been hydrated.\r\n         * (e.g. if someone is using m components <m.circle />)\r\n         */\r\n        state.onMount = (instance) => onUpdate({ props, current: instance, ...state });\r\n        state.onUpdate = (visualElement) => onUpdate(visualElement);\r\n    }\r\n    return state;\r\n}\r\nconst makeUseVisualState = (config) => (props, isStatic) => {\r\n    const context = useContext(MotionContext);\r\n    const presenceContext = useContext(PresenceContext);\r\n    const make = () => makeState(config, props, context, presenceContext);\r\n    return isStatic ? make() : useConstant(make);\r\n};\r\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\r\n    const values = {};\r\n    const motionValues = scrapeMotionValues(props, {});\r\n    for (const key in motionValues) {\r\n        values[key] = resolveMotionValue(motionValues[key]);\r\n    }\r\n    let { initial, animate } = props;\r\n    const isControllingVariants$1 = isControllingVariants(props);\r\n    const isVariantNode$1 = isVariantNode(props);\r\n    if (context &&\r\n        isVariantNode$1 &&\r\n        !isControllingVariants$1 &&\r\n        props.inherit !== false) {\r\n        if (initial === undefined)\r\n            initial = context.initial;\r\n        if (animate === undefined)\r\n            animate = context.animate;\r\n    }\r\n    let isInitialAnimationBlocked = presenceContext\r\n        ? presenceContext.initial === false\r\n        : false;\r\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\r\n    const variantToSet = isInitialAnimationBlocked ? animate : initial;\r\n    if (variantToSet &&\r\n        typeof variantToSet !== \"boolean\" &&\r\n        !isAnimationControls(variantToSet)) {\r\n        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\r\n        for (let i = 0; i < list.length; i++) {\r\n            const resolved = resolveVariantFromProps(props, list[i]);\r\n            if (resolved) {\r\n                const { transitionEnd, transition, ...target } = resolved;\r\n                for (const key in target) {\r\n                    let valueTarget = target[key];\r\n                    if (Array.isArray(valueTarget)) {\r\n                        /**\r\n                         * Take final keyframe if the initial animation is blocked because\r\n                         * we want to initialise at the end of that blocked animation.\r\n                         */\r\n                        const index = isInitialAnimationBlocked\r\n                            ? valueTarget.length - 1\r\n                            : 0;\r\n                        valueTarget = valueTarget[index];\r\n                    }\r\n                    if (valueTarget !== null) {\r\n                        values[key] = valueTarget;\r\n                    }\r\n                }\r\n                for (const key in transitionEnd) {\r\n                    values[key] = transitionEnd[key];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return values;\r\n}\r\n\r\nexport { makeUseVisualState };\r\n","/**\r\n * A list of all valid MotionProps.\r\n *\r\n * @privateRemarks\r\n * This doesn't throw if a `MotionProp` name is missing - it should.\r\n */\r\nconst validMotionProps = new Set([\r\n    \"animate\",\r\n    \"exit\",\r\n    \"variants\",\r\n    \"initial\",\r\n    \"style\",\r\n    \"values\",\r\n    \"variants\",\r\n    \"transition\",\r\n    \"transformTemplate\",\r\n    \"custom\",\r\n    \"inherit\",\r\n    \"onBeforeLayoutMeasure\",\r\n    \"onAnimationStart\",\r\n    \"onAnimationComplete\",\r\n    \"onUpdate\",\r\n    \"onDragStart\",\r\n    \"onDrag\",\r\n    \"onDragEnd\",\r\n    \"onMeasureDragConstraints\",\r\n    \"onDirectionLock\",\r\n    \"onDragTransitionEnd\",\r\n    \"_dragX\",\r\n    \"_dragY\",\r\n    \"onHoverStart\",\r\n    \"onHoverEnd\",\r\n    \"onViewportEnter\",\r\n    \"onViewportLeave\",\r\n    \"globalTapTarget\",\r\n    \"ignoreStrict\",\r\n    \"viewport\",\r\n]);\r\n/**\r\n * Check whether a prop name is a valid `MotionProp` key.\r\n *\r\n * @param key - Name of the property to check\r\n * @returns `true` is key is a valid `MotionProp`.\r\n *\r\n * @public\r\n */\r\nfunction isValidMotionProp(key) {\r\n    return (key.startsWith(\"while\") ||\r\n        (key.startsWith(\"drag\") && key !== \"draggable\") ||\r\n        key.startsWith(\"layout\") ||\r\n        key.startsWith(\"onTap\") ||\r\n        key.startsWith(\"onPan\") ||\r\n        key.startsWith(\"onLayout\") ||\r\n        validMotionProps.has(key));\r\n}\r\n\r\nexport { isValidMotionProp };\r\n"],"names":["Feature","constructor","node","this","isMounted","update","AnimationFeature","super","animationState","updateAnimationControlsSubscription","animate","getProps","unmountControls","subscribe","mount","prevAnimate","prevProps","unmount","_a","reset","call","id","ExitAnimationFeature","arguments","presenceContext","isPresent","onExitComplete","prevIsPresent","prevPresenceContext","exitAnimation","setActive","then","register","animations","animation","exit","featureProps","drag","focus","hover","tap","pan","inView","layout","featureDefinitions","key","isEnabled","props","some","name","ProjectionNode","MeasureLayout","observerCallbacks","WeakMap","observers","fireObserverCallback","entry","callback","get","target","fireAllObserverCallbacks","entries","forEach","observeIntersection","element","options","rootInteresectionObserver","root","lookupRoot","document","has","set","rootObservers","JSON","stringify","IntersectionObserver","initIntersectionObserver","observe","delete","unobserve","thresholdNames","all","InViewFeature","hasEnteredView","isInView","startObserver","viewport","margin","rootMargin","amount","once","current","undefined","threshold","isIntersecting","onViewportEnter","onViewportLeave","prevViewport","hasViewportOptionChanged","gestureAnimations","MeasureLayoutWithContext","Component","componentDidMount","visualElement","layoutGroup","switchLayoutGroup","layoutId","projection","defaultScaleCorrectors","group","add","didUpdate","addEventListener","safeToRemove","setOptions","hasEverUpdated","getSnapshotBeforeUpdate","layoutDependency","willUpdate","promote","relegate","postRender","stack","getStack","members","length","componentDidUpdate","currentAnimation","isLead","componentWillUnmount","promoteContext","scheduleCheckAfterUnmount","remove","deregister","render","useContext","L","jsx","borderRadius","applyTo","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","boxShadow","motionComponentSymbol","Symbol","for","useMotionRef","visualState","externalRef","useCallback","instance","onMount","useVisualElement","createVisualElement","ProjectionNodeConstructor","_b","parent","MotionContext","lazyContext","LazyContext","PresenceContext","reducedMotionConfig","MotionConfigContext","reducedMotion","visualElementRef","useRef","renderer","blockInitialAnimation","initial","initialLayoutGroupConfig","SwitchLayoutGroupContext","type","initialPromotionConfig","dragConstraints","layoutScroll","layoutRoot","latestValues","getClosestProjectingNode","alwaysMeasureLayout","Boolean","animationType","createProjectionNode","useInsertionEffect","optimisedAppearId","wantsHandoff","window","MotionHandoffIsComplete","MotionHasOptimisedAnimation","MotionIsMounted","updateFeatures","microtask","animateChanges","useEffect","queueMicrotask","MotionHandoffMarkAsComplete","allowProjection","createRendererMotionComponent","preloadedFeatures","useRender","useVisualState","MotionComponent","configAndProps","useLayoutId","isStatic","context","strict","useStrictMode","layoutProjection","combined","getProjectionFunctionality","jsxs","Provider","value","children","features","loadFeatures","displayName","ForwardRefMotionComponent","forwardRef","layoutGroupId","LayoutGroupContext","isForcedMotionValue","startsWith","makeUseVisualState","config","make","scrapeMotionValuesFromProps","createRenderState","onUpdate","state","makeLatestValues","renderState","makeState","scrapeMotionValues","values","motionValues","isControllingVariants$1","isVariantNode$1","inherit","isInitialAnimationBlocked","variantToSet","list","Array","isArray","i","resolved","transitionEnd","transition","valueTarget","validMotionProps","Set","isValidMotionProp"],"sourceRoot":""}