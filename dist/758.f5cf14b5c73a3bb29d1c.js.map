{"version":3,"file":"758.f5cf14b5c73a3bb29d1c.js","mappings":"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","sources":["webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/anticipate.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/back.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/circ.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/ease.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/modifiers/mirror.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/modifiers/reverse.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/utils/is-easing-array.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/easing/utils/map.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/events/add-dom-event.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/events/add-pointer-event.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/events/event-info.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/frameloop/batcher.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/frameloop/render-step.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/frameloop/frame.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/frameloop/microtask.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/frameloop/sync-time.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/gestures/drag/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/gestures/focus.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/gestures/hover.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/gestures/pan/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/gestures/press.mjs"],"sourcesContent":["import { backIn } from './back.mjs';\r\n\r\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\r\n\r\nexport { anticipate };\r\n","import { cubicBezier } from './cubic-bezier.mjs';\r\nimport { mirrorEasing } from './modifiers/mirror.mjs';\r\nimport { reverseEasing } from './modifiers/reverse.mjs';\r\n\r\nconst backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);\r\nconst backIn = /*@__PURE__*/ reverseEasing(backOut);\r\nconst backInOut = /*@__PURE__*/ mirrorEasing(backIn);\r\n\r\nexport { backIn, backInOut, backOut };\r\n","import { mirrorEasing } from './modifiers/mirror.mjs';\r\nimport { reverseEasing } from './modifiers/reverse.mjs';\r\n\r\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\r\nconst circOut = reverseEasing(circIn);\r\nconst circInOut = mirrorEasing(circIn);\r\n\r\nexport { circIn, circInOut, circOut };\r\n","import { noop } from 'motion-utils';\r\n\r\n/*\r\n  Bezier function generator\r\n  This has been modified from Gaëtan Renaudeau's BezierEasing\r\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\r\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\r\n  \r\n  I've removed the newtonRaphsonIterate algo because in benchmarking it\r\n  wasn't noticiably faster than binarySubdivision, indeed removing it\r\n  usually improved times, depending on the curve.\r\n  I also removed the lookup table, as for the added bundle size and loop we're\r\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\r\n  to 12 to compensate and this still tended to be faster for no perceivable\r\n  loss in accuracy.\r\n  Usage\r\n    const easeOut = cubicBezier(.17,.67,.83,.67);\r\n    const x = easeOut(0.5); // returns 0.627...\r\n*/\r\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\r\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\r\n    t;\r\nconst subdivisionPrecision = 0.0000001;\r\nconst subdivisionMaxIterations = 12;\r\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\r\n    let currentX;\r\n    let currentT;\r\n    let i = 0;\r\n    do {\r\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\r\n        currentX = calcBezier(currentT, mX1, mX2) - x;\r\n        if (currentX > 0.0) {\r\n            upperBound = currentT;\r\n        }\r\n        else {\r\n            lowerBound = currentT;\r\n        }\r\n    } while (Math.abs(currentX) > subdivisionPrecision &&\r\n        ++i < subdivisionMaxIterations);\r\n    return currentT;\r\n}\r\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\r\n    // If this is a linear gradient, return linear easing\r\n    if (mX1 === mY1 && mX2 === mY2)\r\n        return noop;\r\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\r\n    // If animation is at start/end, return t without easing\r\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\r\n}\r\n\r\nexport { cubicBezier };\r\n","import { cubicBezier } from './cubic-bezier.mjs';\r\n\r\nconst easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);\r\nconst easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);\r\nconst easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);\r\n\r\nexport { easeIn, easeInOut, easeOut };\r\n","// Accepts an easing function and returns a new one that outputs mirrored values for\r\n// the second half of the animation. Turns easeIn into easeInOut.\r\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\r\n\r\nexport { mirrorEasing };\r\n","// Accepts an easing function and returns a new one that outputs reversed values.\r\n// Turns easeIn into easeOut.\r\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\r\n\r\nexport { reverseEasing };\r\n","const isEasingArray = (ease) => {\r\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\r\n};\r\n\r\nexport { isEasingArray };\r\n","import { isBezierDefinition } from 'motion-dom';\r\nimport { invariant, noop } from 'motion-utils';\r\nimport { anticipate } from '../anticipate.mjs';\r\nimport { backIn, backInOut, backOut } from '../back.mjs';\r\nimport { circIn, circInOut, circOut } from '../circ.mjs';\r\nimport { cubicBezier } from '../cubic-bezier.mjs';\r\nimport { easeIn, easeInOut, easeOut } from '../ease.mjs';\r\n\r\nconst easingLookup = {\r\n    linear: noop,\r\n    easeIn,\r\n    easeInOut,\r\n    easeOut,\r\n    circIn,\r\n    circInOut,\r\n    circOut,\r\n    backIn,\r\n    backInOut,\r\n    backOut,\r\n    anticipate,\r\n};\r\nconst easingDefinitionToFunction = (definition) => {\r\n    if (isBezierDefinition(definition)) {\r\n        // If cubic bezier definition, create bezier curve\r\n        invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\r\n        const [x1, y1, x2, y2] = definition;\r\n        return cubicBezier(x1, y1, x2, y2);\r\n    }\r\n    else if (typeof definition === \"string\") {\r\n        // Else lookup from table\r\n        invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\r\n        return easingLookup[definition];\r\n    }\r\n    return definition;\r\n};\r\n\r\nexport { easingDefinitionToFunction };\r\n","function addDomEvent(target, eventName, handler, options = { passive: true }) {\r\n    target.addEventListener(eventName, handler, options);\r\n    return () => target.removeEventListener(eventName, handler);\r\n}\r\n\r\nexport { addDomEvent };\r\n","import { addDomEvent } from './add-dom-event.mjs';\r\nimport { addPointerInfo } from './event-info.mjs';\r\n\r\nfunction addPointerEvent(target, eventName, handler, options) {\r\n    return addDomEvent(target, eventName, addPointerInfo(handler), options);\r\n}\r\n\r\nexport { addPointerEvent };\r\n","import { isPrimaryPointer } from 'motion-dom';\r\n\r\nfunction extractEventInfo(event) {\r\n    return {\r\n        point: {\r\n            x: event.pageX,\r\n            y: event.pageY,\r\n        },\r\n    };\r\n}\r\nconst addPointerInfo = (handler) => {\r\n    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));\r\n};\r\n\r\nexport { addPointerInfo, extractEventInfo };\r\n","import { MotionGlobalConfig } from '../utils/GlobalConfig.mjs';\r\nimport { createRenderStep } from './render-step.mjs';\r\n\r\nconst stepsOrder = [\r\n    \"read\", // Read\r\n    \"resolveKeyframes\", // Write/Read/Write/Read\r\n    \"update\", // Compute\r\n    \"preRender\", // Compute\r\n    \"render\", // Write\r\n    \"postRender\", // Compute\r\n];\r\nconst maxElapsed = 40;\r\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\r\n    let runNextFrame = false;\r\n    let useDefaultElapsed = true;\r\n    const state = {\r\n        delta: 0.0,\r\n        timestamp: 0.0,\r\n        isProcessing: false,\r\n    };\r\n    const flagRunNextFrame = () => (runNextFrame = true);\r\n    const steps = stepsOrder.reduce((acc, key) => {\r\n        acc[key] = createRenderStep(flagRunNextFrame);\r\n        return acc;\r\n    }, {});\r\n    const { read, resolveKeyframes, update, preRender, render, postRender } = steps;\r\n    const processBatch = () => {\r\n        const timestamp = MotionGlobalConfig.useManualTiming\r\n            ? state.timestamp\r\n            : performance.now();\r\n        runNextFrame = false;\r\n        state.delta = useDefaultElapsed\r\n            ? 1000 / 60\r\n            : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\r\n        state.timestamp = timestamp;\r\n        state.isProcessing = true;\r\n        // Unrolled render loop for better per-frame performance\r\n        read.process(state);\r\n        resolveKeyframes.process(state);\r\n        update.process(state);\r\n        preRender.process(state);\r\n        render.process(state);\r\n        postRender.process(state);\r\n        state.isProcessing = false;\r\n        if (runNextFrame && allowKeepAlive) {\r\n            useDefaultElapsed = false;\r\n            scheduleNextBatch(processBatch);\r\n        }\r\n    };\r\n    const wake = () => {\r\n        runNextFrame = true;\r\n        useDefaultElapsed = true;\r\n        if (!state.isProcessing) {\r\n            scheduleNextBatch(processBatch);\r\n        }\r\n    };\r\n    const schedule = stepsOrder.reduce((acc, key) => {\r\n        const step = steps[key];\r\n        acc[key] = (process, keepAlive = false, immediate = false) => {\r\n            if (!runNextFrame)\r\n                wake();\r\n            return step.schedule(process, keepAlive, immediate);\r\n        };\r\n        return acc;\r\n    }, {});\r\n    const cancel = (process) => {\r\n        for (let i = 0; i < stepsOrder.length; i++) {\r\n            steps[stepsOrder[i]].cancel(process);\r\n        }\r\n    };\r\n    return { schedule, cancel, state, steps };\r\n}\r\n\r\nexport { createRenderBatcher, stepsOrder };\r\n","function createRenderStep(runNextFrame) {\r\n    /**\r\n     * We create and reuse two queues, one to queue jobs for the current frame\r\n     * and one for the next. We reuse to avoid triggering GC after x frames.\r\n     */\r\n    let thisFrame = new Set();\r\n    let nextFrame = new Set();\r\n    /**\r\n     * Track whether we're currently processing jobs in this step. This way\r\n     * we can decide whether to schedule new jobs for this frame or next.\r\n     */\r\n    let isProcessing = false;\r\n    let flushNextFrame = false;\r\n    /**\r\n     * A set of processes which were marked keepAlive when scheduled.\r\n     */\r\n    const toKeepAlive = new WeakSet();\r\n    let latestFrameData = {\r\n        delta: 0.0,\r\n        timestamp: 0.0,\r\n        isProcessing: false,\r\n    };\r\n    function triggerCallback(callback) {\r\n        if (toKeepAlive.has(callback)) {\r\n            step.schedule(callback);\r\n            runNextFrame();\r\n        }\r\n        callback(latestFrameData);\r\n    }\r\n    const step = {\r\n        /**\r\n         * Schedule a process to run on the next frame.\r\n         */\r\n        schedule: (callback, keepAlive = false, immediate = false) => {\r\n            const addToCurrentFrame = immediate && isProcessing;\r\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\r\n            if (keepAlive)\r\n                toKeepAlive.add(callback);\r\n            if (!queue.has(callback))\r\n                queue.add(callback);\r\n            return callback;\r\n        },\r\n        /**\r\n         * Cancel the provided callback from running on the next frame.\r\n         */\r\n        cancel: (callback) => {\r\n            nextFrame.delete(callback);\r\n            toKeepAlive.delete(callback);\r\n        },\r\n        /**\r\n         * Execute all schedule callbacks.\r\n         */\r\n        process: (frameData) => {\r\n            latestFrameData = frameData;\r\n            /**\r\n             * If we're already processing we've probably been triggered by a flushSync\r\n             * inside an existing process. Instead of executing, mark flushNextFrame\r\n             * as true and ensure we flush the following frame at the end of this one.\r\n             */\r\n            if (isProcessing) {\r\n                flushNextFrame = true;\r\n                return;\r\n            }\r\n            isProcessing = true;\r\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\r\n            // Execute this frame\r\n            thisFrame.forEach(triggerCallback);\r\n            // Clear the frame so no callbacks remain. This is to avoid\r\n            // memory leaks should this render step not run for a while.\r\n            thisFrame.clear();\r\n            isProcessing = false;\r\n            if (flushNextFrame) {\r\n                flushNextFrame = false;\r\n                step.process(frameData);\r\n            }\r\n        },\r\n    };\r\n    return step;\r\n}\r\n\r\nexport { createRenderStep };\r\n","import { noop } from 'motion-utils';\r\nimport { createRenderBatcher } from './batcher.mjs';\r\n\r\nconst { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : noop, true);\r\n\r\nexport { cancelFrame, frame, frameData, frameSteps };\r\n","import { createRenderBatcher } from './batcher.mjs';\r\n\r\nconst { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);\r\n\r\nexport { cancelMicrotask, microtask };\r\n","import { MotionGlobalConfig } from '../utils/GlobalConfig.mjs';\r\nimport { frameData } from './frame.mjs';\r\n\r\nlet now;\r\nfunction clearTime() {\r\n    now = undefined;\r\n}\r\n/**\r\n * An eventloop-synchronous alternative to performance.now().\r\n *\r\n * Ensures that time measurements remain consistent within a synchronous context.\r\n * Usually calling performance.now() twice within the same synchronous context\r\n * will return different values which isn't useful for animations when we're usually\r\n * trying to sync animations to the same frame.\r\n */\r\nconst time = {\r\n    now: () => {\r\n        if (now === undefined) {\r\n            time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming\r\n                ? frameData.timestamp\r\n                : performance.now());\r\n        }\r\n        return now;\r\n    },\r\n    set: (newTime) => {\r\n        now = newTime;\r\n        queueMicrotask(clearTime);\r\n    },\r\n};\r\n\r\nexport { time };\r\n","import { progress } from 'motion-utils';\r\nimport { calcLength } from '../../../projection/geometry/delta-calc.mjs';\r\nimport { clamp } from '../../../utils/clamp.mjs';\r\nimport { mixNumber } from '../../../utils/mix/number.mjs';\r\n\r\n/**\r\n * Apply constraints to a point. These constraints are both physical along an\r\n * axis, and an elastic factor that determines how much to constrain the point\r\n * by if it does lie outside the defined parameters.\r\n */\r\nfunction applyConstraints(point, { min, max }, elastic) {\r\n    if (min !== undefined && point < min) {\r\n        // If we have a min point defined, and this is outside of that, constrain\r\n        point = elastic\r\n            ? mixNumber(min, point, elastic.min)\r\n            : Math.max(point, min);\r\n    }\r\n    else if (max !== undefined && point > max) {\r\n        // If we have a max point defined, and this is outside of that, constrain\r\n        point = elastic\r\n            ? mixNumber(max, point, elastic.max)\r\n            : Math.min(point, max);\r\n    }\r\n    return point;\r\n}\r\n/**\r\n * Calculate constraints in terms of the viewport when defined relatively to the\r\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\r\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\r\n */\r\nfunction calcRelativeAxisConstraints(axis, min, max) {\r\n    return {\r\n        min: min !== undefined ? axis.min + min : undefined,\r\n        max: max !== undefined\r\n            ? axis.max + max - (axis.max - axis.min)\r\n            : undefined,\r\n    };\r\n}\r\n/**\r\n * Calculate constraints in terms of the viewport when\r\n * defined relatively to the measured bounding box.\r\n */\r\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\r\n    return {\r\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\r\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\r\n    };\r\n}\r\n/**\r\n * Calculate viewport constraints when defined as another viewport-relative axis\r\n */\r\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\r\n    let min = constraintsAxis.min - layoutAxis.min;\r\n    let max = constraintsAxis.max - layoutAxis.max;\r\n    // If the constraints axis is actually smaller than the layout axis then we can\r\n    // flip the constraints\r\n    if (constraintsAxis.max - constraintsAxis.min <\r\n        layoutAxis.max - layoutAxis.min) {\r\n        [min, max] = [max, min];\r\n    }\r\n    return { min, max };\r\n}\r\n/**\r\n * Calculate viewport constraints when defined as another viewport-relative box\r\n */\r\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\r\n    return {\r\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\r\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\r\n    };\r\n}\r\n/**\r\n * Calculate a transform origin relative to the source axis, between 0-1, that results\r\n * in an asthetically pleasing scale/transform needed to project from source to target.\r\n */\r\nfunction calcOrigin(source, target) {\r\n    let origin = 0.5;\r\n    const sourceLength = calcLength(source);\r\n    const targetLength = calcLength(target);\r\n    if (targetLength > sourceLength) {\r\n        origin = progress(target.min, target.max - sourceLength, source.min);\r\n    }\r\n    else if (sourceLength > targetLength) {\r\n        origin = progress(source.min, source.max - targetLength, target.min);\r\n    }\r\n    return clamp(0, 1, origin);\r\n}\r\n/**\r\n * Rebase the calculated viewport constraints relative to the layout.min point.\r\n */\r\nfunction rebaseAxisConstraints(layout, constraints) {\r\n    const relativeConstraints = {};\r\n    if (constraints.min !== undefined) {\r\n        relativeConstraints.min = constraints.min - layout.min;\r\n    }\r\n    if (constraints.max !== undefined) {\r\n        relativeConstraints.max = constraints.max - layout.min;\r\n    }\r\n    return relativeConstraints;\r\n}\r\nconst defaultElastic = 0.35;\r\n/**\r\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\r\n */\r\nfunction resolveDragElastic(dragElastic = defaultElastic) {\r\n    if (dragElastic === false) {\r\n        dragElastic = 0;\r\n    }\r\n    else if (dragElastic === true) {\r\n        dragElastic = defaultElastic;\r\n    }\r\n    return {\r\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\r\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\r\n    };\r\n}\r\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\r\n    return {\r\n        min: resolvePointElastic(dragElastic, minLabel),\r\n        max: resolvePointElastic(dragElastic, maxLabel),\r\n    };\r\n}\r\nfunction resolvePointElastic(dragElastic, label) {\r\n    return typeof dragElastic === \"number\"\r\n        ? dragElastic\r\n        : dragElastic[label] || 0;\r\n}\r\n\r\nexport { applyConstraints, calcOrigin, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };\r\n","import { invariant } from 'motion-utils';\r\nimport { setDragLock } from 'motion-dom';\r\nimport { PanSession } from '../pan/PanSession.mjs';\r\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\r\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\r\nimport { applyConstraints, calcRelativeConstraints, resolveDragElastic, rebaseAxisConstraints, calcViewportConstraints, calcOrigin, defaultElastic } from './utils/constraints.mjs';\r\nimport { createBox } from '../../projection/geometry/models.mjs';\r\nimport { eachAxis } from '../../projection/utils/each-axis.mjs';\r\nimport { measurePageBox } from '../../projection/utils/measure.mjs';\r\nimport { extractEventInfo } from '../../events/event-info.mjs';\r\nimport { convertBoxToBoundingBox, convertBoundingBoxToBox } from '../../projection/geometry/conversion.mjs';\r\nimport { addDomEvent } from '../../events/add-dom-event.mjs';\r\nimport { calcLength } from '../../projection/geometry/delta-calc.mjs';\r\nimport { mixNumber } from '../../utils/mix/number.mjs';\r\nimport { percent } from '../../value/types/numbers/units.mjs';\r\nimport { animateMotionValue } from '../../animation/interfaces/motion-value.mjs';\r\nimport { getContextWindow } from '../../utils/get-context-window.mjs';\r\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\r\nimport { frame } from '../../frameloop/frame.mjs';\r\n\r\nconst elementDragControls = new WeakMap();\r\n/**\r\n *\r\n */\r\n// let latestPointerEvent: PointerEvent\r\nclass VisualElementDragControls {\r\n    constructor(visualElement) {\r\n        this.openDragLock = null;\r\n        this.isDragging = false;\r\n        this.currentDirection = null;\r\n        this.originPoint = { x: 0, y: 0 };\r\n        /**\r\n         * The permitted boundaries of travel, in pixels.\r\n         */\r\n        this.constraints = false;\r\n        this.hasMutatedConstraints = false;\r\n        /**\r\n         * The per-axis resolved elastic values.\r\n         */\r\n        this.elastic = createBox();\r\n        this.visualElement = visualElement;\r\n    }\r\n    start(originEvent, { snapToCursor = false } = {}) {\r\n        /**\r\n         * Don't start dragging if this component is exiting\r\n         */\r\n        const { presenceContext } = this.visualElement;\r\n        if (presenceContext && presenceContext.isPresent === false)\r\n            return;\r\n        const onSessionStart = (event) => {\r\n            const { dragSnapToOrigin } = this.getProps();\r\n            // Stop or pause any animations on both axis values immediately. This allows the user to throw and catch\r\n            // the component.\r\n            dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();\r\n            if (snapToCursor) {\r\n                this.snapToCursor(extractEventInfo(event).point);\r\n            }\r\n        };\r\n        const onStart = (event, info) => {\r\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\r\n            const { drag, dragPropagation, onDragStart } = this.getProps();\r\n            if (drag && !dragPropagation) {\r\n                if (this.openDragLock)\r\n                    this.openDragLock();\r\n                this.openDragLock = setDragLock(drag);\r\n                // If we don 't have the lock, don't start dragging\r\n                if (!this.openDragLock)\r\n                    return;\r\n            }\r\n            this.isDragging = true;\r\n            this.currentDirection = null;\r\n            this.resolveConstraints();\r\n            if (this.visualElement.projection) {\r\n                this.visualElement.projection.isAnimationBlocked = true;\r\n                this.visualElement.projection.target = undefined;\r\n            }\r\n            /**\r\n             * Record gesture origin\r\n             */\r\n            eachAxis((axis) => {\r\n                let current = this.getAxisMotionValue(axis).get() || 0;\r\n                /**\r\n                 * If the MotionValue is a percentage value convert to px\r\n                 */\r\n                if (percent.test(current)) {\r\n                    const { projection } = this.visualElement;\r\n                    if (projection && projection.layout) {\r\n                        const measuredAxis = projection.layout.layoutBox[axis];\r\n                        if (measuredAxis) {\r\n                            const length = calcLength(measuredAxis);\r\n                            current = length * (parseFloat(current) / 100);\r\n                        }\r\n                    }\r\n                }\r\n                this.originPoint[axis] = current;\r\n            });\r\n            // Fire onDragStart event\r\n            if (onDragStart) {\r\n                frame.postRender(() => onDragStart(event, info));\r\n            }\r\n            addValueToWillChange(this.visualElement, \"transform\");\r\n            const { animationState } = this.visualElement;\r\n            animationState && animationState.setActive(\"whileDrag\", true);\r\n        };\r\n        const onMove = (event, info) => {\r\n            // latestPointerEvent = event\r\n            const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();\r\n            // If we didn't successfully receive the gesture lock, early return.\r\n            if (!dragPropagation && !this.openDragLock)\r\n                return;\r\n            const { offset } = info;\r\n            // Attempt to detect drag direction if directionLock is true\r\n            if (dragDirectionLock && this.currentDirection === null) {\r\n                this.currentDirection = getCurrentDirection(offset);\r\n                // If we've successfully set a direction, notify listener\r\n                if (this.currentDirection !== null) {\r\n                    onDirectionLock && onDirectionLock(this.currentDirection);\r\n                }\r\n                return;\r\n            }\r\n            // Update each point with the latest position\r\n            this.updateAxis(\"x\", info.point, offset);\r\n            this.updateAxis(\"y\", info.point, offset);\r\n            /**\r\n             * Ideally we would leave the renderer to fire naturally at the end of\r\n             * this frame but if the element is about to change layout as the result\r\n             * of a re-render we want to ensure the browser can read the latest\r\n             * bounding box to ensure the pointer and element don't fall out of sync.\r\n             */\r\n            this.visualElement.render();\r\n            /**\r\n             * This must fire after the render call as it might trigger a state\r\n             * change which itself might trigger a layout update.\r\n             */\r\n            onDrag && onDrag(event, info);\r\n        };\r\n        const onSessionEnd = (event, info) => this.stop(event, info);\r\n        const resumeAnimation = () => eachAxis((axis) => {\r\n            var _a;\r\n            return this.getAnimationState(axis) === \"paused\" &&\r\n                ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());\r\n        });\r\n        const { dragSnapToOrigin } = this.getProps();\r\n        this.panSession = new PanSession(originEvent, {\r\n            onSessionStart,\r\n            onStart,\r\n            onMove,\r\n            onSessionEnd,\r\n            resumeAnimation,\r\n        }, {\r\n            transformPagePoint: this.visualElement.getTransformPagePoint(),\r\n            dragSnapToOrigin,\r\n            contextWindow: getContextWindow(this.visualElement),\r\n        });\r\n    }\r\n    stop(event, info) {\r\n        const isDragging = this.isDragging;\r\n        this.cancel();\r\n        if (!isDragging)\r\n            return;\r\n        const { velocity } = info;\r\n        this.startAnimation(velocity);\r\n        const { onDragEnd } = this.getProps();\r\n        if (onDragEnd) {\r\n            frame.postRender(() => onDragEnd(event, info));\r\n        }\r\n    }\r\n    cancel() {\r\n        this.isDragging = false;\r\n        const { projection, animationState } = this.visualElement;\r\n        if (projection) {\r\n            projection.isAnimationBlocked = false;\r\n        }\r\n        this.panSession && this.panSession.end();\r\n        this.panSession = undefined;\r\n        const { dragPropagation } = this.getProps();\r\n        if (!dragPropagation && this.openDragLock) {\r\n            this.openDragLock();\r\n            this.openDragLock = null;\r\n        }\r\n        animationState && animationState.setActive(\"whileDrag\", false);\r\n    }\r\n    updateAxis(axis, _point, offset) {\r\n        const { drag } = this.getProps();\r\n        // If we're not dragging this axis, do an early return.\r\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection))\r\n            return;\r\n        const axisValue = this.getAxisMotionValue(axis);\r\n        let next = this.originPoint[axis] + offset[axis];\r\n        // Apply constraints\r\n        if (this.constraints && this.constraints[axis]) {\r\n            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\r\n        }\r\n        axisValue.set(next);\r\n    }\r\n    resolveConstraints() {\r\n        var _a;\r\n        const { dragConstraints, dragElastic } = this.getProps();\r\n        const layout = this.visualElement.projection &&\r\n            !this.visualElement.projection.layout\r\n            ? this.visualElement.projection.measure(false)\r\n            : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;\r\n        const prevConstraints = this.constraints;\r\n        if (dragConstraints && isRefObject(dragConstraints)) {\r\n            if (!this.constraints) {\r\n                this.constraints = this.resolveRefConstraints();\r\n            }\r\n        }\r\n        else {\r\n            if (dragConstraints && layout) {\r\n                this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\r\n            }\r\n            else {\r\n                this.constraints = false;\r\n            }\r\n        }\r\n        this.elastic = resolveDragElastic(dragElastic);\r\n        /**\r\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\r\n         * from viewport-relative to component-relative.\r\n         */\r\n        if (prevConstraints !== this.constraints &&\r\n            layout &&\r\n            this.constraints &&\r\n            !this.hasMutatedConstraints) {\r\n            eachAxis((axis) => {\r\n                if (this.constraints !== false &&\r\n                    this.getAxisMotionValue(axis)) {\r\n                    this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    resolveRefConstraints() {\r\n        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();\r\n        if (!constraints || !isRefObject(constraints))\r\n            return false;\r\n        const constraintsElement = constraints.current;\r\n        invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\r\n        const { projection } = this.visualElement;\r\n        // TODO\r\n        if (!projection || !projection.layout)\r\n            return false;\r\n        const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\r\n        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\r\n        /**\r\n         * If there's an onMeasureDragConstraints listener we call it and\r\n         * if different constraints are returned, set constraints to that\r\n         */\r\n        if (onMeasureDragConstraints) {\r\n            const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\r\n            this.hasMutatedConstraints = !!userConstraints;\r\n            if (userConstraints) {\r\n                measuredConstraints = convertBoundingBoxToBox(userConstraints);\r\n            }\r\n        }\r\n        return measuredConstraints;\r\n    }\r\n    startAnimation(velocity) {\r\n        const { drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = this.getProps();\r\n        const constraints = this.constraints || {};\r\n        const momentumAnimations = eachAxis((axis) => {\r\n            if (!shouldDrag(axis, drag, this.currentDirection)) {\r\n                return;\r\n            }\r\n            let transition = (constraints && constraints[axis]) || {};\r\n            if (dragSnapToOrigin)\r\n                transition = { min: 0, max: 0 };\r\n            /**\r\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\r\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\r\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\r\n             * using the value of `dragElastic`.\r\n             */\r\n            const bounceStiffness = dragElastic ? 200 : 1000000;\r\n            const bounceDamping = dragElastic ? 40 : 10000000;\r\n            const inertia = {\r\n                type: \"inertia\",\r\n                velocity: dragMomentum ? velocity[axis] : 0,\r\n                bounceStiffness,\r\n                bounceDamping,\r\n                timeConstant: 750,\r\n                restDelta: 1,\r\n                restSpeed: 10,\r\n                ...dragTransition,\r\n                ...transition,\r\n            };\r\n            // If we're not animating on an externally-provided `MotionValue` we can use the\r\n            // component's animation controls which will handle interactions with whileHover (etc),\r\n            // otherwise we just have to animate the `MotionValue` itself.\r\n            return this.startAxisValueAnimation(axis, inertia);\r\n        });\r\n        // Run all animations and then resolve the new drag constraints.\r\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd);\r\n    }\r\n    startAxisValueAnimation(axis, transition) {\r\n        const axisValue = this.getAxisMotionValue(axis);\r\n        addValueToWillChange(this.visualElement, axis);\r\n        return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));\r\n    }\r\n    stopAnimation() {\r\n        eachAxis((axis) => this.getAxisMotionValue(axis).stop());\r\n    }\r\n    pauseAnimation() {\r\n        eachAxis((axis) => { var _a; return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause(); });\r\n    }\r\n    getAnimationState(axis) {\r\n        var _a;\r\n        return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;\r\n    }\r\n    /**\r\n     * Drag works differently depending on which props are provided.\r\n     *\r\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\r\n     * - Otherwise, we apply the delta to the x/y motion values.\r\n     */\r\n    getAxisMotionValue(axis) {\r\n        const dragKey = `_drag${axis.toUpperCase()}`;\r\n        const props = this.visualElement.getProps();\r\n        const externalMotionValue = props[dragKey];\r\n        return externalMotionValue\r\n            ? externalMotionValue\r\n            : this.visualElement.getValue(axis, (props.initial\r\n                ? props.initial[axis]\r\n                : undefined) || 0);\r\n    }\r\n    snapToCursor(point) {\r\n        eachAxis((axis) => {\r\n            const { drag } = this.getProps();\r\n            // If we're not dragging this axis, do an early return.\r\n            if (!shouldDrag(axis, drag, this.currentDirection))\r\n                return;\r\n            const { projection } = this.visualElement;\r\n            const axisValue = this.getAxisMotionValue(axis);\r\n            if (projection && projection.layout) {\r\n                const { min, max } = projection.layout.layoutBox[axis];\r\n                axisValue.set(point[axis] - mixNumber(min, max, 0.5));\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * When the viewport resizes we want to check if the measured constraints\r\n     * have changed and, if so, reposition the element within those new constraints\r\n     * relative to where it was before the resize.\r\n     */\r\n    scalePositionWithinConstraints() {\r\n        if (!this.visualElement.current)\r\n            return;\r\n        const { drag, dragConstraints } = this.getProps();\r\n        const { projection } = this.visualElement;\r\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints)\r\n            return;\r\n        /**\r\n         * Stop current animations as there can be visual glitching if we try to do\r\n         * this mid-animation\r\n         */\r\n        this.stopAnimation();\r\n        /**\r\n         * Record the relative position of the dragged element relative to the\r\n         * constraints box and save as a progress value.\r\n         */\r\n        const boxProgress = { x: 0, y: 0 };\r\n        eachAxis((axis) => {\r\n            const axisValue = this.getAxisMotionValue(axis);\r\n            if (axisValue && this.constraints !== false) {\r\n                const latest = axisValue.get();\r\n                boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);\r\n            }\r\n        });\r\n        /**\r\n         * Update the layout of this element and resolve the latest drag constraints\r\n         */\r\n        const { transformTemplate } = this.visualElement.getProps();\r\n        this.visualElement.current.style.transform = transformTemplate\r\n            ? transformTemplate({}, \"\")\r\n            : \"none\";\r\n        projection.root && projection.root.updateScroll();\r\n        projection.updateLayout();\r\n        this.resolveConstraints();\r\n        /**\r\n         * For each axis, calculate the current progress of the layout axis\r\n         * within the new constraints.\r\n         */\r\n        eachAxis((axis) => {\r\n            if (!shouldDrag(axis, drag, null))\r\n                return;\r\n            /**\r\n             * Calculate a new transform based on the previous box progress\r\n             */\r\n            const axisValue = this.getAxisMotionValue(axis);\r\n            const { min, max } = this.constraints[axis];\r\n            axisValue.set(mixNumber(min, max, boxProgress[axis]));\r\n        });\r\n    }\r\n    addListeners() {\r\n        if (!this.visualElement.current)\r\n            return;\r\n        elementDragControls.set(this.visualElement, this);\r\n        const element = this.visualElement.current;\r\n        /**\r\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\r\n         */\r\n        const stopPointerListener = addPointerEvent(element, \"pointerdown\", (event) => {\r\n            const { drag, dragListener = true } = this.getProps();\r\n            drag && dragListener && this.start(event);\r\n        });\r\n        const measureDragConstraints = () => {\r\n            const { dragConstraints } = this.getProps();\r\n            if (isRefObject(dragConstraints) && dragConstraints.current) {\r\n                this.constraints = this.resolveRefConstraints();\r\n            }\r\n        };\r\n        const { projection } = this.visualElement;\r\n        const stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\r\n        if (projection && !projection.layout) {\r\n            projection.root && projection.root.updateScroll();\r\n            projection.updateLayout();\r\n        }\r\n        frame.read(measureDragConstraints);\r\n        /**\r\n         * Attach a window resize listener to scale the draggable target within its defined\r\n         * constraints as the window resizes.\r\n         */\r\n        const stopResizeListener = addDomEvent(window, \"resize\", () => this.scalePositionWithinConstraints());\r\n        /**\r\n         * If the element's layout changes, calculate the delta and apply that to\r\n         * the drag gesture's origin point.\r\n         */\r\n        const stopLayoutUpdateListener = projection.addEventListener(\"didUpdate\", (({ delta, hasLayoutChanged }) => {\r\n            if (this.isDragging && hasLayoutChanged) {\r\n                eachAxis((axis) => {\r\n                    const motionValue = this.getAxisMotionValue(axis);\r\n                    if (!motionValue)\r\n                        return;\r\n                    this.originPoint[axis] += delta[axis].translate;\r\n                    motionValue.set(motionValue.get() + delta[axis].translate);\r\n                });\r\n                this.visualElement.render();\r\n            }\r\n        }));\r\n        return () => {\r\n            stopResizeListener();\r\n            stopPointerListener();\r\n            stopMeasureLayoutListener();\r\n            stopLayoutUpdateListener && stopLayoutUpdateListener();\r\n        };\r\n    }\r\n    getProps() {\r\n        const props = this.visualElement.getProps();\r\n        const { drag = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true, } = props;\r\n        return {\r\n            ...props,\r\n            drag,\r\n            dragDirectionLock,\r\n            dragPropagation,\r\n            dragConstraints,\r\n            dragElastic,\r\n            dragMomentum,\r\n        };\r\n    }\r\n}\r\nfunction shouldDrag(direction, drag, currentDirection) {\r\n    return ((drag === true || drag === direction) &&\r\n        (currentDirection === null || currentDirection === direction));\r\n}\r\n/**\r\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\r\n * than the provided threshold, return `null`.\r\n *\r\n * @param offset - The x/y offset from origin.\r\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\r\n */\r\nfunction getCurrentDirection(offset, lockThreshold = 10) {\r\n    let direction = null;\r\n    if (Math.abs(offset.y) > lockThreshold) {\r\n        direction = \"y\";\r\n    }\r\n    else if (Math.abs(offset.x) > lockThreshold) {\r\n        direction = \"x\";\r\n    }\r\n    return direction;\r\n}\r\n\r\nexport { VisualElementDragControls, elementDragControls };\r\n","import { Feature } from '../../motion/features/Feature.mjs';\r\nimport { noop } from 'motion-utils';\r\nimport { VisualElementDragControls } from './VisualElementDragControls.mjs';\r\n\r\nclass DragGesture extends Feature {\r\n    constructor(node) {\r\n        super(node);\r\n        this.removeGroupControls = noop;\r\n        this.removeListeners = noop;\r\n        this.controls = new VisualElementDragControls(node);\r\n    }\r\n    mount() {\r\n        // If we've been provided a DragControls for manual control over the drag gesture,\r\n        // subscribe this component to it on mount.\r\n        const { dragControls } = this.node.getProps();\r\n        if (dragControls) {\r\n            this.removeGroupControls = dragControls.subscribe(this.controls);\r\n        }\r\n        this.removeListeners = this.controls.addListeners() || noop;\r\n    }\r\n    unmount() {\r\n        this.removeGroupControls();\r\n        this.removeListeners();\r\n    }\r\n}\r\n\r\nexport { DragGesture };\r\n","import { addDomEvent } from '../events/add-dom-event.mjs';\r\nimport { Feature } from '../motion/features/Feature.mjs';\r\nimport { pipe } from '../utils/pipe.mjs';\r\n\r\nclass FocusGesture extends Feature {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.isActive = false;\r\n    }\r\n    onFocus() {\r\n        let isFocusVisible = false;\r\n        /**\r\n         * If this element doesn't match focus-visible then don't\r\n         * apply whileHover. But, if matches throws that focus-visible\r\n         * is not a valid selector then in that browser outline styles will be applied\r\n         * to the element by default and we want to match that behaviour with whileFocus.\r\n         */\r\n        try {\r\n            isFocusVisible = this.node.current.matches(\":focus-visible\");\r\n        }\r\n        catch (e) {\r\n            isFocusVisible = true;\r\n        }\r\n        if (!isFocusVisible || !this.node.animationState)\r\n            return;\r\n        this.node.animationState.setActive(\"whileFocus\", true);\r\n        this.isActive = true;\r\n    }\r\n    onBlur() {\r\n        if (!this.isActive || !this.node.animationState)\r\n            return;\r\n        this.node.animationState.setActive(\"whileFocus\", false);\r\n        this.isActive = false;\r\n    }\r\n    mount() {\r\n        this.unmount = pipe(addDomEvent(this.node.current, \"focus\", () => this.onFocus()), addDomEvent(this.node.current, \"blur\", () => this.onBlur()));\r\n    }\r\n    unmount() { }\r\n}\r\n\r\nexport { FocusGesture };\r\n","import { Feature } from '../motion/features/Feature.mjs';\r\nimport { hover } from 'motion-dom';\r\nimport { extractEventInfo } from '../events/event-info.mjs';\r\nimport { frame } from '../frameloop/frame.mjs';\r\n\r\nfunction handleHoverEvent(node, event, lifecycle) {\r\n    const { props } = node;\r\n    if (node.animationState && props.whileHover) {\r\n        node.animationState.setActive(\"whileHover\", lifecycle === \"Start\");\r\n    }\r\n    const eventName = (\"onHover\" + lifecycle);\r\n    const callback = props[eventName];\r\n    if (callback) {\r\n        frame.postRender(() => callback(event, extractEventInfo(event)));\r\n    }\r\n}\r\nclass HoverGesture extends Feature {\r\n    mount() {\r\n        const { current } = this.node;\r\n        if (!current)\r\n            return;\r\n        this.unmount = hover(current, (startEvent) => {\r\n            handleHoverEvent(this.node, startEvent, \"Start\");\r\n            return (endEvent) => handleHoverEvent(this.node, endEvent, \"End\");\r\n        });\r\n    }\r\n    unmount() { }\r\n}\r\n\r\nexport { HoverGesture };\r\n","import { isPrimaryPointer } from 'motion-dom';\r\nimport { secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\r\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\r\nimport { extractEventInfo } from '../../events/event-info.mjs';\r\nimport { distance2D } from '../../utils/distance.mjs';\r\nimport { pipe } from '../../utils/pipe.mjs';\r\nimport { frame, cancelFrame, frameData } from '../../frameloop/frame.mjs';\r\n\r\n/**\r\n * @internal\r\n */\r\nclass PanSession {\r\n    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {}) {\r\n        /**\r\n         * @internal\r\n         */\r\n        this.startEvent = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.lastMoveEvent = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.lastMoveEventInfo = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.handlers = {};\r\n        /**\r\n         * @internal\r\n         */\r\n        this.contextWindow = window;\r\n        this.updatePoint = () => {\r\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\r\n                return;\r\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\r\n            const isPanStarted = this.startEvent !== null;\r\n            // Only start panning if the offset is larger than 3 pixels. If we make it\r\n            // any larger than this we'll want to reset the pointer history\r\n            // on the first update to avoid visual snapping to the cursoe.\r\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\r\n            if (!isPanStarted && !isDistancePastThreshold)\r\n                return;\r\n            const { point } = info;\r\n            const { timestamp } = frameData;\r\n            this.history.push({ ...point, timestamp });\r\n            const { onStart, onMove } = this.handlers;\r\n            if (!isPanStarted) {\r\n                onStart && onStart(this.lastMoveEvent, info);\r\n                this.startEvent = this.lastMoveEvent;\r\n            }\r\n            onMove && onMove(this.lastMoveEvent, info);\r\n        };\r\n        this.handlePointerMove = (event, info) => {\r\n            this.lastMoveEvent = event;\r\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\r\n            // Throttle mouse move event to once per frame\r\n            frame.update(this.updatePoint, true);\r\n        };\r\n        this.handlePointerUp = (event, info) => {\r\n            this.end();\r\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\r\n            if (this.dragSnapToOrigin)\r\n                resumeAnimation && resumeAnimation();\r\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\r\n                return;\r\n            const panInfo = getPanInfo(event.type === \"pointercancel\"\r\n                ? this.lastMoveEventInfo\r\n                : transformPoint(info, this.transformPagePoint), this.history);\r\n            if (this.startEvent && onEnd) {\r\n                onEnd(event, panInfo);\r\n            }\r\n            onSessionEnd && onSessionEnd(event, panInfo);\r\n        };\r\n        // If we have more than one touch, don't start detecting this gesture\r\n        if (!isPrimaryPointer(event))\r\n            return;\r\n        this.dragSnapToOrigin = dragSnapToOrigin;\r\n        this.handlers = handlers;\r\n        this.transformPagePoint = transformPagePoint;\r\n        this.contextWindow = contextWindow || window;\r\n        const info = extractEventInfo(event);\r\n        const initialInfo = transformPoint(info, this.transformPagePoint);\r\n        const { point } = initialInfo;\r\n        const { timestamp } = frameData;\r\n        this.history = [{ ...point, timestamp }];\r\n        const { onSessionStart } = handlers;\r\n        onSessionStart &&\r\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\r\n        this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\r\n    }\r\n    updateHandlers(handlers) {\r\n        this.handlers = handlers;\r\n    }\r\n    end() {\r\n        this.removeListeners && this.removeListeners();\r\n        cancelFrame(this.updatePoint);\r\n    }\r\n}\r\nfunction transformPoint(info, transformPagePoint) {\r\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\r\n}\r\nfunction subtractPoint(a, b) {\r\n    return { x: a.x - b.x, y: a.y - b.y };\r\n}\r\nfunction getPanInfo({ point }, history) {\r\n    return {\r\n        point,\r\n        delta: subtractPoint(point, lastDevicePoint(history)),\r\n        offset: subtractPoint(point, startDevicePoint(history)),\r\n        velocity: getVelocity(history, 0.1),\r\n    };\r\n}\r\nfunction startDevicePoint(history) {\r\n    return history[0];\r\n}\r\nfunction lastDevicePoint(history) {\r\n    return history[history.length - 1];\r\n}\r\nfunction getVelocity(history, timeDelta) {\r\n    if (history.length < 2) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    let i = history.length - 1;\r\n    let timestampedPoint = null;\r\n    const lastPoint = lastDevicePoint(history);\r\n    while (i >= 0) {\r\n        timestampedPoint = history[i];\r\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\r\n            secondsToMilliseconds(timeDelta)) {\r\n            break;\r\n        }\r\n        i--;\r\n    }\r\n    if (!timestampedPoint) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\r\n    if (time === 0) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    const currentVelocity = {\r\n        x: (lastPoint.x - timestampedPoint.x) / time,\r\n        y: (lastPoint.y - timestampedPoint.y) / time,\r\n    };\r\n    if (currentVelocity.x === Infinity) {\r\n        currentVelocity.x = 0;\r\n    }\r\n    if (currentVelocity.y === Infinity) {\r\n        currentVelocity.y = 0;\r\n    }\r\n    return currentVelocity;\r\n}\r\n\r\nexport { PanSession };\r\n","import { PanSession } from './PanSession.mjs';\r\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\r\nimport { Feature } from '../../motion/features/Feature.mjs';\r\nimport { noop } from 'motion-utils';\r\nimport { getContextWindow } from '../../utils/get-context-window.mjs';\r\nimport { frame } from '../../frameloop/frame.mjs';\r\n\r\nconst asyncHandler = (handler) => (event, info) => {\r\n    if (handler) {\r\n        frame.postRender(() => handler(event, info));\r\n    }\r\n};\r\nclass PanGesture extends Feature {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.removePointerDownListener = noop;\r\n    }\r\n    onPointerDown(pointerDownEvent) {\r\n        this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {\r\n            transformPagePoint: this.node.getTransformPagePoint(),\r\n            contextWindow: getContextWindow(this.node),\r\n        });\r\n    }\r\n    createPanHandlers() {\r\n        const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();\r\n        return {\r\n            onSessionStart: asyncHandler(onPanSessionStart),\r\n            onStart: asyncHandler(onPanStart),\r\n            onMove: onPan,\r\n            onEnd: (event, info) => {\r\n                delete this.session;\r\n                if (onPanEnd) {\r\n                    frame.postRender(() => onPanEnd(event, info));\r\n                }\r\n            },\r\n        };\r\n    }\r\n    mount() {\r\n        this.removePointerDownListener = addPointerEvent(this.node.current, \"pointerdown\", (event) => this.onPointerDown(event));\r\n    }\r\n    update() {\r\n        this.session && this.session.updateHandlers(this.createPanHandlers());\r\n    }\r\n    unmount() {\r\n        this.removePointerDownListener();\r\n        this.session && this.session.end();\r\n    }\r\n}\r\n\r\nexport { PanGesture };\r\n","import { Feature } from '../motion/features/Feature.mjs';\r\nimport { press } from 'motion-dom';\r\nimport { extractEventInfo } from '../events/event-info.mjs';\r\nimport { frame } from '../frameloop/frame.mjs';\r\n\r\nfunction handlePressEvent(node, event, lifecycle) {\r\n    const { props } = node;\r\n    if (node.animationState && props.whileTap) {\r\n        node.animationState.setActive(\"whileTap\", lifecycle === \"Start\");\r\n    }\r\n    const eventName = (\"onTap\" + (lifecycle === \"End\" ? \"\" : lifecycle));\r\n    const callback = props[eventName];\r\n    if (callback) {\r\n        frame.postRender(() => callback(event, extractEventInfo(event)));\r\n    }\r\n}\r\nclass PressGesture extends Feature {\r\n    mount() {\r\n        const { current } = this.node;\r\n        if (!current)\r\n            return;\r\n        this.unmount = press(current, (startEvent) => {\r\n            handlePressEvent(this.node, startEvent, \"Start\");\r\n            return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? \"End\" : \"Cancel\");\r\n        }, { useGlobalTarget: this.node.props.globalTapTarget });\r\n    }\r\n    unmount() { }\r\n}\r\n\r\nexport { PressGesture };\r\n"],"names":["anticipate","p","Math","pow","backOut","backIn","backInOut","circIn","sin","acos","circOut","circInOut","calcBezier","t","a1","a2","subdivisionPrecision","subdivisionMaxIterations","cubicBezier","mX1","mY1","mX2","mY2","getTForX","aX","x","lowerBound","upperBound","currentX","currentT","i","abs","binarySubdivide","easeIn","easeOut","easeInOut","mirrorEasing","easing","reverseEasing","isEasingArray","ease","Array","isArray","easingLookup","linear","easingDefinitionToFunction","definition","length","x1","y1","x2","y2","undefined","addDomEvent","target","eventName","handler","options","passive","addEventListener","removeEventListener","addPointerEvent","extractEventInfo","event","point","pageX","y","pageY","addPointerInfo","stepsOrder","maxElapsed","createRenderBatcher","scheduleNextBatch","allowKeepAlive","runNextFrame","useDefaultElapsed","state","delta","timestamp","isProcessing","flagRunNextFrame","steps","reduce","acc","key","thisFrame","Set","nextFrame","flushNextFrame","toKeepAlive","WeakSet","latestFrameData","triggerCallback","callback","has","step","schedule","keepAlive","immediate","queue","add","cancel","delete","process","frameData","forEach","clear","createRenderStep","read","resolveKeyframes","update","preRender","render","postRender","processBatch","useManualTiming","performance","now","max","min","frame","cancelFrame","frameSteps","requestAnimationFrame","microtask","cancelMicrotask","queueMicrotask","clearTime","time","set","newTime","calcRelativeAxisConstraints","axis","calcViewportAxisConstraints","layoutAxis","constraintsAxis","defaultElastic","resolveAxisElastic","dragElastic","minLabel","maxLabel","resolvePointElastic","label","elementDragControls","WeakMap","VisualElementDragControls","constructor","visualElement","this","openDragLock","isDragging","currentDirection","originPoint","constraints","hasMutatedConstraints","elastic","start","originEvent","snapToCursor","presenceContext","isPresent","dragSnapToOrigin","getProps","panSession","PanSession","onSessionStart","pauseAnimation","stopAnimation","e","onStart","info","drag","dragPropagation","onDragStart","resolveConstraints","projection","isAnimationBlocked","current","getAxisMotionValue","get","test","layout","measuredAxis","layoutBox","parseFloat","animationState","setActive","onMove","dragDirectionLock","onDirectionLock","onDrag","offset","lockThreshold","direction","getCurrentDirection","updateAxis","onSessionEnd","stop","resumeAnimation","_a","getAnimationState","animation","play","transformPagePoint","getTransformPagePoint","contextWindow","velocity","startAnimation","onDragEnd","end","_point","shouldDrag","axisValue","next","applyConstraints","dragConstraints","measure","prevConstraints","resolveRefConstraints","top","left","bottom","right","calcRelativeConstraints","resolveDragElastic","relativeConstraints","rebaseAxisConstraints","onMeasureDragConstraints","constraintsElement","constraintsBox","root","measuredConstraints","calcViewportConstraints","userConstraints","dragMomentum","dragTransition","onDragTransitionEnd","momentumAnimations","transition","bounceStiffness","bounceDamping","inertia","type","timeConstant","restDelta","restSpeed","startAxisValueAnimation","Promise","all","then","pause","dragKey","toUpperCase","props","externalMotionValue","getValue","initial","scalePositionWithinConstraints","boxProgress","latest","source","origin","sourceLength","targetLength","progress","clamp","calcOrigin","transformTemplate","style","transform","updateScroll","updateLayout","addListeners","element","stopPointerListener","dragListener","measureDragConstraints","stopMeasureLayoutListener","stopResizeListener","window","stopLayoutUpdateListener","hasLayoutChanged","motionValue","translate","DragGesture","Feature","node","super","removeGroupControls","noop","removeListeners","controls","mount","dragControls","subscribe","unmount","FocusGesture","arguments","isActive","onFocus","isFocusVisible","matches","onBlur","handleHoverEvent","lifecycle","whileHover","HoverGesture","startEvent","endEvent","handlers","lastMoveEvent","lastMoveEventInfo","updatePoint","getPanInfo","history","isPanStarted","isDistancePastThreshold","push","handlePointerMove","transformPoint","handlePointerUp","onEnd","panInfo","initialInfo","updateHandlers","subtractPoint","a","b","lastDevicePoint","startDevicePoint","getVelocity","timeDelta","timestampedPoint","lastPoint","currentVelocity","Infinity","asyncHandler","PanGesture","removePointerDownListener","onPointerDown","pointerDownEvent","session","createPanHandlers","onPanSessionStart","onPanStart","onPan","onPanEnd","handlePressEvent","whileTap","PressGesture","success","useGlobalTarget","globalTapTarget"],"sourceRoot":""}