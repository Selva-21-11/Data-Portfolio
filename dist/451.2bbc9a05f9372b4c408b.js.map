{"version":3,"file":"451.2bbc9a05f9372b4c408b.js","mappings":"kIAAA,MAAMA,EACF,WAAAC,CAAYC,GACRC,KAAKC,WAAY,EACjBD,KAAKD,KAAOA,CAChB,CACA,MAAAG,GAAW,E,iBCAf,SAASC,GAAwB,IAAEC,EAAG,KAAEC,EAAI,MAAEC,EAAK,OAAEC,IACjD,MAAO,CACHC,EAAG,CAAEC,IAAKJ,EAAMK,IAAKJ,GACrBK,EAAG,CAAEF,IAAKL,EAAKM,IAAKH,GAE5B,CACA,SAASK,GAAwB,EAAEJ,EAAC,EAAEG,IAClC,MAAO,CAAEP,IAAKO,EAAEF,IAAKH,MAAOE,EAAEE,IAAKH,OAAQI,EAAED,IAAKL,KAAMG,EAAEC,IAC9D,CAMA,SAASI,EAAmBC,EAAOC,GAC/B,IAAKA,EACD,OAAOD,EACX,MAAME,EAAUD,EAAe,CAAEP,EAAGM,EAAMT,KAAMM,EAAGG,EAAMV,MACnDa,EAAcF,EAAe,CAAEP,EAAGM,EAAMR,MAAOK,EAAGG,EAAMP,SAC9D,MAAO,CACHH,IAAKY,EAAQL,EACbN,KAAMW,EAAQR,EACdD,OAAQU,EAAYN,EACpBL,MAAOW,EAAYT,EAE3B,C,kICxBA,SAASU,EAAWJ,EAAOK,EAAOC,GAG9B,OAAOA,EADQD,GADYL,EAAQM,EAGvC,CAIA,SAASC,EAAgBP,EAAOQ,EAAWH,EAAOC,EAAaG,GAI3D,YAHiBC,IAAbD,IACAT,EAAQI,EAAWJ,EAAOS,EAAUH,IAEjCF,EAAWJ,EAAOK,EAAOC,GAAeE,CACnD,CAIA,SAASG,EAAeC,EAAMJ,EAAY,EAAGH,EAAQ,EAAGC,EAAaG,GACjEG,EAAKjB,IAAMY,EAAgBK,EAAKjB,IAAKa,EAAWH,EAAOC,EAAaG,GACpEG,EAAKhB,IAAMW,EAAgBK,EAAKhB,IAAKY,EAAWH,EAAOC,EAAaG,EACxE,CAIA,SAASI,EAAcC,GAAK,EAAEpB,EAAC,EAAEG,IAC7Bc,EAAeG,EAAIpB,EAAGA,EAAEc,UAAWd,EAAEW,MAAOX,EAAEY,aAC9CK,EAAeG,EAAIjB,EAAGA,EAAEW,UAAWX,EAAEQ,MAAOR,EAAES,YAClD,CACA,MAAMS,EAAsB,cACtBC,EAAsB,gBAO5B,SAASC,EAAgBH,EAAKI,EAAWC,EAAUC,GAAqB,GACpE,MAAMC,EAAaF,EAASG,OAC5B,IAAKD,EACD,OAGJ,IAAIpC,EACAsC,EAFJL,EAAUxB,EAAIwB,EAAUrB,EAAI,EAG5B,IAAK,IAAI2B,EAAI,EAAGA,EAAIH,EAAYG,IAAK,CACjCvC,EAAOkC,EAASK,GAChBD,EAAQtC,EAAKwC,gBAKb,MAAM,cAAEC,GAAkBzC,EAAK0C,QAC3BD,GACAA,EAAcE,MAAMC,OACkB,aAAtCH,EAAcE,MAAMC,MAAMC,UAG1BV,GACAnC,EAAK0C,QAAQI,cACb9C,EAAK+C,QACL/C,IAASA,EAAKgD,MACdC,EAAapB,EAAK,CACdpB,GAAIT,EAAK+C,OAAOG,OAAOzC,EACvBG,GAAIZ,EAAK+C,OAAOG,OAAOtC,IAG3B0B,IAEAL,EAAUxB,GAAK6B,EAAM7B,EAAEW,MACvBa,EAAUrB,GAAK0B,EAAM1B,EAAEQ,MAEvBQ,EAAcC,EAAKS,IAEnBH,IAAsB,QAAanC,EAAKmD,eACxCF,EAAapB,EAAK7B,EAAKmD,cAE/B,CAKIlB,EAAUxB,EAAIsB,GACdE,EAAUxB,EAAIqB,IACdG,EAAUxB,EAAI,GAEdwB,EAAUrB,EAAImB,GACdE,EAAUrB,EAAIkB,IACdG,EAAUrB,EAAI,EAEtB,CACA,SAASwC,EAAczB,EAAM0B,GACzB1B,EAAKjB,IAAMiB,EAAKjB,IAAM2C,EACtB1B,EAAKhB,IAAMgB,EAAKhB,IAAM0C,CAC1B,CAMA,SAASC,EAAc3B,EAAM4B,EAAeC,EAAWhC,EAAUiC,EAAa,IAG1E/B,EAAeC,EAAM4B,EAAeC,GAFhB,OAAU7B,EAAKjB,IAAKiB,EAAKhB,IAAK8C,GAEUjC,EAChE,CAIA,SAASyB,EAAapB,EAAK6B,GACvBJ,EAAczB,EAAIpB,EAAGiD,EAAUjD,EAAGiD,EAAUC,OAAQD,EAAUtC,MAAOsC,EAAUE,SAC/EN,EAAczB,EAAIjB,EAAG8C,EAAU9C,EAAG8C,EAAUG,OAAQH,EAAUtC,MAAOsC,EAAUI,QACnF,C,oFClHA,MACMC,EAAY,MACZC,EAAY,OAEZC,GAAgB,IAChBC,EAAgB,IACtB,SAASC,EAAWxC,GAChB,OAAOA,EAAKhB,IAAMgB,EAAKjB,GAC3B,CACA,SAAS0D,EAAOC,EAAOC,EAAQC,GAC3B,OAAOC,KAAKC,IAAIJ,EAAQC,IAAWC,CACvC,CACA,SAASG,EAAcpC,EAAOqC,EAAQL,EAAQM,EAAS,IACnDtC,EAAMsC,OAASA,EACftC,EAAMjB,aAAc,OAAUsD,EAAOjE,IAAKiE,EAAOhE,IAAK2B,EAAMsC,QAC5DtC,EAAMlB,MAAQ+C,EAAWG,GAAUH,EAAWQ,GAC9CrC,EAAMf,WACF,OAAU+C,EAAO5D,IAAK4D,EAAO3D,IAAK2B,EAAMsC,QAAUtC,EAAMjB,aACvDiB,EAAMlB,OAAS2C,GAAazB,EAAMlB,OAAS4C,GAC5Ca,MAAMvC,EAAMlB,UACZkB,EAAMlB,MAAQ,IAEbkB,EAAMf,WAAa0C,GACpB3B,EAAMf,WAAa2C,GACnBW,MAAMvC,EAAMf,cACZe,EAAMf,UAAY,EAE1B,CACA,SAASuD,EAAaxC,EAAOqC,EAAQL,EAAQM,GACzCF,EAAcpC,EAAM7B,EAAGkE,EAAOlE,EAAG6D,EAAO7D,EAAGmE,EAASA,EAAOhB,aAAUnC,GACrEiD,EAAcpC,EAAM1B,EAAG+D,EAAO/D,EAAG0D,EAAO1D,EAAGgE,EAASA,EAAOd,aAAUrC,EACzE,CACA,SAASsD,EAAiBT,EAAQU,EAAUC,GACxCX,EAAO5D,IAAMuE,EAAOvE,IAAMsE,EAAStE,IACnC4D,EAAO3D,IAAM2D,EAAO5D,IAAMyD,EAAWa,EACzC,CACA,SAASE,EAAgBZ,EAAQU,EAAUC,GACvCF,EAAiBT,EAAO7D,EAAGuE,EAASvE,EAAGwE,EAAOxE,GAC9CsE,EAAiBT,EAAO1D,EAAGoE,EAASpE,EAAGqE,EAAOrE,EAClD,CACA,SAASuE,EAAyBb,EAAQc,EAAQH,GAC9CX,EAAO5D,IAAM0E,EAAO1E,IAAMuE,EAAOvE,IACjC4D,EAAO3D,IAAM2D,EAAO5D,IAAMyD,EAAWiB,EACzC,CACA,SAASC,EAAqBf,EAAQc,EAAQH,GAC1CE,EAAyBb,EAAO7D,EAAG2E,EAAO3E,EAAGwE,EAAOxE,GACpD0E,EAAyBb,EAAO1D,EAAGwE,EAAOxE,EAAGqE,EAAOrE,EACxD,C,4CCjDA,MAMM0E,EAAc,KAAM,CACtB7E,EAP0B,CAC1Bc,UAAW,EACXH,MAAO,EACPwD,OAAQ,EACRvD,YAAa,GAIbT,EAR0B,CAC1BW,UAAW,EACXH,MAAO,EACPwD,OAAQ,EACRvD,YAAa,KAOXkE,EAAY,KAAM,CACpB9E,EAFqB,CAAGC,IAAK,EAAGC,IAAK,GAGrCC,EAHqB,CAAGF,IAAK,EAAGC,IAAK,I,iBCVzC,SAAS6E,EAASC,GACd,MAAO,CAACA,EAAS,KAAMA,EAAS,KACpC,C,iCCFA,SAASC,EAAgBtE,GACrB,YAAiBK,IAAVL,GAAiC,IAAVA,CAClC,CACA,SAASuE,GAAS,MAAEvE,EAAK,OAAEuC,EAAM,OAAEE,IAC/B,OAAS6B,EAAgBtE,KACpBsE,EAAgB/B,KAChB+B,EAAgB7B,EACzB,CACA,SAAS+B,EAAaC,GAClB,OAAQF,EAASE,IACbC,EAAeD,IACfA,EAAOE,GACPF,EAAOG,QACPH,EAAOI,SACPJ,EAAOK,SACPL,EAAOM,OACPN,EAAOO,KACf,CACA,SAASN,EAAeD,GACpB,OAAOQ,EAAcR,EAAOpF,IAAM4F,EAAcR,EAAOjF,EAC3D,CACA,SAASyF,EAAchC,GACnB,OAAOA,GAAmB,OAAVA,CACpB,C,qGCpBA,SAASiC,EAAmBC,EAAUvF,GAClC,OAAO,SAAwB,QAAmBuF,EAASC,wBAAyBxF,GACxF,CACA,SAASyF,EAAeC,EAASC,EAAoBC,GACjD,MAAMC,EAAcP,EAAmBI,EAASE,IAC1C,OAAE7D,GAAW4D,EAKnB,OAJI5D,KACA,QAAc8D,EAAYpG,EAAGsC,EAAOG,OAAOzC,IAC3C,QAAcoG,EAAYjG,EAAGmC,EAAOG,OAAOtC,IAExCiG,CACX,C,iBCZA,SAASC,EAA8BC,GACnC,GAAqB,oBAAVC,MACP,OAAOD,EAMX,MAAME,EAAiB,IAAIC,IAO3B,OAAO,IAAIF,OANuB,IAAIG,IAI3BJ,KAAoBI,IAEa,CAMxCC,IAAK,CAACC,EAASC,IACC,WAARA,EACOP,GAINE,EAAeM,IAAID,IACpBL,EAAeO,IAAIF,EAAKP,EAAiBO,IAEtCL,EAAeG,IAAIE,KAGtC,C,0CCnCA,SAASG,EAAeC,EAAMC,GAC1B,IAAKC,MAAMC,QAAQF,GACf,OAAO,EACX,MAAMG,EAAaH,EAAKtF,OACxB,GAAIyF,IAAeJ,EAAKrF,OACpB,OAAO,EACX,IAAK,IAAIE,EAAI,EAAGA,EAAIuF,EAAYvF,IAC5B,GAAIoF,EAAKpF,KAAOmF,EAAKnF,GACjB,OAAO,EAEf,OAAO,CACX,C,4CCRA,MAAMwF,EAAkB,IAAa1F,OACrC,SAAS2F,EAAkBvF,GACvB,IAAKA,EACD,OACJ,IAAKA,EAAcwF,sBAAuB,CACtC,MAAMC,EAAUzF,EAAcwC,QACxB+C,EAAkBvF,EAAcwC,SAChC,CAAC,EAIP,YAHoCxD,IAAhCgB,EAAcE,MAAMwF,UACpBD,EAAQC,QAAU1F,EAAcE,MAAMwF,SAEnCD,CACX,CACA,MAAMA,EAAU,CAAC,EACjB,IAAK,IAAI3F,EAAI,EAAGA,EAAIwF,EAAiBxF,IAAK,CACtC,MAAM6F,EAAO,IAAa7F,GACpB8F,EAAO5F,EAAcE,MAAMyF,KAC7B,OAAeC,KAAkB,IAATA,KACxBH,EAAQE,GAAQC,EAExB,CACA,OAAOH,CACX,CChBA,MAAMI,EAAuB,IAAI,KAAsBC,UACjDC,EAAoB,IAAqBnG,OAI/C,SAASoG,EAAqBhG,GAC1B,IAAIiG,EAJR,SAAqBjG,GACjB,OAAQkG,GAAeC,QAAQC,IAAIF,EAAWG,KAAI,EAAGC,YAAWrG,cAAc,OAAqBD,EAAesG,EAAWrG,KACjI,CAEkBsG,CAAYvG,GACtBwG,EAAQC,IACRC,GAAkB,EAKtB,MAAMC,EAA2BC,GAAS,CAACC,EAAKC,KAC5C,IAAIC,EACJ,MAAMC,GAAW,OAAehH,EAAe8G,EAAqB,SAATF,EACZ,QAAxCG,EAAK/G,EAAciH,uBAAoC,IAAPF,OAAgB,EAASA,EAAGG,YAC7ElI,GACN,GAAIgI,EAAU,CACV,MAAM,WAAEG,EAAU,cAAEC,KAAkBvF,GAAWmF,EACjDH,EAAM,IAAKA,KAAQhF,KAAWuF,EAClC,CACA,OAAOP,CAAG,EAmBd,SAASQ,EAAeC,GACpB,MAAM,MAAEpH,GAAUF,EACZyF,EAAUF,EAAkBvF,EAAcwC,SAAW,CAAC,EAKtD0D,EAAa,GAKbqB,EAAc,IAAIC,IAMxB,IAAIC,EAAkB,CAAC,EAKnBC,EAAsBC,IAO1B,IAAK,IAAI7H,EAAI,EAAGA,EAAIiG,EAAmBjG,IAAK,CACxC,MAAM8G,EAAOf,EAAqB/F,GAC5B8H,EAAYpB,EAAMI,GAClBhB,OAAuB5G,IAAhBkB,EAAM0G,GACb1G,EAAM0G,GACNnB,EAAQmB,GACRiB,GAAgB,OAAejC,GAK/BkC,EAAclB,IAASU,EAAoBM,EAAUG,SAAW,MAClD,IAAhBD,IACAJ,EAAsB5H,GAO1B,IAAIkI,EAAcpC,IAASH,EAAQmB,IAC/BhB,IAAS1F,EAAM0G,IACfiB,EAeJ,GAXIG,GACAtB,GACA1G,EAAciI,yBACdD,GAAc,GAMlBJ,EAAUM,cAAgB,IAAKT,IAI7BG,EAAUG,UAA4B,OAAhBD,IAElBlC,IAASgC,EAAUO,WAErB,OAAoBvC,IACJ,kBAATA,EACP,SAOJ,MAAMwC,EAAmBC,EAAuBT,EAAUO,SAAUvC,GACpE,IAAI0C,EAAoBF,GAEnBxB,IAASU,GACNM,EAAUG,WACTC,GACDH,GAEH/H,EAAI4H,GAAuBG,EAC5BU,GAAuB,EAK3B,MAAMC,EAAiBrD,MAAMC,QAAQQ,GAAQA,EAAO,CAACA,GAKrD,IAAI6C,EAAiBD,EAAeE,OAAO/B,EAAwBC,GAAO,CAAC,IACvD,IAAhBkB,IACAW,EAAiB,CAAC,GAUtB,MAAM,mBAAEE,EAAqB,CAAC,GAAMf,EAC9BgB,EAAU,IACTD,KACAF,GAEDI,EAAiBhE,IACnByD,GAAoB,EAChBf,EAAYzC,IAAID,KAChB0D,GAAuB,EACvBhB,EAAYuB,OAAOjE,IAEvB+C,EAAUmB,eAAelE,IAAO,EAChC,MAAMmE,EAAchJ,EAAciJ,SAASpE,GACvCmE,IACAA,EAAYE,WAAY,EAAK,EAErC,IAAK,MAAMrE,KAAO+D,EAAS,CACvB,MAAM3D,EAAOwD,EAAe5D,GACtBK,EAAOyD,EAAmB9D,GAEhC,GAAI4C,EAAgB0B,eAAetE,GAC/B,SAIJ,IAAIuE,GAAkB,EAElBA,GADA,OAAkBnE,KAAS,OAAkBC,IAC1BF,EAAeC,EAAMC,GAGtBD,IAASC,EAE3BkE,EACInE,QAEA4D,EAAchE,GAId0C,EAAY8B,IAAIxE,QAGN7F,IAATiG,GAAsBsC,EAAYzC,IAAID,GAK3CgE,EAAchE,GAOd+C,EAAUM,cAAcrD,IAAO,CAEvC,CAKA+C,EAAUO,SAAWvC,EACrBgC,EAAUe,mBAAqBF,EAI3Bb,EAAUG,WACVN,EAAkB,IAAKA,KAAoBgB,IAE3C/B,GAAmB1G,EAAcsJ,wBACjChB,GAAoB,GAQpBA,MAFyBN,GAAeI,IACIG,IAE5CrC,EAAWqD,QAAQf,EAAenC,KAAKC,IAAc,CACjDA,UAAWA,EACXrG,QAAS,CAAE2G,YAGvB,CAMA,GAAIW,EAAYiC,KAAM,CAClB,MAAMC,EAAoB,CAAC,EAC3BlC,EAAYmC,SAAS7E,IACjB,MAAM8E,EAAiB3J,EAAc4J,cAAc/E,GAC7CmE,EAAchJ,EAAciJ,SAASpE,GACvCmE,IACAA,EAAYE,WAAY,GAE5BO,EAAkB5E,GAAO8E,QAAuDA,EAAiB,IAAI,IAEzGzD,EAAWqD,KAAK,CAAEjD,UAAWmD,GACjC,CACA,IAAII,EAAgBC,QAAQ5D,EAAWtG,QAOvC,OANI8G,IACmB,IAAlBxG,EAAMwF,SAAqBxF,EAAMwF,UAAYxF,EAAM+F,SACnDjG,EAAciI,yBACf4B,GAAgB,GAEpBnD,GAAkB,EACXmD,EAAgB5D,EAAQC,GAAcC,QAAQ4D,SACzD,CAkBA,MAAO,CACH1C,iBACA2C,UAhBJ,SAAmBpD,EAAMmB,GACrB,IAAIhB,EAEJ,GAAIP,EAAMI,GAAMmB,WAAaA,EACzB,OAAO5B,QAAQ4D,UAEsB,QAAxChD,EAAK/G,EAAciK,uBAAoC,IAAPlD,GAAyBA,EAAG2C,SAASQ,IAAY,IAAInD,EAAI,OAAuC,QAA/BA,EAAKmD,EAAMC,sBAAmC,IAAPpD,OAAgB,EAASA,EAAGiD,UAAUpD,EAAMmB,EAAS,IAC9MvB,EAAMI,GAAMmB,SAAWA,EACvB,MAAM7B,EAAamB,EAAeT,GAClC,IAAK,MAAM/B,KAAO2B,EACdA,EAAM3B,GAAKqD,cAAgB,CAAC,EAEhC,OAAOhC,CACX,EAIIkE,mBAjQJ,SAA4BC,GACxBpE,EAAUoE,EAAarK,EAC3B,EAgQIsK,SAAU,IAAM9D,EAChB+D,MAAO,KACH/D,EAAQC,IACRC,GAAkB,CAAI,EAGlC,CACA,SAAS2B,EAAuBnD,EAAMD,GAClC,MAAoB,iBAATA,EACAA,IAASC,IAEXC,MAAMC,QAAQH,KACXD,EAAeC,EAAMC,EAGrC,CACA,SAASsF,EAAgBzC,GAAW,GAChC,MAAO,CACHA,WACAG,cAAe,CAAC,EAChBa,eAAgB,CAAC,EACjBJ,mBAAoB,CAAC,EAE7B,CACA,SAASlC,IACL,MAAO,CACHR,QAASuE,GAAgB,GACzBC,YAAaD,IACbE,WAAYF,IACZG,SAAUH,IACVI,UAAWJ,IACXK,WAAYL,IACZM,KAAMN,IAEd,C,cCrUA,MAAMO,UAAyB1N,EAAA,EAM3B,WAAAC,CAAYC,GACRyN,MAAMzN,GACNA,EAAK4M,iBAAmB5M,EAAK4M,eAAiBnE,EAAqBzI,GACvE,CACA,mCAAA0N,GACI,MAAM,QAAEhF,GAAYzI,KAAKD,KAAK2N,YAC1B,OAAoBjF,KACpBzI,KAAK2N,gBAAkBlF,EAAQmF,UAAU5N,KAAKD,MAEtD,CAIA,KAAA8N,GACI7N,KAAKyN,qCACT,CACA,MAAAvN,GACI,MAAM,QAAEuI,GAAYzI,KAAKD,KAAK2N,YACtBjF,QAASqF,GAAgB9N,KAAKD,KAAKgO,WAAa,CAAC,EACrDtF,IAAYqF,GACZ9N,KAAKyN,qCAEb,CACA,OAAAO,GACI,IAAIzE,EACJvJ,KAAKD,KAAK4M,eAAeI,QACO,QAA/BxD,EAAKvJ,KAAK2N,uBAAoC,IAAPpE,GAAyBA,EAAG0E,KAAKjO,KAC7E,ECnCJ,IAAIkO,EAAK,EACT,MAAMC,UAA6BtO,EAAA,EAC/B,WAAAC,GACI0N,SAASY,WACTpO,KAAKkO,GAAKA,GACd,CACA,MAAAhO,GACI,IAAKF,KAAKD,KAAK0J,gBACX,OACJ,MAAM,UAAE4E,EAAS,eAAEC,GAAmBtO,KAAKD,KAAK0J,iBACxC4E,UAAWE,GAAkBvO,KAAKD,KAAKyO,qBAAuB,CAAC,EACvE,IAAKxO,KAAKD,KAAK4M,gBAAkB0B,IAAcE,EAC3C,OAEJ,MAAME,EAAgBzO,KAAKD,KAAK4M,eAAeH,UAAU,QAAS6B,GAC9DC,IAAmBD,GACnBI,EAAcC,MAAK,IAAMJ,EAAetO,KAAKkO,KAErD,CACA,KAAAL,GACI,MAAM,SAAEc,GAAa3O,KAAKD,KAAK0J,iBAAmB,CAAC,EAC/CkF,IACA3O,KAAKgO,QAAUW,EAAS3O,KAAKkO,IAErC,CACA,OAAAF,GAAY,ECxBhB,MAAMtF,EAAa,CACfI,UAAW,CACPjJ,QAAS0N,GAEbD,KAAM,CACFzN,QAASsO,I,0ECHjB,MAAMS,EAAwB,CAK1BC,wBAAwB,EAKxBC,gBAAgB,G,cCbpB,SAASC,EAAgBC,EAAQtN,GAC7B,OAAIA,EAAKhB,MAAQgB,EAAKjB,IACX,EACHuO,GAAUtN,EAAKhB,IAAMgB,EAAKjB,KAAQ,GAC9C,CAQA,MAAMwO,EAAsB,CACxBC,QAAS,CAACC,EAAQpP,KACd,IAAKA,EAAKsE,OACN,OAAO8K,EAKX,GAAsB,iBAAXA,EAAqB,CAC5B,IAAI,EAAAC,GAAGC,KAAKF,GAIR,OAAOA,EAHPA,EAASG,WAAWH,EAK5B,CAOA,MAAO,GAFGJ,EAAgBI,EAAQpP,EAAKsE,OAAO7D,OACpCuO,EAAgBI,EAAQpP,EAAKsE,OAAO1D,KAC1B,G,wBCjC5B,MAAM4O,EAAmB,CACrBL,QAAS,CAACC,GAAUnN,YAAWO,sBAC3B,MAAMiN,EAAWL,EACXM,EAASC,EAAA,EAAQC,MAAMR,GAE7B,GAAIM,EAAOrN,OAAS,EAChB,OAAOoN,EACX,MAAMI,EAAWF,EAAA,EAAQG,kBAAkBV,GACrClM,EAA8B,iBAAdwM,EAAO,GAAkB,EAAI,EAE7CK,EAASvN,EAAgB/B,EAAEW,MAAQa,EAAUxB,EAC7CuP,EAASxN,EAAgB5B,EAAEQ,MAAQa,EAAUrB,EACnD8O,EAAO,EAAIxM,IAAW6M,EACtBL,EAAO,EAAIxM,IAAW8M,EAOtB,MAAMC,GAAe,OAAUF,EAAQC,EAAQ,IAO/C,MALkC,iBAAvBN,EAAO,EAAIxM,KAClBwM,EAAO,EAAIxM,IAAW+M,GAEQ,iBAAvBP,EAAO,EAAIxM,KAClBwM,EAAO,EAAIxM,IAAW+M,GACnBJ,EAASH,EAAO,GC9BzBQ,EAAkB,CAAC,E,uBCazB,MAAMC,UAAiC,EAAAC,UAMnC,iBAAAC,GACI,MAAM,cAAE5N,EAAa,YAAE6N,EAAW,kBAAEC,EAAiB,SAAEC,GAAavQ,KAAK0C,OACnE,WAAE8N,GAAehO,EDpB/B,IAA2BiO,ICqBDC,EDpBtBC,OAAOC,OAAOX,EAAiBQ,GCqBvBD,IACIH,EAAYQ,OACZR,EAAYQ,MAAMhF,IAAI2E,GACtBF,GAAqBA,EAAkB3B,UAAY4B,GACnDD,EAAkB3B,SAAS6B,GAE/BA,EAAWzN,KAAK+N,YAChBN,EAAWO,iBAAiB,qBAAqB,KAC7C/Q,KAAKgR,cAAc,IAEvBR,EAAWS,WAAW,IACfT,EAAW/N,QACd6L,eAAgB,IAAMtO,KAAKgR,kBAGnCpC,EAAsBE,gBAAiB,CAC3C,CACA,uBAAAoC,CAAwBnD,GACpB,MAAM,iBAAEoD,EAAgB,cAAE3O,EAAa,KAAE4O,EAAI,UAAE/C,GAAcrO,KAAK0C,MAC5D8N,EAAahO,EAAcgO,WACjC,OAAKA,GASLA,EAAWnC,UAAYA,EACnB+C,GACArD,EAAUoD,mBAAqBA,QACV3P,IAArB2P,EACAX,EAAWa,aAGXrR,KAAKgR,eAELjD,EAAUM,YAAcA,IACpBA,EACAmC,EAAWc,UAELd,EAAWe,YAMjB,KAAMC,YAAW,KACb,MAAMC,EAAQjB,EAAWkB,WACpBD,GAAUA,EAAME,QAAQvP,QACzBpC,KAAKgR,cACT,KAIL,MAnCI,IAoCf,CACA,kBAAAY,GACI,MAAM,WAAEpB,GAAexQ,KAAK0C,MAAMF,cAC9BgO,IACAA,EAAWzN,KAAK+N,YAChBe,EAAA,EAAUL,YAAW,MACZhB,EAAWsB,kBAAoBtB,EAAWuB,UAC3C/R,KAAKgR,cACT,IAGZ,CACA,oBAAAgB,GACI,MAAM,cAAExP,EAAa,YAAE6N,EAAaC,kBAAmB2B,GAAoBjS,KAAK0C,OAC1E,WAAE8N,GAAehO,EACnBgO,IACAA,EAAW0B,4BACP7B,GAAeA,EAAYQ,OAC3BR,EAAYQ,MAAMsB,OAAO3B,GACzByB,GAAkBA,EAAeG,YACjCH,EAAeG,WAAW5B,GAEtC,CACA,YAAAQ,GACI,MAAM,aAAEA,GAAiBhR,KAAK0C,MAC9BsO,GAAgBA,GACpB,CACA,MAAAqB,GACI,OAAO,IACX,EAEJ,SAASC,EAAc5P,GACnB,MAAO2L,EAAW2C,IAAgB,UAC5BX,GAAc,IAAAkC,YAAWC,EAAAC,GAC/B,OAAQ,IAAAC,KAAIxC,EAA0B,IAAKxN,EAAO2N,YAAaA,EAAaC,mBAAmB,IAAAiC,YAAWI,EAAA,GAA2BtE,UAAWA,EAAW2C,aAAcA,GAC7K,CACA,MAAMN,EAAyB,CAC3BkC,aAAc,IACP3D,EACH4D,QAAS,CACL,sBACA,uBACA,yBACA,4BAGRC,oBAAqB7D,EACrB8D,qBAAsB9D,EACtB+D,uBAAwB/D,EACxBgE,wBAAyBhE,EACzBiE,UAAW3D,G,oEClIf,MAAM4D,EAAiB,CAACC,EAAGC,IAAMD,EAAEE,MAAQD,EAAEC,MCG7C,MAAMC,EACF,WAAAzT,GACIE,KAAKwT,SAAW,GAChBxT,KAAKyT,SAAU,CACnB,CACA,GAAA5H,CAAIa,IACA,QAAc1M,KAAKwT,SAAU9G,GAC7B1M,KAAKyT,SAAU,CACnB,CACA,MAAAtB,CAAOzF,IACH,QAAW1M,KAAKwT,SAAU9G,GAC1B1M,KAAKyT,SAAU,CACnB,CACA,OAAAvH,CAAQ1G,GACJxF,KAAKyT,SAAWzT,KAAKwT,SAASE,KAAKP,GACnCnT,KAAKyT,SAAU,EACfzT,KAAKwT,SAAStH,QAAQ1G,EAC1B,E,cCbJ,SAASmO,EAAMnO,EAAUoO,GACrB,MAAMC,EAAQ,IAAKC,MACbC,EAAe,EAAGC,gBACpB,MAAMC,EAAUD,EAAYH,EACxBI,GAAWL,KACX,QAAYG,GACZvO,EAASyO,EAAUL,GACvB,EAGJ,OADA,KAAMM,KAAKH,GAAc,GAClB,KAAM,QAAYA,EAC7B,C,gDCbA,MAAMI,GAAU,CAAC,UAAW,WAAY,aAAc,eAChDC,GAAaD,GAAQ/R,OACrBiS,GAAYjQ,GAA2B,iBAAVA,EAAqBkL,WAAWlL,GAASA,EACtEkQ,GAAQlQ,GAA2B,iBAAVA,GAAsB,EAAAgL,GAAGC,KAAKjL,GA0C7D,SAASmQ,GAAU3O,EAAQ4O,GACvB,YAA8BhT,IAAvBoE,EAAO4O,GACR5O,EAAO4O,GACP5O,EAAOgN,YACjB,CAwBA,MAAM6B,GAAgCC,GAAS,EAAG,GAAKC,GAAA,IACjDC,GAAiCF,GAAS,GAAK,IAAMG,EAAA,GAC3D,SAASH,GAASjU,EAAKC,EAAKoU,GACxB,OAAQC,GAEAA,EAAItU,EACG,EACPsU,EAAIrU,EACG,EACJoU,GAAO,EAAAE,GAAA,GAASvU,EAAKC,EAAKqU,GAEzC,CCpFA,SAASE,GAAavT,EAAMwT,GACxBxT,EAAKjB,IAAMyU,EAAWzU,IACtBiB,EAAKhB,IAAMwU,EAAWxU,GAC1B,CAMA,SAASyU,GAAYvT,EAAKwT,GACtBH,GAAarT,EAAIpB,EAAG4U,EAAU5U,GAC9ByU,GAAarT,EAAIjB,EAAGyU,EAAUzU,EAClC,CAMA,SAAS0U,GAAkBhT,EAAOiT,GAC9BjT,EAAMf,UAAYgU,EAAYhU,UAC9Be,EAAMlB,MAAQmU,EAAYnU,MAC1BkB,EAAMjB,YAAckU,EAAYlU,YAChCiB,EAAMsC,OAAS2Q,EAAY3Q,MAC/B,C,0BCrBA,SAAS4Q,GAAiBzU,EAAOQ,EAAWH,EAAOC,EAAaG,GAM5D,OALAT,GAASQ,EACTR,GAAQ,SAAWA,EAAO,EAAIK,EAAOC,QACpBI,IAAbD,IACAT,GAAQ,SAAWA,EAAO,EAAIS,EAAUH,IAErCN,CACX,CAsBA,SAAS0U,GAAqB9T,EAAM+T,GAAapO,EAAKqO,EAAUC,GAAYhR,EAAQiR,IAlBpF,SAAyBlU,EAAMJ,EAAY,EAAGH,EAAQ,EAAGwD,EAAS,GAAKpD,EAAU2T,EAAaxT,EAAMkU,EAAalU,GACzG,KAAQ2N,KAAK/N,KACbA,EAAYgO,WAAWhO,GAEvBA,GADyB,OAAUsU,EAAWnV,IAAKmV,EAAWlV,IAAKY,EAAY,KAChDsU,EAAWnV,KAE9C,GAAyB,iBAAda,EACP,OACJ,IAAIF,GAAc,OAAU8T,EAAWzU,IAAKyU,EAAWxU,IAAKiE,GACxDjD,IAASwT,IACT9T,GAAeE,GACnBI,EAAKjB,IAAM8U,GAAiB7T,EAAKjB,IAAKa,EAAWH,EAAOC,EAAaG,GACrEG,EAAKhB,IAAM6U,GAAiB7T,EAAKhB,IAAKY,EAAWH,EAAOC,EAAaG,EACzE,CAMIsU,CAAgBnU,EAAM+T,EAAWpO,GAAMoO,EAAWC,GAAWD,EAAWE,GAAYF,EAAWtU,MAAOwD,EAAQiR,EAClH,CAIA,MAAME,GAAQ,CAAC,IAAK,SAAU,WACxBC,GAAQ,CAAC,IAAK,SAAU,WAK9B,SAASC,GAAoBpU,EAAK6T,EAAYL,EAAWa,GACrDT,GAAqB5T,EAAIpB,EAAGiV,EAAYK,GAAOV,EAAYA,EAAU5U,OAAIgB,EAAWyU,EAAYA,EAAUzV,OAAIgB,GAC9GgU,GAAqB5T,EAAIjB,EAAG8U,EAAYM,GAAOX,EAAYA,EAAUzU,OAAIa,EAAWyU,EAAYA,EAAUtV,OAAIa,EAClH,C,eCjDA,SAAS0U,GAAgB7T,GACrB,OAA2B,IAApBA,EAAMf,WAAmC,IAAhBe,EAAMlB,KAC1C,CACA,SAASgV,GAAY9T,GACjB,OAAO6T,GAAgB7T,EAAM7B,IAAM0V,GAAgB7T,EAAM1B,EAC7D,CACA,SAASyV,GAAWhD,EAAGC,GACnB,OAAOD,EAAE3S,MAAQ4S,EAAE5S,KAAO2S,EAAE1S,MAAQ2S,EAAE3S,GAC1C,CAIA,SAAS2V,GAAkBjD,EAAGC,GAC1B,OAAQ9O,KAAK+R,MAAMlD,EAAE3S,OAAS8D,KAAK+R,MAAMjD,EAAE5S,MACvC8D,KAAK+R,MAAMlD,EAAE1S,OAAS6D,KAAK+R,MAAMjD,EAAE3S,IAC3C,CACA,SAAS6V,GAAiBnD,EAAGC,GACzB,OAAOgD,GAAkBjD,EAAE5S,EAAG6S,EAAE7S,IAAM6V,GAAkBjD,EAAEzS,EAAG0S,EAAE1S,EACnE,CACA,SAAS6V,GAAY5U,GACjB,OAAO,SAAWA,EAAIpB,IAAK,SAAWoB,EAAIjB,EAC9C,CACA,SAAS8V,GAAgBrD,EAAGC,GACxB,OAAQD,EAAE9R,YAAc+R,EAAE/R,WACtB8R,EAAEjS,QAAUkS,EAAElS,OACdiS,EAAEhS,cAAgBiS,EAAEjS,WAC5B,CC1BA,MAAMsV,GACF,WAAA5W,GACIE,KAAK2R,QAAU,EACnB,CACA,GAAA9F,CAAI9L,IACA,QAAcC,KAAK2R,QAAS5R,GAC5BA,EAAK4W,gBACT,CACA,MAAAxE,CAAOpS,GAKH,IAJA,QAAWC,KAAK2R,QAAS5R,GACrBA,IAASC,KAAK4W,WACd5W,KAAK4W,cAAWpV,GAEhBzB,IAASC,KAAK6W,KAAM,CACpB,MAAMD,EAAW5W,KAAK2R,QAAQ3R,KAAK2R,QAAQvP,OAAS,GAChDwU,GACA5W,KAAKsR,QAAQsF,EAErB,CACJ,CACA,QAAArF,CAASxR,GACL,MAAM+W,EAAc9W,KAAK2R,QAAQoF,WAAWC,GAAWjX,IAASiX,IAChE,GAAoB,IAAhBF,EACA,OAAO,EAIX,IAAIF,EACJ,IAAK,IAAItU,EAAIwU,EAAaxU,GAAK,EAAGA,IAAK,CACnC,MAAM0U,EAAShX,KAAK2R,QAAQrP,GAC5B,IAAyB,IAArB0U,EAAO3I,UAAqB,CAC5BuI,EAAWI,EACX,KACJ,CACJ,CACA,QAAIJ,IACA5W,KAAKsR,QAAQsF,IACN,EAKf,CACA,OAAAtF,CAAQvR,EAAMkX,GACV,MAAML,EAAW5W,KAAK6W,KACtB,GAAI9W,IAAS6W,IAEb5W,KAAK4W,SAAWA,EAChB5W,KAAK6W,KAAO9W,EACZA,EAAKmX,OACDN,GAAU,CACVA,EAAStQ,UAAYsQ,EAASD,iBAC9B5W,EAAK4W,iBACL5W,EAAKoX,WAAaP,EACdK,IACAlX,EAAKoX,WAAWC,iBAAkB,GAElCR,EAASS,WACTtX,EAAKsX,SAAWT,EAASS,SACzBtX,EAAKsX,SAASnU,aACV0T,EAASU,iBAAmBV,EAAS1T,cAEzCnD,EAAKgD,MAAQhD,EAAKgD,KAAKwU,aACvBxX,EAAKyX,eAAgB,GAEzB,MAAM,UAAEC,GAAc1X,EAAK0C,SACT,IAAdgV,GACAb,EAASc,MAcjB,CACJ,CACA,qBAAAC,GACI3X,KAAK2R,QAAQzF,SAASnM,IAClB,MAAM,QAAE0C,EAAO,aAAEmV,GAAiB7X,EAClC0C,EAAQ6L,gBAAkB7L,EAAQ6L,iBAC9BsJ,GACAA,EAAanV,QAAQ6L,gBACjBsJ,EAAanV,QAAQ6L,gBAC7B,GAER,CACA,cAAAqI,GACI3W,KAAK2R,QAAQzF,SAASnM,IAClBA,EAAKuG,UAAYvG,EAAK4W,gBAAe,EAAM,GAEnD,CAKA,kBAAAkB,GACQ7X,KAAK6W,MAAQ7W,KAAK6W,KAAKQ,WACvBrX,KAAK6W,KAAKQ,cAAW7V,EAE7B,E,0BChFJ,MAAMsW,GAAU,CACZ1O,KAAM,kBACN2O,WAAY,EACZC,qBAAsB,EACtBC,uBAAwB,GAEtBC,GAA4B,oBAAXC,aAAiD3W,IAAvB2W,OAAOC,YAClDC,GAAgB,CAAC,GAAI,IAAK,IAAK,KAC/BC,GAAmB,CAAEC,WAAY,UAMvC,IAAI,GAAK,EACT,SAASC,GAAyBnR,EAAK7E,EAAeoD,EAAQ6S,GAC1D,MAAM,aAAEvV,GAAiBV,EAErBU,EAAamE,KACbzB,EAAOyB,GAAOnE,EAAamE,GAC3B7E,EAAckW,eAAerR,EAAK,GAC9BoR,IACAA,EAAsBpR,GAAO,GAGzC,CACA,SAASsR,GAAuCC,GAE5C,GADAA,EAAeC,2BAA4B,EACvCD,EAAe7V,OAAS6V,EACxB,OACJ,MAAM,cAAEpW,GAAkBoW,EAAenW,QACzC,IAAKD,EACD,OACJ,MAAMsW,GAAW,OAAqBtW,GACtC,GAAI2V,OAAOY,4BAA4BD,EAAU,aAAc,CAC3D,MAAM,OAAE3T,EAAM,SAAEoL,GAAaqI,EAAenW,QAC5C0V,OAAOa,+BAA+BF,EAAU,YAAa,OAAS3T,GAAUoL,GACpF,CACA,MAAM,OAAEvL,GAAW4T,EACf5T,IAAWA,EAAO6T,2BAClBF,GAAuC3T,EAE/C,CACA,SAASiU,IAAqB,qBAAEC,EAAoB,cAAEC,EAAa,cAAEC,EAAa,kBAAEC,EAAiB,eAAEC,IACnG,OAAO,MACH,WAAAxZ,CAAYoD,EAAe,CAAC,EAAG8B,GAASmU,aAAqD,EAASA,MAIlGnZ,KAAKkO,GAAK,KAIVlO,KAAKuZ,YAAc,EAOnBvZ,KAAKwT,SAAW,IAAIxJ,IAKpBhK,KAAKyC,QAAU,CAAC,EAMhBzC,KAAKwZ,iBAAkB,EACvBxZ,KAAKyZ,oBAAqB,EAO1BzZ,KAAKwX,eAAgB,EAKrBxX,KAAK0Z,mBAAoB,EAKzB1Z,KAAK2Z,yBAA0B,EAK/B3Z,KAAK4Z,kBAAmB,EAIxB5Z,KAAK6Z,uBAAwB,EAC7B7Z,KAAK8Z,uBAAwB,EAK7B9Z,KAAKuX,YAAa,EAIlBvX,KAAK+Z,OAAQ,EAKb/Z,KAAKga,YAAa,EAIlBha,KAAKia,sBAAuB,EAO5Bja,KAAK6Y,2BAA4B,EASjC7Y,KAAKgC,UAAY,CAAExB,EAAG,EAAGG,EAAG,GAI5BX,KAAKka,cAAgB,IAAIjT,IACzBjH,KAAKma,iBAAkB,EAEvBna,KAAKoa,iBAAkB,EACvBpa,KAAKqa,eAAiB,IAAMra,KAAKE,SACjCF,KAAKsa,2BAA4B,EACjCta,KAAKua,kBAAoB,KACjBva,KAAKuX,aACLvX,KAAKuX,YAAa,EAClBvX,KAAKwa,oBACT,EAOJxa,KAAKya,iBAAmB,KACpBza,KAAKsa,2BAA4B,EAK7BpC,KACAJ,GAAQC,WACJD,GAAQE,qBACJF,GAAQG,uBACJ,GAEhBjY,KAAK0a,MAAMxO,QAAQyO,IACnB3a,KAAK0a,MAAMxO,QAAQ0O,IACnB5a,KAAK0a,MAAMxO,QAAQ2O,IACnB7a,KAAK0a,MAAMxO,QAAQ4O,IACf5C,IACAC,OAAOC,YAAY2C,OAAOjD,GAC9B,EAKJ9X,KAAKgb,yBAA2B,EAChChb,KAAKib,cAAe,EACpBjb,KAAKkb,WAAY,EACjBlb,KAAKmb,kBAAoB,EAKzBnb,KAAKob,YAAc,IAAInU,IACvBjH,KAAKkD,aAAeA,EACpBlD,KAAK+C,KAAOiC,EAASA,EAAOjC,MAAQiC,EAAShF,KAC7CA,KAAKqb,KAAOrW,EAAS,IAAIA,EAAOqW,KAAMrW,GAAU,GAChDhF,KAAKgF,OAASA,EACdhF,KAAKsT,MAAQtO,EAASA,EAAOsO,MAAQ,EAAI,EACzC,IAAK,IAAIhR,EAAI,EAAGA,EAAItC,KAAKqb,KAAKjZ,OAAQE,IAClCtC,KAAKqb,KAAK/Y,GAAG2X,sBAAuB,EAEpCja,KAAK+C,OAAS/C,OACdA,KAAK0a,MAAQ,IAAInH,EACzB,CACA,gBAAAxC,CAAiB5I,EAAMmT,GAInB,OAHKtb,KAAKka,cAAc5S,IAAIa,IACxBnI,KAAKka,cAAc3S,IAAIY,EAAM,IAAI,MAE9BnI,KAAKka,cAAc/S,IAAIgB,GAAM0D,IAAIyP,EAC5C,CACA,eAAAC,CAAgBpT,KAASjB,GACrB,MAAMsU,EAAsBxb,KAAKka,cAAc/S,IAAIgB,GACnDqT,GAAuBA,EAAoBC,UAAUvU,EACzD,CACA,YAAAwU,CAAavT,GACT,OAAOnI,KAAKka,cAAc5S,IAAIa,EAClC,CAIA,KAAA0F,CAAMvH,EAAUkR,EAAgBxX,KAAK+C,KAAKoX,iBACtC,GAAIna,KAAKsG,SACL,OCnPhB,IAAsBG,EDoPVzG,KAAK+Z,OCpPKtT,EDoPgBH,aCnPRqV,YAAkC,QAApBlV,EAAQmV,QDoPxC5b,KAAKsG,SAAWA,EAChB,MAAM,SAAEiK,EAAQ,OAAEpL,EAAM,cAAE3C,GAAkBxC,KAAKyC,QASjD,GARID,IAAkBA,EAAcqZ,SAChCrZ,EAAcqL,MAAMvH,GAExBtG,KAAK+C,KAAK2X,MAAM7O,IAAI7L,MACpBA,KAAKgF,QAAUhF,KAAKgF,OAAOwO,SAAS3H,IAAI7L,MACpCwX,IAAkBrS,GAAUoL,KAC5BvQ,KAAKwX,eAAgB,GAErB0B,EAAsB,CACtB,IAAI4C,EACJ,MAAMC,EAAsB,IAAO/b,KAAK+C,KAAK+W,uBAAwB,EACrEZ,EAAqB5S,GAAU,KAC3BtG,KAAK+C,KAAK+W,uBAAwB,EAClCgC,GAAeA,IACfA,EAAcnI,EAAMoI,EAAqB,KACrCnN,EAAsBC,yBACtBD,EAAsBC,wBAAyB,EAC/C7O,KAAK0a,MAAMxO,QAAQ8P,IACvB,GAER,CACIzL,GACAvQ,KAAK+C,KAAKkZ,mBAAmB1L,EAAUvQ,OAGd,IAAzBA,KAAKyC,QAAQgG,SACbjG,IACC+N,GAAYpL,IACbnF,KAAK+Q,iBAAiB,aAAa,EAAG1O,QAAO6Z,mBAAkBC,2BAA0BhX,OAAQiX,MAC7F,GAAIpc,KAAKqc,yBAGL,OAFArc,KAAKqE,YAAS7C,OACdxB,KAAKsc,oBAAiB9a,GAI1B,MAAM+a,EAAmBvc,KAAKyC,QAAQkH,YAClCnH,EAAcga,wBACdC,IACE,uBAAEC,EAAsB,0BAAEC,GAA+Bna,EAAckL,WAKvEkP,GAAiB5c,KAAK6c,eACvBtG,GAAiBvW,KAAK6c,aAAcT,IACrCD,EAMEW,GAAgCZ,GAAoBC,EAC1D,GAAInc,KAAKyC,QAAQsa,YACZ/c,KAAKmX,YAAcnX,KAAKmX,WAAW7Q,UACpCwW,GACCZ,IACIU,IAAkB5c,KAAK8R,kBAAoB,CAC5C9R,KAAKmX,aACLnX,KAAK4X,aAAe5X,KAAKmX,WACzBnX,KAAK4X,aAAaA,kBAAepW,GAErCxB,KAAKgd,mBAAmB3a,EAAOya,GAC/B,MAAMG,EAAmB,KAClB,QAAmBV,EAAkB,UACxCW,OAAQR,EACRS,WAAYR,IAEZna,EAAc4a,oBACdpd,KAAKyC,QAAQsa,cACbE,EAAiBtJ,MAAQ,EACzBsJ,EAAiB7T,MAAO,GAE5BpJ,KAAKqd,eAAeJ,EACxB,MAOSf,GACDF,GAAgBhc,MAEhBA,KAAK+R,UAAY/R,KAAKyC,QAAQ6L,gBAC9BtO,KAAKyC,QAAQ6L,iBAGrBtO,KAAK6c,aAAeT,CAAS,GAGzC,CACA,OAAApO,GACIhO,KAAKyC,QAAQ8N,UAAYvQ,KAAKqR,aAC9BrR,KAAK+C,KAAK2X,MAAMvI,OAAOnS,MACvB,MAAMyR,EAAQzR,KAAK0R,WACnBD,GAASA,EAAMU,OAAOnS,MACtBA,KAAKgF,QAAUhF,KAAKgF,OAAOwO,SAASlI,OAAOtL,MAC3CA,KAAKsG,cAAW9E,GAChB,QAAYxB,KAAKya,iBACrB,CAEA,WAAA6C,GACItd,KAAK6Z,uBAAwB,CACjC,CACA,aAAA0D,GACIvd,KAAK6Z,uBAAwB,CACjC,CACA,eAAA2D,GACI,OAAOxd,KAAK6Z,uBAAyB7Z,KAAK8Z,qBAC9C,CACA,sBAAAuC,GACI,OAAQrc,KAAKyZ,oBACRzZ,KAAKgF,QAAUhF,KAAKgF,OAAOqX,2BAC5B,CACR,CAEA,WAAAoB,GACQzd,KAAKwd,oBAETxd,KAAKuX,YAAa,EAClBvX,KAAK0a,OAAS1a,KAAK0a,MAAMxO,QAAQwR,IACjC1d,KAAKuZ,cACT,CACA,oBAAAoE,GACI,MAAM,cAAEnb,GAAkBxC,KAAKyC,QAC/B,OAAOD,GAAiBA,EAAckL,WAAWkQ,iBACrD,CACA,UAAAvM,CAAWwM,GAAwB,GAE/B,GADA7d,KAAK+C,KAAKoX,iBAAkB,EACxBna,KAAK+C,KAAKya,kBAEV,YADAxd,KAAKyC,QAAQ6L,gBAAkBtO,KAAKyC,QAAQ6L,kBAoBhD,GALI6J,OAAOa,iCACNhZ,KAAK6Y,2BACNF,GAAuC3Y,OAE1CA,KAAK+C,KAAKwU,YAAcvX,KAAK+C,KAAK0a,cAC/Bzd,KAAKwX,cACL,OACJxX,KAAKwX,eAAgB,EACrB,IAAK,IAAIlV,EAAI,EAAGA,EAAItC,KAAKqb,KAAKjZ,OAAQE,IAAK,CACvC,MAAMvC,EAAOC,KAAKqb,KAAK/Y,GACvBvC,EAAKka,sBAAuB,EAC5Bla,EAAK+d,aAAa,YACd/d,EAAK0C,QAAQsa,YACbhd,EAAKsR,YAAW,EAExB,CACA,MAAM,SAAEd,EAAQ,OAAEpL,GAAWnF,KAAKyC,QAClC,QAAiBjB,IAAb+O,IAA2BpL,EAC3B,OACJ,MAAMyY,EAAoB5d,KAAK2d,uBAC/B3d,KAAK+d,2BAA6BH,EAC5BA,EAAkB5d,KAAKkD,aAAc,SACrC1B,EACNxB,KAAKge,iBACLH,GAAyB7d,KAAKub,gBAAgB,aAClD,CACA,MAAArb,GACIF,KAAKoa,iBAAkB,EAKvB,GAJyBpa,KAAKwd,kBAQ1B,OAHAxd,KAAKud,gBACLvd,KAAKwa,yBACLxa,KAAK0a,MAAMxO,QAAQ+R,IAGlBje,KAAKuX,YACNvX,KAAK0a,MAAMxO,QAAQgS,IAEvBle,KAAKuX,YAAa,EAIlBvX,KAAK0a,MAAMxO,QAAQiS,IAKnBne,KAAK0a,MAAMxO,QAAQkS,IAKnBpe,KAAK0a,MAAMxO,QAAQmS,IACnBre,KAAKwa,oBAML,MAAM1G,EAAM,IAAKA,MACjB,KAAUzR,OAAQ,EAAAic,EAAA,GAAM,EAAG,IAAO,GAAIxK,EAAM,KAAUE,WACtD,KAAUA,UAAYF,EACtB,KAAUyK,cAAe,EACzB,KAAWre,OAAOse,QAAQ,MAC1B,KAAWC,UAAUD,QAAQ,MAC7B,KAAWnM,OAAOmM,QAAQ,MAC1B,KAAUD,cAAe,CAC7B,CACA,SAAAzN,GACS9Q,KAAKoa,kBACNpa,KAAKoa,iBAAkB,EACvBvI,EAAA,EAAUqC,KAAKlU,KAAKqa,gBAE5B,CACA,iBAAAG,GACIxa,KAAK0a,MAAMxO,QAAQwS,IACnB1e,KAAKob,YAAYlP,QAAQyS,GAC7B,CACA,wBAAAC,GACS5e,KAAKsa,4BACNta,KAAKsa,2BAA4B,EACjC,KAAMmE,UAAUze,KAAKya,kBAAkB,GAAO,GAEtD,CACA,yBAAAvI,GAMI,KAAMV,YAAW,KACTxR,KAAKwX,cACLxX,KAAK+C,KAAK+N,YAGV9Q,KAAK+C,KAAKwX,mBACd,GAER,CAIA,cAAAyD,IACQhe,KAAKqX,UAAarX,KAAKsG,WAE3BtG,KAAKqX,SAAWrX,KAAK6e,UACzB,CACA,YAAAT,GACI,IAAKpe,KAAKsG,SACN,OAGJ,GADAtG,KAAK8d,iBACC9d,KAAKyC,QAAQqc,qBAAuB9e,KAAK+R,UAC1C/R,KAAKwX,eACN,OASJ,GAAIxX,KAAKmX,aAAenX,KAAKmX,WAAW7Q,SACpC,IAAK,IAAIhE,EAAI,EAAGA,EAAItC,KAAKqb,KAAKjZ,OAAQE,IAAK,CAC1BtC,KAAKqb,KAAK/Y,GAClBwb,cACT,CAEJ,MAAMiB,EAAa/e,KAAKmF,OACxBnF,KAAKmF,OAASnF,KAAK6e,SAAQ,GAC3B7e,KAAKgf,iBAAkB,WACvBhf,KAAKwX,eAAgB,EACrBxX,KAAKuC,qBAAkBf,EACvBxB,KAAKub,gBAAgB,UAAWvb,KAAKmF,OAAO8Z,WAC5C,MAAM,cAAEzc,GAAkBxC,KAAKyC,QAC/BD,GACIA,EAAciZ,OAAO,gBAAiBzb,KAAKmF,OAAO8Z,UAAWF,EAAaA,EAAWE,eAAYzd,EACzG,CACA,YAAAsc,CAAaoB,EAAQ,WACjB,IAAIC,EAAmB7S,QAAQtM,KAAKyC,QAAQI,cAAgB7C,KAAKsG,UAMjE,GALItG,KAAK8C,QACL9C,KAAK8C,OAAOyW,cAAgBvZ,KAAK+C,KAAKwW,aACtCvZ,KAAK8C,OAAOoc,QAAUA,IACtBC,GAAmB,GAEnBA,EAAkB,CAClB,MAAMC,EAAS/F,EAAkBrZ,KAAKsG,UACtCtG,KAAK8C,OAAS,CACVyW,YAAavZ,KAAK+C,KAAKwW,YACvB2F,QACAE,SACAnc,OAAQmW,EAAcpZ,KAAKsG,UAC3B+Y,QAASrf,KAAK8C,OAAS9C,KAAK8C,OAAOsc,OAASA,EAEpD,CACJ,CACA,cAAA9F,GACI,IAAKA,EACD,OACJ,MAAMgG,EAAmBtf,KAAKwX,eAC1BxX,KAAKia,sBACLja,KAAKyC,QAAQqc,oBACXS,EAAgBvf,KAAKuC,kBAAoB4T,GAAYnW,KAAKuC,iBAC1Dqb,EAAoB5d,KAAK2d,uBACzB6B,EAAyB5B,EACzBA,EAAkB5d,KAAKkD,aAAc,SACrC1B,EACAie,EAA8BD,IAA2Bxf,KAAK+d,2BAChEuB,IACCC,IACG,SAAavf,KAAKkD,eAClBuc,KACJnG,EAAetZ,KAAKsG,SAAUkZ,GAC9Bxf,KAAKia,sBAAuB,EAC5Bja,KAAK2W,iBAEb,CACA,OAAAkI,CAAQa,GAAkB,GACtB,MAAMC,EAAU3f,KAAKwG,iBACrB,IAAIyY,EAAYjf,KAAK4f,oBAAoBD,GAi+BrD,IAAkB/d,EAv9BN,OAJI8d,IACAT,EAAYjf,KAAK0f,gBAAgBT,IA29B7CY,IADcje,EAx9BGqd,GAy9BHze,GACdqf,GAAUje,EAAIjB,GAz9BC,CACH4Y,YAAavZ,KAAK+C,KAAKwW,YACvBuG,YAAaH,EACbV,YACA/b,aAAc,CAAC,EACfwB,OAAQ1E,KAAKkO,GAErB,CACA,cAAA1H,GACI,IAAI+C,EACJ,MAAM,cAAE/G,GAAkBxC,KAAKyC,QAC/B,IAAKD,EACD,OAAO,WACX,MAAMZ,EAAMY,EAAc6D,qBAE1B,MADgD,QAAtBkD,EAAKvJ,KAAK8C,cAA2B,IAAPyG,OAAgB,EAASA,EAAG8V,UAAYrf,KAAKqb,KAAK0E,KAAKC,KACzF,CAElB,MAAM,OAAEld,GAAW9C,KAAK+C,KACpBD,KACA,SAAclB,EAAIpB,EAAGsC,EAAOG,OAAOzC,IACnC,SAAcoB,EAAIjB,EAAGmC,EAAOG,OAAOtC,GAE3C,CACA,OAAOiB,CACX,CACA,mBAAAge,CAAoBhe,GAChB,IAAI2H,EACJ,MAAM0W,GAAmB,WAEzB,GADA9K,GAAY8K,EAAkBre,GACH,QAAtB2H,EAAKvJ,KAAK8C,cAA2B,IAAPyG,OAAgB,EAASA,EAAG8V,QAC3D,OAAOY,EAMX,IAAK,IAAI3d,EAAI,EAAGA,EAAItC,KAAKqb,KAAKjZ,OAAQE,IAAK,CACvC,MAAMvC,EAAOC,KAAKqb,KAAK/Y,IACjB,OAAEQ,EAAM,QAAEL,GAAY1C,EACxBA,IAASC,KAAK+C,MAAQD,GAAUL,EAAQI,eAKpCC,EAAOuc,SACPlK,GAAY8K,EAAkBre,IAElC,SAAcqe,EAAiBzf,EAAGsC,EAAOG,OAAOzC,IAChD,SAAcyf,EAAiBtf,EAAGmC,EAAOG,OAAOtC,GAExD,CACA,OAAOsf,CACX,CACA,cAAAC,CAAete,EAAKue,GAAgB,GAChC,MAAMC,GAAiB,WACvBjL,GAAYiL,EAAgBxe,GAC5B,IAAK,IAAIU,EAAI,EAAGA,EAAItC,KAAKqb,KAAKjZ,OAAQE,IAAK,CACvC,MAAMvC,EAAOC,KAAKqb,KAAK/Y,IAClB6d,GACDpgB,EAAK0C,QAAQI,cACb9C,EAAK+C,QACL/C,IAASA,EAAKgD,OACd,SAAaqd,EAAgB,CACzB5f,GAAIT,EAAK+C,OAAOG,OAAOzC,EACvBG,GAAIZ,EAAK+C,OAAOG,OAAOtC,KAG1B,SAAaZ,EAAKmD,gBAEvB,SAAakd,EAAgBrgB,EAAKmD,aACtC,CAIA,OAHI,SAAalD,KAAKkD,gBAClB,SAAakd,EAAgBpgB,KAAKkD,cAE/Bkd,CACX,CACA,eAAAV,CAAgB9d,GACZ,MAAMye,GAAsB,WAC5BlL,GAAYkL,EAAqBze,GACjC,IAAK,IAAIU,EAAI,EAAGA,EAAItC,KAAKqb,KAAKjZ,OAAQE,IAAK,CACvC,MAAMvC,EAAOC,KAAKqb,KAAK/Y,GACvB,IAAKvC,EAAKuG,SACN,SACJ,KAAK,SAAavG,EAAKmD,cACnB,UACJ,SAASnD,EAAKmD,eAAiBnD,EAAKie,iBACpC,MAAM/H,GAAY,WAElBd,GAAYc,EADIlW,EAAKyG,kBAErBwP,GAAoBqK,EAAqBtgB,EAAKmD,aAAcnD,EAAKsX,SAAWtX,EAAKsX,SAAS4H,eAAYzd,EAAWyU,EACrH,CAIA,OAHI,SAAajW,KAAKkD,eAClB8S,GAAoBqK,EAAqBrgB,KAAKkD,cAE3Cmd,CACX,CACA,cAAAC,CAAeje,GACXrC,KAAKugB,YAAcle,EACnBrC,KAAK+C,KAAK6b,2BACV5e,KAAK0Z,mBAAoB,CAC7B,CACA,UAAAzI,CAAWxO,GACPzC,KAAKyC,QAAU,IACRzC,KAAKyC,WACLA,EACHgV,eAAiCjW,IAAtBiB,EAAQgV,WAA0BhV,EAAQgV,UAE7D,CACA,iBAAAwG,GACIje,KAAK8C,YAAStB,EACdxB,KAAKmF,YAAS3D,EACdxB,KAAKqX,cAAW7V,EAChBxB,KAAK+d,gCAA6Bvc,EAClCxB,KAAKugB,iBAAc/e,EACnBxB,KAAKqE,YAAS7C,EACdxB,KAAKwX,eAAgB,CACzB,CACA,kCAAAgJ,GACSxgB,KAAKygB,gBAQNzgB,KAAKygB,eAAezF,2BACpB,KAAUhH,WACVhU,KAAKygB,eAAe7F,oBAAmB,EAE/C,CACA,kBAAAA,CAAmB8F,GAAqB,GACpC,IAAInX,EAMJ,MAAMsN,EAAO7W,KAAK2gB,UAClB3gB,KAAK0Z,oBAAsB1Z,KAAK0Z,kBAAoB7C,EAAK6C,mBACzD1Z,KAAK4Z,mBAAqB5Z,KAAK4Z,iBAAmB/C,EAAK+C,kBACvD5Z,KAAK2Z,0BAA4B3Z,KAAK2Z,wBAA0B9C,EAAK8C,yBACrE,MAAMiH,EAAWtU,QAAQtM,KAAK4X,eAAiB5X,OAAS6W,EAWxD,KANkB6J,GACbE,GAAY5gB,KAAK2Z,yBAClB3Z,KAAK0Z,oBACmB,QAAtBnQ,EAAKvJ,KAAKgF,cAA2B,IAAPuE,OAAgB,EAASA,EAAGmQ,oBAC5D1Z,KAAK6gB,gCACL7gB,KAAK+C,KAAK+W,uBAEV,OACJ,MAAM,OAAE3U,EAAM,SAAEoL,GAAavQ,KAAKyC,QAIlC,GAAKzC,KAAKmF,SAAYA,GAAUoL,GAAhC,CAQA,GANAvQ,KAAKgb,yBAA2B,KAAUhH,WAMrChU,KAAKugB,cAAgBvgB,KAAKsc,eAAgB,CAC3C,MAAMmE,EAAiBzgB,KAAK8gB,6BACxBL,GACAA,EAAetb,QACY,IAA3BnF,KAAKmb,mBACLnb,KAAKygB,eAAiBA,EACtBzgB,KAAKwgB,qCACLxgB,KAAKsc,gBAAiB,WACtBtc,KAAK+gB,sBAAuB,YAC5B,SAAqB/gB,KAAK+gB,qBAAsB/gB,KAAKmF,OAAO8Z,UAAWwB,EAAetb,OAAO8Z,WAC7F9J,GAAYnV,KAAKsc,eAAgBtc,KAAK+gB,uBAGtC/gB,KAAKygB,eAAiBzgB,KAAKsc,oBAAiB9a,CAEpD,CAKA,GAAKxB,KAAKsc,gBAAmBtc,KAAKugB,YAAlC,CAyCA,GApCKvgB,KAAKqE,SACNrE,KAAKqE,QAAS,WACdrE,KAAKghB,sBAAuB,YAK5BhhB,KAAKsc,gBACLtc,KAAK+gB,sBACL/gB,KAAKygB,gBACLzgB,KAAKygB,eAAepc,QACpBrE,KAAKwgB,sCACL,QAAgBxgB,KAAKqE,OAAQrE,KAAKsc,eAAgBtc,KAAKygB,eAAepc,SAKjErE,KAAKugB,aACNjU,QAAQtM,KAAK4X,cAEb5X,KAAKqE,OAASrE,KAAKkgB,eAAelgB,KAAKmF,OAAO8Z,WAG9C9J,GAAYnV,KAAKqE,OAAQrE,KAAKmF,OAAO8Z,YAEzC,SAAcjf,KAAKqE,OAAQrE,KAAKugB,cAMhCpL,GAAYnV,KAAKqE,OAAQrE,KAAKmF,OAAO8Z,WAKrCjf,KAAK6gB,+BAAgC,CACrC7gB,KAAK6gB,gCAAiC,EACtC,MAAMJ,EAAiBzgB,KAAK8gB,6BACxBL,GACAnU,QAAQmU,EAAe7I,gBACnBtL,QAAQtM,KAAK4X,gBAChB6I,EAAehe,QAAQI,cACxB4d,EAAepc,QACY,IAA3BrE,KAAKmb,mBACLnb,KAAKygB,eAAiBA,EACtBzgB,KAAKwgB,qCACLxgB,KAAKsc,gBAAiB,WACtBtc,KAAK+gB,sBAAuB,YAC5B,SAAqB/gB,KAAK+gB,qBAAsB/gB,KAAKqE,OAAQoc,EAAepc,QAC5E8Q,GAAYnV,KAAKsc,eAAgBtc,KAAK+gB,uBAGtC/gB,KAAKygB,eAAiBzgB,KAAKsc,oBAAiB9a,CAEpD,CAII0W,IACAJ,GAAQE,sBAhEF,CA5BA,CA8Fd,CACA,0BAAA8I,GACI,GAAK9gB,KAAKgF,UACN,SAAShF,KAAKgF,OAAO9B,iBACrB,SAAelD,KAAKgF,OAAO9B,cAG/B,OAAIlD,KAAKgF,OAAOic,eACLjhB,KAAKgF,OAGLhF,KAAKgF,OAAO8b,4BAE3B,CACA,YAAAG,GACI,OAAO3U,SAAStM,KAAKsc,gBACjBtc,KAAKugB,aACLvgB,KAAKyC,QAAQsa,aACb/c,KAAKmF,OACb,CACA,cAAA0V,GACI,IAAItR,EACJ,MAAMsN,EAAO7W,KAAK2gB,UACZC,EAAWtU,QAAQtM,KAAK4X,eAAiB5X,OAAS6W,EACxD,IAAIqK,GAAU,EAuBd,IAlBIlhB,KAAK0Z,oBAA6C,QAAtBnQ,EAAKvJ,KAAKgF,cAA2B,IAAPuE,OAAgB,EAASA,EAAGmQ,sBACtFwH,GAAU,GAMVN,IACC5gB,KAAK2Z,yBAA2B3Z,KAAK4Z,oBACtCsH,GAAU,GAMVlhB,KAAKgb,2BAA6B,KAAUhH,YAC5CkN,GAAU,GAEVA,EACA,OACJ,MAAM,OAAE/b,EAAM,SAAEoL,GAAavQ,KAAKyC,QAWlC,GANAzC,KAAKwZ,gBAAkBlN,QAAStM,KAAKgF,QAAUhF,KAAKgF,OAAOwU,iBACvDxZ,KAAK8R,kBACL9R,KAAKmhB,kBACJnhB,KAAKwZ,kBACNxZ,KAAKugB,YAAcvgB,KAAKsc,oBAAiB9a,IAExCxB,KAAKmF,SAAYA,IAAUoL,EAC5B,OAKJ4E,GAAYnV,KAAKgf,gBAAiBhf,KAAKmF,OAAO8Z,WAI9C,MAAMmC,EAAiBphB,KAAKgC,UAAUxB,EAChC6gB,EAAiBrhB,KAAKgC,UAAUrB,GAKtC,SAAgBX,KAAKgf,gBAAiBhf,KAAKgC,UAAWhC,KAAKqb,KAAMuF,IAK7D/J,EAAK1R,QACJ0R,EAAKxS,QACgB,IAArBrE,KAAKgC,UAAUxB,GAAgC,IAArBR,KAAKgC,UAAUrB,IAC1CkW,EAAKxS,OAASwS,EAAK1R,OAAO8Z,UAC1BpI,EAAKmK,sBAAuB,YAEhC,MAAM,OAAE3c,GAAWwS,EACdxS,GAYArE,KAAKuC,iBAAoBvC,KAAKshB,qBAI/BjM,GAAkBrV,KAAKshB,oBAAoB9gB,EAAGR,KAAKuC,gBAAgB/B,GACnE6U,GAAkBrV,KAAKshB,oBAAoB3gB,EAAGX,KAAKuC,gBAAgB5B,IAJnEX,KAAKuhB,0BAeT,SAAavhB,KAAKuC,gBAAiBvC,KAAKgf,gBAAiB3a,EAAQrE,KAAKkD,cAClElD,KAAKgC,UAAUxB,IAAM4gB,GACrBphB,KAAKgC,UAAUrB,IAAM0gB,GACpB5K,GAAgBzW,KAAKuC,gBAAgB/B,EAAGR,KAAKshB,oBAAoB9gB,IACjEiW,GAAgBzW,KAAKuC,gBAAgB5B,EAAGX,KAAKshB,oBAAoB3gB,KAClEX,KAAKib,cAAe,EACpBjb,KAAK2W,iBACL3W,KAAKub,gBAAgB,mBAAoBlX,IAKzC6T,IACAJ,GAAQG,0BAnCJjY,KAAKshB,sBACLthB,KAAKuhB,yBACLvhB,KAAK2W,iBAmCjB,CACA,IAAAe,GACI1X,KAAKkb,WAAY,CAErB,CACA,IAAAhE,GACIlX,KAAKkb,WAAY,CAErB,CACA,cAAAvE,CAAe6K,GAAY,GACvB,IAAIjY,EAEJ,GADsC,QAArCA,EAAKvJ,KAAKyC,QAAQD,qBAAkC,IAAP+G,GAAyBA,EAAGoN,iBACtE6K,EAAW,CACX,MAAM/P,EAAQzR,KAAK0R,WACnBD,GAASA,EAAMkF,gBACnB,CACI3W,KAAK4X,eAAiB5X,KAAK4X,aAAatR,WACxCtG,KAAK4X,kBAAepW,EAE5B,CACA,sBAAA+f,GACIvhB,KAAKshB,qBAAsB,WAC3BthB,KAAKuC,iBAAkB,WACvBvC,KAAKyhB,8BAA+B,UACxC,CACA,kBAAAzE,CAAmB3a,EAAOya,GAA+B,GACrD,MAAMzF,EAAWrX,KAAKqX,SAChBqK,EAAuBrK,EACvBA,EAASnU,aACT,CAAC,EACDye,EAAc,IAAK3hB,KAAKkD,cACxBqd,GAAc,WACfvgB,KAAKygB,gBACLzgB,KAAKygB,eAAehe,QAAQsa,aAC7B/c,KAAKsc,eAAiBtc,KAAK+gB,0BAAuBvf,GAEtDxB,KAAK6gB,gCAAkC/D,EACvC,MAAM8E,GAAiB,WAGjBC,GAFiBxK,EAAWA,EAAS3S,YAASlD,MAC/BxB,KAAKmF,OAASnF,KAAKmF,OAAOT,YAASlD,GAElDiQ,EAAQzR,KAAK0R,WACboQ,GAAgBrQ,GAASA,EAAME,QAAQvP,QAAU,EACjD2f,EAAyBzV,QAAQuV,IAClCC,IAC0B,IAA3B9hB,KAAKyC,QAAQgV,YACZzX,KAAKqb,KAAK0E,KAAKiC,KAEpB,IAAIC,EADJjiB,KAAKmb,kBAAoB,EAEzBnb,KAAKkiB,eAAkB/S,IACnB,MAAM6F,EAAW7F,EAAS,IFj/B1C,IAAmBiE,EAAGC,EE0/CN8O,EAAQC,EAAMC,EAAItN,EAxgBlBuN,GAAa/B,EAAY/f,EAAG6B,EAAM7B,EAAGwU,GACrCsN,GAAa/B,EAAY5f,EAAG0B,EAAM1B,EAAGqU,GACrChV,KAAKsgB,eAAeC,GAChBvgB,KAAKsc,gBACLtc,KAAK+gB,sBACL/gB,KAAKmF,QACLnF,KAAKygB,gBACLzgB,KAAKygB,eAAetb,UACpB,SAAqByc,EAAgB5hB,KAAKmF,OAAO8Z,UAAWjf,KAAKygB,eAAetb,OAAO8Z,WAggB3FkD,EA/fWniB,KAAKsc,eA+fR8F,EA/fwBpiB,KAAK+gB,qBA+fvBsB,EA/f6CT,EA+fzC7M,EA/fyDC,EAggBvFuN,GAAQJ,EAAO3hB,EAAG4hB,EAAK5hB,EAAG6hB,EAAG7hB,EAAGuU,GAChCwN,GAAQJ,EAAOxhB,EAAGyhB,EAAKzhB,EAAG0hB,EAAG1hB,EAAGoU,GA5fZkN,IFhgCL7O,EEigCepT,KAAKsc,eFjgCjBjJ,EEigCiC4O,EFhgC5C7L,GAAWhD,EAAE5S,EAAG6S,EAAE7S,IAAM4V,GAAWhD,EAAEzS,EAAG0S,EAAE1S,MEigC7BX,KAAK0Z,mBAAoB,GAExBuI,IACDA,GAAqB,YACzB9M,GAAY8M,EAAoBjiB,KAAKsc,iBAErCuF,IACA7hB,KAAKsX,gBAAkBqK,EL3gC3C,SAAmBtd,EAAQme,EAAQ3L,EAAM7B,EAAU+M,EAAwBD,GACnEC,GACA1d,EAAOoe,SAAU,OAAU,OAEVjhB,IAAjBqV,EAAK4L,QAAwB5L,EAAK4L,QAAU,EAAGhO,GAAgBO,IAC/D3Q,EAAOqe,aAAc,YAA6BlhB,IAAnBghB,EAAOC,QAAwBD,EAAOC,QAAU,EAAG,EAAG7N,GAAiBI,KAEjG8M,IACLzd,EAAOoe,SAAU,YAA6BjhB,IAAnBghB,EAAOC,QAAwBD,EAAOC,QAAU,OAAoBjhB,IAAjBqV,EAAK4L,QAAwB5L,EAAK4L,QAAU,EAAGzN,IAKjI,IAAK,IAAI1S,EAAI,EAAGA,EAAI8R,GAAY9R,IAAK,CACjC,MAAMqgB,EAAc,SAASxO,GAAQ7R,WACrC,IAAIsgB,EAAerO,GAAUiO,EAAQG,GACjCE,EAAatO,GAAUsC,EAAM8L,QACZnhB,IAAjBohB,QAA6CphB,IAAfqhB,IAElCD,IAAiBA,EAAe,GAChCC,IAAeA,EAAa,GACI,IAAjBD,GACI,IAAfC,GACAvO,GAAKsO,KAAkBtO,GAAKuO,IAE5Bxe,EAAOse,GAAepe,KAAK7D,KAAI,OAAU2T,GAASuO,GAAevO,GAASwO,GAAa7N,GAAW,IAC9F,KAAQ3F,KAAKwT,IAAe,KAAQxT,KAAKuT,MACzCve,EAAOse,IAAgB,MAI3Bte,EAAOse,GAAeE,EAE9B,EAIIL,EAAOzc,QAAU8Q,EAAK9Q,UACtB1B,EAAO0B,QAAS,OAAUyc,EAAOzc,QAAU,EAAG8Q,EAAK9Q,QAAU,EAAGiP,GAExE,CKo+BoB8N,CAAUnB,EAAaD,EAAsB1hB,KAAKkD,aAAc8R,EAAU+M,EAAwBD,IAEtG9hB,KAAK+C,KAAK6b,2BACV5e,KAAK2W,iBACL3W,KAAKmb,kBAAoBnG,CAAQ,EAErChV,KAAKkiB,eAAeliB,KAAKyC,QAAQsa,WAAa,IAAO,EACzD,CACA,cAAAM,CAAe5a,GACXzC,KAAKub,gBAAgB,kBACrBvb,KAAK8R,kBAAoB9R,KAAK8R,iBAAiBiR,OAC3C/iB,KAAK4X,cAAgB5X,KAAK4X,aAAa9F,kBACvC9R,KAAK4X,aAAa9F,iBAAiBiR,OAEnC/iB,KAAKmhB,oBACL,QAAYnhB,KAAKmhB,kBACjBnhB,KAAKmhB,sBAAmB3f,GAO5BxB,KAAKmhB,iBAAmB,KAAMjhB,QAAO,KACjC0O,EAAsBC,wBAAyB,EAC/C7O,KAAK8R,kBAAmB,OAAmB,EArgCnC,IAqgCuD,IACxDrP,EACHugB,SAAW7T,IACPnP,KAAKkiB,eAAe/S,GACpB1M,EAAQugB,UAAYvgB,EAAQugB,SAAS7T,EAAO,EAEhDgO,WAAY,KACR1a,EAAQ0a,YAAc1a,EAAQ0a,aAC9Bnd,KAAKijB,mBAAmB,IAG5BjjB,KAAK4X,eACL5X,KAAK4X,aAAa9F,iBAAmB9R,KAAK8R,kBAE9C9R,KAAKmhB,sBAAmB3f,CAAS,GAEzC,CACA,iBAAAyhB,GACQjjB,KAAK4X,eACL5X,KAAK4X,aAAa9F,sBAAmBtQ,EACrCxB,KAAK4X,aAAaR,qBAAkB5V,GAExC,MAAMiQ,EAAQzR,KAAK0R,WACnBD,GAASA,EAAMkG,wBACf3X,KAAK4X,aACD5X,KAAK8R,iBACD9R,KAAKsX,qBACD9V,EACZxB,KAAKub,gBAAgB,oBACzB,CACA,eAAAS,GACQhc,KAAK8R,mBACL9R,KAAKkiB,gBAAkBliB,KAAKkiB,eAriCpB,KAsiCRliB,KAAK8R,iBAAiBiR,QAE1B/iB,KAAKijB,mBACT,CACA,uBAAAC,GACI,MAAMrM,EAAO7W,KAAK2gB,UAClB,IAAI,qBAAEK,EAAoB,OAAE3c,EAAM,OAAEc,EAAM,aAAEjC,GAAiB2T,EAC7D,GAAKmK,GAAyB3c,GAAWc,EAAzC,CAOA,GAAInF,OAAS6W,GACT7W,KAAKmF,QACLA,GACAge,GAA0BnjB,KAAKyC,QAAQ2gB,cAAepjB,KAAKmF,OAAO8Z,UAAW9Z,EAAO8Z,WAAY,CAChG5a,EAASrE,KAAKqE,SAAU,WACxB,MAAMgf,GAAU,SAAWrjB,KAAKmF,OAAO8Z,UAAUze,GACjD6D,EAAO7D,EAAEC,IAAMoW,EAAKxS,OAAO7D,EAAEC,IAC7B4D,EAAO7D,EAAEE,IAAM2D,EAAO7D,EAAEC,IAAM4iB,EAC9B,MAAMC,GAAU,SAAWtjB,KAAKmF,OAAO8Z,UAAUte,GACjD0D,EAAO1D,EAAEF,IAAMoW,EAAKxS,OAAO1D,EAAEF,IAC7B4D,EAAO1D,EAAED,IAAM2D,EAAO1D,EAAEF,IAAM6iB,CAClC,CACAnO,GAAY6L,EAAsB3c,IAMlC,SAAa2c,EAAsB9d,IAOnC,SAAalD,KAAKyhB,6BAA8BzhB,KAAKgf,gBAAiBgC,EAAsB9d,EA/BlF,CAgCd,CACA,kBAAA+Y,CAAmB1L,EAAUxQ,GACpBC,KAAKob,YAAY9T,IAAIiJ,IACtBvQ,KAAKob,YAAY7T,IAAIgJ,EAAU,IAAImG,IAEzB1W,KAAKob,YAAYjU,IAAIoJ,GAC7B1E,IAAI9L,GACV,MAAMwjB,EAASxjB,EAAK0C,QAAQ+gB,uBAC5BzjB,EAAKuR,QAAQ,CACT3H,WAAY4Z,EAASA,EAAO5Z,gBAAanI,EACzCyV,sBAAuBsM,GAAUA,EAAOE,4BAClCF,EAAOE,4BAA4B1jB,QACnCyB,GAEd,CACA,MAAAuQ,GACI,MAAMN,EAAQzR,KAAK0R,WACnB,OAAOD,GAAQA,EAAMoF,OAAS7W,IAClC,CACA,OAAA2gB,GACI,IAAIpX,EACJ,MAAM,SAAEgH,GAAavQ,KAAKyC,QAC1B,OAAO8N,IAAuC,QAA1BhH,EAAKvJ,KAAK0R,kBAA+B,IAAPnI,OAAgB,EAASA,EAAGsN,OAAgB7W,IACtG,CACA,WAAA0jB,GACI,IAAIna,EACJ,MAAM,SAAEgH,GAAavQ,KAAKyC,QAC1B,OAAO8N,EAAsC,QAA1BhH,EAAKvJ,KAAK0R,kBAA+B,IAAPnI,OAAgB,EAASA,EAAGqN,cAAWpV,CAChG,CACA,QAAAkQ,GACI,MAAM,SAAEnB,GAAavQ,KAAKyC,QAC1B,GAAI8N,EACA,OAAOvQ,KAAK+C,KAAKqY,YAAYjU,IAAIoJ,EACzC,CACA,OAAAe,EAAQ,WAAE0I,EAAU,WAAErQ,EAAU,sBAAEsN,GAA2B,CAAC,GAC1D,MAAMxF,EAAQzR,KAAK0R,WACfD,GACAA,EAAMH,QAAQtR,KAAMiX,GACpB+C,IACAha,KAAKuC,qBAAkBf,EACvBxB,KAAKga,YAAa,GAElBrQ,GACA3J,KAAKiR,WAAW,CAAEtH,cAC1B,CACA,QAAA4H,GACI,MAAME,EAAQzR,KAAK0R,WACnB,QAAID,GACOA,EAAMF,SAASvR,KAK9B,CACA,oBAAA0d,GACI,MAAM,cAAElb,GAAkBxC,KAAKyC,QAC/B,IAAKD,EACD,OAEJ,IAAImhB,GAAyB,EAK7B,MAAM,aAAEzgB,GAAiBV,EAWzB,IAVIU,EAAa4C,GACb5C,EAAa6C,QACb7C,EAAa8C,SACb9C,EAAa+C,SACb/C,EAAa0gB,SACb1gB,EAAagD,OACbhD,EAAaiD,SACbwd,GAAyB,IAGxBA,EACD,OACJ,MAAME,EAAc,CAAC,EACjB3gB,EAAa4C,GACb0S,GAAyB,IAAKhW,EAAeqhB,EAAa7jB,KAAKsX,iBAGnE,IAAK,IAAIhV,EAAI,EAAGA,EAAI+V,GAAcjW,OAAQE,IACtCkW,GAAyB,SAASH,GAAc/V,KAAME,EAAeqhB,EAAa7jB,KAAKsX,iBACvFkB,GAAyB,OAAOH,GAAc/V,KAAME,EAAeqhB,EAAa7jB,KAAKsX,iBAIzF9U,EAAc6P,SAEd,IAAK,MAAMhL,KAAOwc,EACdrhB,EAAckW,eAAerR,EAAKwc,EAAYxc,IAC1CrH,KAAKsX,kBACLtX,KAAKsX,gBAAgBjQ,GAAOwc,EAAYxc,IAKhD7E,EAAcmU,gBAClB,CACA,mBAAAmN,CAAoBC,GAChB,IAAIxa,EAAIya,EACR,IAAKhkB,KAAKsG,UAAYtG,KAAK+Z,MACvB,OACJ,IAAK/Z,KAAKkb,UACN,OAAO5C,GAEX,MAAM2L,EAAS,CACX1L,WAAY,IAEVqF,EAAoB5d,KAAK2d,uBAC/B,GAAI3d,KAAKga,WAQL,OAPAha,KAAKga,YAAa,EAClBiK,EAAOxB,QAAU,GACjBwB,EAAOC,eACH,QAAmBH,aAA6C,EAASA,EAAUG,gBAAkB,GACzGD,EAAOxgB,UAAYma,EACbA,EAAkB5d,KAAKkD,aAAc,IACrC,OACC+gB,EAEX,MAAMpN,EAAO7W,KAAK2gB,UAClB,IAAK3gB,KAAKuC,kBAAoBvC,KAAKmF,SAAW0R,EAAKxS,OAAQ,CACvD,MAAM8f,EAAc,CAAC,EAerB,OAdInkB,KAAKyC,QAAQ8N,WACb4T,EAAY1B,aACsBjhB,IAA9BxB,KAAKkD,aAAauf,QACZziB,KAAKkD,aAAauf,QAClB,EACV0B,EAAYD,eACR,QAAmBH,aAA6C,EAASA,EAAUG,gBAAkB,IAEzGlkB,KAAKib,gBAAiB,SAAajb,KAAKkD,gBACxCihB,EAAY1gB,UAAYma,EAClBA,EAAkB,CAAC,EAAG,IACtB,OACN5d,KAAKib,cAAe,GAEjBkJ,CACX,CACA,MAAMC,EAAiBvN,EAAKS,iBAAmBT,EAAK3T,aACpDlD,KAAKkjB,0BACLe,EAAOxgB,UErwCnB,SAAkCpB,EAAOL,EAAWqiB,GAChD,IAAI5gB,EAAY,GAOhB,MAAM6gB,EAAajiB,EAAM7B,EAAEc,UAAYU,EAAUxB,EAC3C+jB,EAAaliB,EAAM1B,EAAEW,UAAYU,EAAUrB,EAC3C6jB,GAAcH,aAAyD,EAASA,EAAgBve,IAAM,EAW5G,IAVIwe,GAAcC,GAAcC,KAC5B/gB,EAAY,eAAe6gB,QAAiBC,QAAiBC,SAM7C,IAAhBxiB,EAAUxB,GAA2B,IAAhBwB,EAAUrB,IAC/B8C,GAAa,SAAS,EAAIzB,EAAUxB,MAAM,EAAIwB,EAAUrB,OAExD0jB,EAAiB,CACjB,MAAM,qBAAEI,EAAoB,OAAE1e,EAAM,QAAEC,EAAO,QAAEC,EAAO,MAAEC,EAAK,MAAEC,GAAUke,EACrEI,IACAhhB,EAAY,eAAeghB,QAA2BhhB,KACtDsC,IACAtC,GAAa,UAAUsC,UACvBC,IACAvC,GAAa,WAAWuC,UACxBC,IACAxC,GAAa,WAAWwC,UACxBC,IACAzC,GAAa,SAASyC,UACtBC,IACA1C,GAAa,SAAS0C,SAC9B,CAKA,MAAMue,EAAgBriB,EAAM7B,EAAEW,MAAQa,EAAUxB,EAC1CmkB,EAAgBtiB,EAAM1B,EAAEQ,MAAQa,EAAUrB,EAIhD,OAHsB,IAAlB+jB,GAAyC,IAAlBC,IACvBlhB,GAAa,SAASihB,MAAkBC,MAErClhB,GAAa,MACxB,CFutC+BmhB,CAAyB5kB,KAAKyhB,6BAA8BzhB,KAAKgC,UAAWoiB,GAC3FxG,IACAqG,EAAOxgB,UAAYma,EAAkBwG,EAAgBH,EAAOxgB,YAEhE,MAAM,EAAEjD,EAAC,EAAEG,GAAMX,KAAKuC,gBACtB0hB,EAAOY,gBAAkB,GAAc,IAAXrkB,EAAEmE,WAA4B,IAAXhE,EAAEgE,YAC7CkS,EAAKS,gBAKL2M,EAAOxB,QACH5L,IAAS7W,KACiG,QAAnGgkB,EAAuC,QAAjCza,EAAK6a,EAAe3B,eAA4B,IAAPlZ,EAAgBA,EAAKvJ,KAAKkD,aAAauf,eAA4B,IAAPuB,EAAgBA,EAAK,EACjIhkB,KAAKoX,gBACDpX,KAAKkD,aAAauf,QAClB2B,EAAe1B,YAO7BuB,EAAOxB,QACH5L,IAAS7W,UACwBwB,IAA3B4iB,EAAe3B,QACX2B,EAAe3B,QACf,QAC2BjhB,IAA/B4iB,EAAe1B,YACX0B,EAAe1B,YACf,EAKlB,IAAK,MAAMrb,KAAO4I,EAAiB,CAC/B,QAA4BzO,IAAxB4iB,EAAe/c,GACf,SACJ,MAAM,QAAE6H,EAAO,QAAE2D,GAAY5C,EAAgB5I,GAOvCyd,EAAiC,SAArBb,EAAOxgB,UACnB2gB,EAAe/c,GACf6H,EAAQkV,EAAe/c,GAAMwP,GACnC,GAAIhE,EAAS,CACT,MAAMkS,EAAMlS,EAAQzQ,OACpB,IAAK,IAAIE,EAAI,EAAGA,EAAIyiB,EAAKziB,IACrB2hB,EAAOpR,EAAQvQ,IAAMwiB,CAE7B,MAEIb,EAAO5c,GAAOyd,CAEtB,CAYA,OANI9kB,KAAKyC,QAAQ8N,WACb0T,EAAOC,cACHrN,IAAS7W,MACH,QAAmB+jB,aAA6C,EAASA,EAAUG,gBAAkB,GACrG,QAEPD,CACX,CACA,aAAAvF,GACI1e,KAAKmX,WAAanX,KAAKqX,cAAW7V,CACtC,CAEA,SAAAwjB,GACIhlB,KAAK+C,KAAK2X,MAAMxO,SAASnM,IAAW,IAAIwJ,EAAI,OAAwC,QAAhCA,EAAKxJ,EAAK+R,wBAAqC,IAAPvI,OAAgB,EAASA,EAAGwZ,MAAM,IAC9H/iB,KAAK+C,KAAK2X,MAAMxO,QAAQ+R,IACxBje,KAAK+C,KAAKqY,YAAY6J,OAC1B,EAER,CACA,SAAS7G,GAAare,GAClBA,EAAKqe,cACT,CACA,SAASC,GAAmBte,GACxB,IAAIwJ,EACJ,MAAM8N,GAAuC,QAA1B9N,EAAKxJ,EAAKoX,kBAA+B,IAAP5N,OAAgB,EAASA,EAAG8N,WAAatX,EAAKsX,SACnG,GAAItX,EAAKgS,UACLhS,EAAKoF,QACLkS,GACAtX,EAAK2b,aAAa,aAAc,CAChC,MAAQuD,UAAW9Z,EAAQ2a,YAAaoF,GAAmBnlB,EAAKoF,QAC1D,cAAEie,GAAkBrjB,EAAK0C,QACzBme,EAAWvJ,EAAS3S,SAAW3E,EAAKoF,OAAOT,OAG3B,SAAlB0e,GACA,SAAU1hB,IACN,MAAMyjB,EAAevE,EACfvJ,EAASyI,YAAYpe,GACrB2V,EAAS4H,UAAUvd,GACnBU,GAAS,SAAW+iB,GAC1BA,EAAa1kB,IAAM0E,EAAOzD,GAAMjB,IAChC0kB,EAAazkB,IAAMykB,EAAa1kB,IAAM2B,CAAM,IAG3C+gB,GAA0BC,EAAe/L,EAAS4H,UAAW9Z,KAClE,SAAUzD,IACN,MAAMyjB,EAAevE,EACfvJ,EAASyI,YAAYpe,GACrB2V,EAAS4H,UAAUvd,GACnBU,GAAS,SAAW+C,EAAOzD,IACjCyjB,EAAazkB,IAAMykB,EAAa1kB,IAAM2B,EAIlCrC,EAAKuc,iBAAmBvc,EAAK+R,mBAC7B/R,EAAK2Z,mBAAoB,EACzB3Z,EAAKuc,eAAe5a,GAAMhB,IACtBX,EAAKuc,eAAe5a,GAAMjB,IAAM2B,EACxC,IAGR,MAAMgjB,GAAc,YACpB,SAAaA,EAAajgB,EAAQkS,EAAS4H,WAC3C,MAAMoG,GAAc,WAChBzE,GACA,SAAayE,EAAatlB,EAAKmgB,eAAegF,GAAgB,GAAO7N,EAASyI,cAG9E,SAAauF,EAAalgB,EAAQkS,EAAS4H,WAE/C,MAAM/C,GAAoB/F,GAAYiP,GACtC,IAAIjJ,GAA2B,EAC/B,IAAKpc,EAAKoX,WAAY,CAClB,MAAMsJ,EAAiB1gB,EAAK+gB,6BAK5B,GAAIL,IAAmBA,EAAetJ,WAAY,CAC9C,MAAQE,SAAUiO,EAAgBngB,OAAQogB,GAAiB9E,EAC3D,GAAI6E,GAAkBC,EAAc,CAChC,MAAMC,GAAmB,YACzB,SAAqBA,EAAkBnO,EAAS4H,UAAWqG,EAAerG,WAC1E,MAAM2C,GAAiB,YACvB,SAAqBA,EAAgBzc,EAAQogB,EAAatG,WACrD1I,GAAiBiP,EAAkB5D,KACpCzF,GAA2B,GAE3BsE,EAAehe,QAAQsa,aACvBhd,EAAKuc,eAAiBsF,EACtB7hB,EAAKghB,qBAAuByE,EAC5BzlB,EAAK0gB,eAAiBA,EAE9B,CACJ,CACJ,CACA1gB,EAAKwb,gBAAgB,YAAa,CAC9BpW,SACAkS,WACAhV,MAAOgjB,EACPD,cACAlJ,mBACAC,4BAER,MACK,GAAIpc,EAAKgS,SAAU,CACpB,MAAM,eAAEzD,GAAmBvO,EAAK0C,QAChC6L,GAAkBA,GACtB,CAMAvO,EAAK0C,QAAQkH,gBAAanI,CAC9B,CACA,SAASmZ,GAAoB5a,GAIrBmY,IACAJ,GAAQC,aAEPhY,EAAKiF,SAQLjF,EAAKkhB,iBACNlhB,EAAK2Z,kBAAoB3Z,EAAKiF,OAAO0U,mBAOzC3Z,EAAK4Z,0BAA4B5Z,EAAK4Z,wBAA0BrN,QAAQvM,EAAK2Z,mBACzE3Z,EAAKiF,OAAO0U,mBACZ3Z,EAAKiF,OAAO2U,0BAChB5Z,EAAK6Z,mBAAqB7Z,EAAK6Z,iBAAmB7Z,EAAKiF,OAAO4U,kBAClE,CACA,SAASkB,GAAgB/a,GACrBA,EAAK2Z,kBACD3Z,EAAK4Z,wBACD5Z,EAAK6Z,kBACD,CAChB,CACA,SAAS8E,GAAc3e,GACnBA,EAAK2e,eACT,CACA,SAAST,GAAkBle,GACvBA,EAAKke,mBACT,CACA,SAASC,GAAmBne,GACxBA,EAAKyX,eAAgB,CACzB,CACA,SAAS2G,GAAoBpe,GACzB,MAAM,cAAEyC,GAAkBzC,EAAK0C,QAC3BD,GAAiBA,EAAckL,WAAW+X,uBAC1CjjB,EAAciZ,OAAO,uBAEzB1b,EAAKuZ,gBACT,CACA,SAAS0C,GAAgBjc,GACrBA,EAAKic,kBACLjc,EAAKwgB,YAAcxgB,EAAKuc,eAAiBvc,EAAKsE,YAAS7C,EACvDzB,EAAK2Z,mBAAoB,CAC7B,CACA,SAASkB,GAAmB7a,GACxBA,EAAK6a,oBACT,CACA,SAASC,GAAe9a,GACpBA,EAAK8a,gBACT,CACA,SAAS6C,GAAqB3d,GAC1BA,EAAK2d,sBACT,CACA,SAASiB,GAAoBlN,GACzBA,EAAMoG,oBACV,CACA,SAASyK,GAAaH,EAAQ9f,EAAO0S,GACjCoN,EAAO7gB,WAAY,OAAUe,EAAMf,UAAW,EAAGyT,GACjDoN,EAAOhhB,OAAQ,OAAUkB,EAAMlB,MAAO,EAAG4T,GACzCoN,EAAOxd,OAAStC,EAAMsC,OACtBwd,EAAO/gB,YAAciB,EAAMjB,WAC/B,CACA,SAASmhB,GAAQJ,EAAQC,EAAMC,EAAItN,GAC/BoN,EAAO1hB,KAAM,OAAU2hB,EAAK3hB,IAAK4hB,EAAG5hB,IAAKsU,GACzCoN,EAAOzhB,KAAM,OAAU0hB,EAAK1hB,IAAK2hB,EAAG3hB,IAAKqU,EAC7C,CAKA,SAASiN,GAAoBjiB,GACzB,OAAQA,EAAKuX,sBAAwD9V,IAArCzB,EAAKuX,gBAAgBoL,WACzD,CACA,MAAMjG,GAA0B,CAC5BiJ,SAAU,IACVC,KAAM,CAAC,GAAK,EAAG,GAAK,IAElBC,GAAqBC,GAAgC,oBAAdC,WACzCA,UAAUC,WACVD,UAAUC,UAAUC,cAAcC,SAASJ,GAMzCK,GAAaN,GAAkB,kBAAoBA,GAAkB,WACrErhB,KAAK+R,MACLzB,EAAA,EACN,SAASgL,GAAUne,GAEfA,EAAKjB,IAAMylB,GAAWxkB,EAAKjB,KAC3BiB,EAAKhB,IAAMwlB,GAAWxkB,EAAKhB,IAC/B,CAKA,SAASyiB,GAA0BC,EAAe/L,EAAUlS,GACxD,MAA0B,aAAlBie,GACe,oBAAlBA,KACI,SAAO5M,GAAYa,GAAWb,GAAYrR,GAAS,GAChE,CACA,SAAS6a,GAAuBjgB,GAC5B,IAAIwJ,EACJ,OAAOxJ,IAASA,EAAKgD,OAAgC,QAAtBwG,EAAKxJ,EAAK+C,cAA2B,IAAPyG,OAAgB,EAASA,EAAG8V,QAC7F,C,eGziDA,MAAM8G,GAAyBlN,GAAqB,CAChDC,qBAAsB,CAACkN,EAAK3K,KAAW,QAAY2K,EAAK,SAAU3K,GAClErC,cAAe,KAAM,CACjB5Y,EAAG6lB,SAASC,gBAAgBC,YAAcF,SAASG,KAAKD,WACxD5lB,EAAG0lB,SAASC,gBAAgBG,WAAaJ,SAASG,KAAKC,YAE3DpN,kBAAmB,KAAM,ICNvB3S,GAAqB,CACvBmV,aAASra,GAEPklB,GAAqBzN,GAAqB,CAC5CG,cAAgB9S,IAAa,CACzB9F,EAAG8F,EAASigB,WACZ5lB,EAAG2F,EAASmgB,YAEhBtN,cAAe,KACX,IAAKzS,GAAmBmV,QAAS,CAC7B,MAAM8K,EAAe,IAAIR,GAAuB,CAAC,GACjDQ,EAAa9Y,MAAMsK,QACnBwO,EAAa1V,WAAW,CAAEpO,cAAc,IACxC6D,GAAmBmV,QAAU8K,CACjC,CACA,OAAOjgB,GAAmBmV,OAAO,EAErCvC,eAAgB,CAAChT,EAAUlC,KACvBkC,EAAS3D,MAAMc,eAAsBjC,IAAV4C,EAAsBA,EAAQ,MAAM,EAEnEiV,kBAAoB/S,GAAagG,QAAuD,UAA/C6L,OAAOyO,iBAAiBtgB,GAAUugB,YClBzE,GAAO,CACTC,IAAK,CACDjnB,QAAS,KAEbuR,KAAM,CACFvR,QAAS,IACTknB,eAAgBL,GAChBpU,cAAa,I,oCCPrB,MAAM0U,GAAoB,IAAIC,QAMxBC,GAAY,IAAID,QAChBE,GAAwBC,IAC1B,MAAM5hB,EAAWwhB,GAAkB7f,IAAIigB,EAAM/iB,QAC7CmB,GAAYA,EAAS4hB,EAAM,EAEzBC,GAA4BC,IAC9BA,EAAQpb,QAAQib,GAAqB,EAqBzC,SAASI,GAAoB9gB,EAAShE,EAAS+C,GAC3C,MAAMgiB,EApBV,UAAkC,KAAEzkB,KAASN,IACzC,MAAMglB,EAAa1kB,GAAQsjB,SAItBa,GAAU5f,IAAImgB,IACfP,GAAU3f,IAAIkgB,EAAY,CAAC,GAE/B,MAAMC,EAAgBR,GAAU/f,IAAIsgB,GAC9BpgB,EAAMsgB,KAAKC,UAAUnlB,GAQ3B,OAHKilB,EAAcrgB,KACfqgB,EAAcrgB,GAAO,IAAIwgB,qBAAqBR,GAA0B,CAAEtkB,UAASN,KAEhFilB,EAAcrgB,EACzB,CAEsCygB,CAAyBrlB,GAG3D,OAFAukB,GAAkBzf,IAAId,EAASjB,GAC/BgiB,EAA0BO,QAAQthB,GAC3B,KACHugB,GAAkB1b,OAAO7E,GACzB+gB,EAA0BQ,UAAUvhB,EAAQ,CAEpD,CC3CA,MAAMwhB,GAAiB,CACnBlI,KAAM,EACNnX,IAAK,GAET,MAAMsf,WAAsBroB,EAAA,EACxB,WAAAC,GACI0N,SAASY,WACTpO,KAAKmoB,gBAAiB,EACtBnoB,KAAKooB,UAAW,CACpB,CACA,aAAAC,GACIroB,KAAKgO,UACL,MAAM,SAAEsa,EAAW,CAAC,GAAMtoB,KAAKD,KAAK2N,YAC9B,KAAE3K,EAAMwlB,OAAQC,EAAU,OAAEC,EAAS,OAAM,KAAEC,GAASJ,EACtD7lB,EAAU,CACZM,KAAMA,EAAOA,EAAK8Y,aAAUra,EAC5BgnB,aACAG,UAA6B,iBAAXF,EAAsBA,EAASR,GAAeQ,IA+BpE,OAAOlB,GAAoBvnB,KAAKD,KAAK8b,QAASpZ,GA7BhB2kB,IAC1B,MAAM,eAAEwB,GAAmBxB,EAI3B,GAAIpnB,KAAKooB,WAAaQ,EAClB,OAMJ,GALA5oB,KAAKooB,SAAWQ,EAKZF,IAASE,GAAkB5oB,KAAKmoB,eAChC,OAEKS,IACL5oB,KAAKmoB,gBAAiB,GAEtBnoB,KAAKD,KAAK4M,gBACV3M,KAAKD,KAAK4M,eAAeH,UAAU,cAAeoc,GAMtD,MAAM,gBAAEC,EAAe,gBAAEC,GAAoB9oB,KAAKD,KAAK2N,WACjDlI,EAAWojB,EAAiBC,EAAkBC,EACpDtjB,GAAYA,EAAS4hB,EAAM,GAGnC,CACA,KAAAvZ,GACI7N,KAAKqoB,eACT,CACA,MAAAnoB,GACI,GAAoC,oBAAzB2nB,qBACP,OACJ,MAAM,MAAEnlB,EAAK,UAAEqL,GAAc/N,KAAKD,KACR,CAAC,SAAU,SAAU,QAAQggB,KAO/D,UAAkC,SAAEuI,EAAW,CAAC,IAAOA,SAAUS,EAAe,CAAC,GAAM,CAAC,GACpF,OAAQ5gB,GAASmgB,EAASngB,KAAU4gB,EAAa5gB,EACrD,CAToE6gB,CAAyBtmB,EAAOqL,KAExF/N,KAAKqoB,eAEb,CACA,OAAAra,GAAY,EC5DhB,MAAMib,GAAoB,CACtBC,OAAQ,CACJrpB,QAASqoB,IAEbiB,IAAK,CACDtpB,QAAS,MAEbupB,MAAO,CACHvpB,QAAS,MAEbwpB,MAAO,CACHxpB,QAAS,OCbXsF,GAAS,CACXA,OAAQ,CACJ4hB,eAAgBL,GAChBpU,cAAa,I,0DCNrB,MAAMgX,GAAe,CACjBxgB,UAAW,CACP,UACA,WACA,aACA,WACA,OACA,cACA,aACA,aAEJwE,KAAM,CAAC,QACP8D,KAAM,CAAC,OAAQ,gBACfgY,MAAO,CAAC,cACRC,MAAO,CAAC,aAAc,eAAgB,cACtCF,IAAK,CAAC,WAAY,QAAS,aAAc,eACzCrC,IAAK,CAAC,QAAS,aAAc,oBAAqB,YAClDoC,OAAQ,CAAC,cAAe,kBAAmB,mBAC3C/jB,OAAQ,CAAC,SAAU,aAEjBokB,GAAqB,CAAC,EAC5B,IAAK,MAAMliB,KAAOiiB,GACdC,GAAmBliB,GAAO,CACtBmiB,UAAY9mB,GAAU4mB,GAAajiB,GAAK0Y,MAAM5X,KAAWzF,EAAMyF,MCvBvE,MAAMshB,GAAwBC,OAAOC,IAAI,yB,eCOzC,SAASC,GAAaC,EAAarnB,EAAesnB,GAC9C,OAAO,IAAAC,cAAazjB,IACZA,GACAujB,EAAYG,SAAWH,EAAYG,QAAQ1jB,GAE3C9D,IACI8D,EACA9D,EAAcqL,MAAMvH,GAGpB9D,EAAcwL,WAGlB8b,IAC2B,mBAAhBA,EACPA,EAAYxjB,IAEP,QAAYwjB,KACjBA,EAAYjO,QAAUvV,GAE9B,GAOJ,CAAC9D,GACL,C,qCCxBA,SAASynB,GAAiB9Z,EAAW0Z,EAAannB,EAAOwnB,EAAqBC,GAC1E,IAAI5gB,EAAIya,EACR,MAAQxhB,cAAewC,IAAW,IAAAuN,YAAW6X,GAAA,GACvCC,GAAc,IAAA9X,YAAW+X,GAAA,GACzB7gB,GAAkB,IAAA8I,YAAWgY,GAAA,GAC7BC,GAAsB,IAAAjY,YAAWkY,GAAA,GAAqBC,cACtDC,GAAmB,IAAAC,QAAO,MAIhCV,EAAsBA,GAAuBG,EAAYQ,UACpDF,EAAiB9O,SAAWqO,IAC7BS,EAAiB9O,QAAUqO,EAAoB/Z,EAAW,CACtD0Z,cACA7kB,SACAtC,QACA+G,kBACAqC,wBAAuBrC,IACW,IAA5BA,EAAgBvB,QAEtBsiB,yBAGR,MAAMhoB,EAAgBmoB,EAAiB9O,QAKjCiP,GAA2B,IAAAvY,YAAWI,EAAA,IACxCnQ,GACCA,EAAcgO,aACf2Z,GACwB,SAAvB3nB,EAAc4G,MAA0C,QAAvB5G,EAAc4G,MA2DxD,SAA8B5G,EAAeE,EAAOynB,EAA2B3G,GAC3E,MAAM,SAAEjT,EAAQ,OAAEpL,EAAM,KAAEiM,EAAI,gBAAE2Z,EAAe,aAAEloB,EAAY,WAAEka,GAAgBra,EAC/EF,EAAcgO,WAAa,IAAI2Z,EAA0B3nB,EAAcU,aAAcR,EAAM,8BACrFlB,EACAwpB,GAAyBxoB,EAAcwC,SAC7CxC,EAAcgO,WAAWS,WAAW,CAChCV,WACApL,SACA2Z,oBAAqBxS,QAAQ8E,IAAU2Z,IAAmB,QAAYA,GACtEvoB,gBAQA4gB,cAAiC,iBAAXje,EAAsBA,EAAS,OACrDqe,yBACA3gB,eACAka,cAER,CAhFQ,CAAqB4N,EAAiB9O,QAASnZ,EAAOynB,EAA2BW,GAErF,MAAM7qB,GAAY,IAAA2qB,SAAO,IACzB,IAAAK,qBAAmB,KAKXzoB,GAAiBvC,EAAU4b,SAC3BrZ,EAActC,OAAOwC,EAAO+G,EAChC,IAMJ,MAAMyhB,EAAoBxoB,EAAM,MAC1ByoB,GAAe,IAAAP,QAAOte,QAAQ4e,MACY,QAAzC3hB,EAAK4O,OAAOiT,+BAA4C,IAAP7hB,OAAgB,EAASA,EAAG0E,KAAKkK,OAAQ+S,MAC9C,QAA7ClH,EAAK7L,OAAOY,mCAAgD,IAAPiL,OAAgB,EAASA,EAAG/V,KAAKkK,OAAQ+S,KAqCpG,OApCA,SAA0B,KACjB1oB,IAELvC,EAAU4b,SAAU,EACpB1D,OAAOkT,iBAAkB,EACzB7oB,EAAc8oB,iBACdzZ,EAAA,EAAUQ,OAAO7P,EAAc6P,QAW3B8Y,EAAatP,SAAWrZ,EAAcmK,gBACtCnK,EAAcmK,eAAe9C,iBACjC,KAEJ,IAAA0hB,YAAU,KACD/oB,KAEA2oB,EAAatP,SAAWrZ,EAAcmK,gBACvCnK,EAAcmK,eAAe9C,iBAE7BshB,EAAatP,UAEb2P,gBAAe,KACX,IAAIjiB,EAC0C,QAA7CA,EAAK4O,OAAOsT,mCAAgD,IAAPliB,GAAyBA,EAAG0E,KAAKkK,OAAQ+S,EAAkB,IAErHC,EAAatP,SAAU,GAC3B,IAEGrZ,CACX,CAwBA,SAASwoB,GAAyBxoB,GAC9B,GAAKA,EAEL,OAAiD,IAA1CA,EAAcC,QAAQipB,gBACvBlpB,EAAcgO,WACdwa,GAAyBxoB,EAAcwC,OACjD,CC1GA,SAAS2mB,IAA8B,kBAAEC,EAAiB,oBAAE1B,EAAmB,UAAE2B,EAAS,eAAEC,EAAc,UAAE3b,IACxG,IAAI5G,EAAIya,EAER,SAAS+H,EAAgBrpB,EAAOonB,GAK5B,IAAIxX,EACJ,MAAM0Z,EAAiB,KAChB,IAAAzZ,YAAWkY,GAAA,MACX/nB,EACH6N,SAAU0b,GAAYvpB,KAEpB,SAAEwpB,GAAaF,EACf/jB,GAAU,QAAuBvF,GACjCmnB,EAAciC,EAAeppB,EAAOwpB,GAC1C,IAAKA,GAAY,KAAW,EA+BpC,YACqB,IAAA3Z,YAAW+X,GAAA,GAAa6B,OAKrC,CAQR,CA5CYC,GACA,MAAMC,EA4ClB,SAAoC3pB,GAChC,MAAM,KAAE0O,EAAI,OAAEjM,GAAWokB,GACzB,IAAKnY,IAASjM,EACV,MAAO,CAAC,EACZ,MAAMmnB,EAAW,IAAKlb,KAASjM,GAC/B,MAAO,CACHmN,eAAgBlB,aAAmC,EAASA,EAAKoY,UAAU9mB,MAAYyC,aAAuC,EAASA,EAAOqkB,UAAU9mB,IAClJ4pB,EAASha,mBACT9Q,EACNulB,eAAgBuF,EAASvF,eAEjC,CAvDqCwF,CAA2BP,GACpD1Z,EAAgB+Z,EAAiB/Z,cAOjCrK,EAAQzF,cAAgBynB,GAAiB9Z,EAAW0Z,EAAamC,EAAgB9B,EAAqBmC,EAAiBtF,eAC3H,CAKA,OAAQ,IAAAyF,MAAKpC,GAAA,EAAcqC,SAAU,CAAEroB,MAAO6D,EAASuL,SAAU,CAAClB,GAAiBrK,EAAQzF,eAAiB,IAAAkQ,KAAIJ,EAAe,CAAE9P,cAAeyF,EAAQzF,iBAAkBwpB,IAAqB,KAAMH,EAAU1b,EAAWzN,EAAOknB,GAAaC,EAAa5hB,EAAQzF,cAAesnB,GAAcD,EAAaqC,EAAUjkB,EAAQzF,iBACnU,CAhCAopB,GCzBJ,SAAsBc,GAClB,IAAK,MAAMrlB,KAAOqlB,EACdnD,GAAmBliB,GAAO,IACnBkiB,GAAmBliB,MACnBqlB,EAASrlB,GAGxB,CDkByBslB,CAAaf,GAiClCG,EAAgBa,YAAc,UAA+B,iBAAdzc,EACzCA,EACA,UAAkG,QAAvF6T,EAAsC,QAAhCza,EAAK4G,EAAUyc,mBAAgC,IAAPrjB,EAAgBA,EAAK4G,EAAUhI,YAAyB,IAAP6b,EAAgBA,EAAK,QACrI,MAAM6I,GAA4B,IAAAC,YAAWf,GAE7C,OADAc,EAA0BpD,IAAyBtZ,EAC5C0c,CACX,CACA,SAASZ,IAAY,SAAE1b,IACnB,MAAMwc,GAAgB,IAAAxa,YAAWC,EAAAC,GAAoBvE,GACrD,OAAO6e,QAA8BvrB,IAAb+O,EAClBwc,EAAgB,IAAMxc,EACtBA,CACV,CEpEA,MAAMyc,GAAuB,CACzB,UACA,SACA,OACA,OACA,UACA,IACA,QACA,OACA,SACA,SACA,OACA,WACA,OACA,UACA,UACA,WACA,OACA,OACA,SACA,SACA,MACA,OACA,QACA,MACA,QC3BJ,SAASC,GAAe9c,GACpB,MAKqB,iBAAdA,IAIHA,EAAU8V,SAAS,SAOvB+G,GAAqBE,QAAQ/c,IAAc,GAIvC,SAASd,KAAKc,GAItB,C,oCCFA,MAAMgd,GAAsB5J,GAAW,CAAC7gB,EAAOwpB,KAC3C,MAAMjkB,GAAU,IAAAsK,YAAW6X,GAAA,GACrB3gB,GAAkB,IAAA8I,YAAWgY,GAAA,GAC7B6C,EAAO,IAnBjB,UAAmB,4BAAEC,EAA2B,kBAAEC,EAAiB,SAAEtK,GAAatgB,EAAOuF,EAASwB,GAC9F,MAAMT,EAAQ,CACV9F,aAAcqqB,GAAiB7qB,EAAOuF,EAASwB,EAAiB4jB,GAChEG,YAAaF,KAWjB,OATItK,IAMAha,EAAMghB,QAAW1jB,GAAa0c,EAAS,CAAEtgB,QAAOmZ,QAASvV,KAAa0C,IACtEA,EAAMga,SAAYxgB,GAAkBwgB,EAASxgB,IAE1CwG,CACX,CAIuBykB,CAAUlK,EAAQ7gB,EAAOuF,EAASwB,GACrD,OAAOyiB,EAAWkB,KAAS,QAAYA,EAAK,EAEhD,SAASG,GAAiB7qB,EAAOuF,EAASwB,EAAiBikB,GACvD,MAAM9nB,EAAS,CAAC,EACV+nB,EAAeD,EAAmBhrB,EAAO,CAAC,GAChD,IAAK,MAAM2E,KAAOsmB,EACd/nB,EAAOyB,IAAO,QAAmBsmB,EAAatmB,IAElD,IAAI,QAAEa,EAAO,QAAEO,GAAY/F,EAC3B,MAAMkrB,GAA0B,QAAsBlrB,GAChDmrB,GAAkB,QAAcnrB,GAClCuF,GACA4lB,IACCD,IACiB,IAAlBlrB,EAAMorB,eACUtsB,IAAZ0G,IACAA,EAAUD,EAAQC,cACN1G,IAAZiH,IACAA,EAAUR,EAAQQ,UAE1B,IAAIslB,IAA4BtkB,IACE,IAA5BA,EAAgBvB,QAEtB6lB,EAA4BA,IAAyC,IAAZ7lB,EACzD,MAAM8lB,EAAeD,EAA4BtlB,EAAUP,EAC3D,GAAI8lB,GACwB,kBAAjBA,KACN,OAAoBA,GAAe,CACpC,MAAMC,EAAOtmB,MAAMC,QAAQomB,GAAgBA,EAAe,CAACA,GAC3D,IAAK,IAAI1rB,EAAI,EAAGA,EAAI2rB,EAAK7rB,OAAQE,IAAK,CAClC,MAAMkH,GAAW,QAAwB9G,EAAOurB,EAAK3rB,IACrD,GAAIkH,EAAU,CACV,MAAM,cAAEI,EAAa,WAAED,KAAetF,GAAWmF,EACjD,IAAK,MAAMnC,KAAOhD,EAAQ,CACtB,IAAI6pB,EAAc7pB,EAAOgD,GACzB,GAAIM,MAAMC,QAAQsmB,GAAc,CAQ5BA,EAAcA,EAHAH,EACRG,EAAY9rB,OAAS,EACrB,EAEV,CACoB,OAAhB8rB,IACAtoB,EAAOyB,GAAO6mB,EAEtB,CACA,IAAK,MAAM7mB,KAAOuC,EACdhE,EAAOyB,GAAOuC,EAAcvC,EAEpC,CACJ,CACJ,CACA,OAAOzB,CACX,C,yBClFA,MAAMuoB,GAAiB,CAAC/pB,EAAOgF,IACpBA,GAAyB,iBAAVhF,EAChBgF,EAAK3F,UAAUW,GACfA,E,eCFV,MAAMgqB,GAAiB,CACnB5tB,EAAG,aACHG,EAAG,aACHmF,EAAG,aACH2e,qBAAsB,eAEpB4J,GAAgB,KAAmBjsB,OCJzC,SAASksB,GAAgBtlB,EAAO9F,EAAc0a,GAC1C,MAAM,MAAEjb,EAAK,KAAE4rB,EAAI,gBAAE1J,GAAoB7b,EAEzC,IAAIrD,GAAe,EACf6oB,GAAqB,EAOzB,IAAK,MAAMnnB,KAAOnE,EAAc,CAC5B,MAAMkB,EAAQlB,EAAamE,GAC3B,GAAI,KAAeC,IAAID,GAEnB1B,GAAe,OAGd,IAAI,QAAkB0B,GACvBknB,EAAKlnB,GAAOjD,MAGX,CAED,MAAMqqB,EAAcN,GAAe/pB,EAAO,KAAiBiD,IACvDA,EAAIqnB,WAAW,WAEfF,GAAqB,EACrB3J,EAAgBxd,GACZonB,GAGJ9rB,EAAM0E,GAAOonB,CAErB,CACJ,CAiBA,GAhBKvrB,EAAaO,YACVkC,GAAgBiY,EAChBjb,EAAMc,UD3BlB,SAAwBP,EAAcO,EAAWma,GAE7C,IAAI+Q,EAAkB,GAClBC,GAAqB,EAKzB,IAAK,IAAItsB,EAAI,EAAGA,EAAI+rB,GAAe/rB,IAAK,CACpC,MAAM+E,EAAM,KAAmB/E,GACzB8B,EAAQlB,EAAamE,GAC3B,QAAc7F,IAAV4C,EACA,SACJ,IAAIyqB,GAAiB,EAOrB,GALIA,EADiB,iBAAVzqB,EACUA,KAAWiD,EAAIqnB,WAAW,SAAW,EAAI,GAGnB,IAAtBpf,WAAWlL,IAE3ByqB,GAAkBjR,EAAmB,CACtC,MAAM6Q,EAAcN,GAAe/pB,EAAO,KAAiBiD,IACtDwnB,IACDD,GAAqB,EAErBD,GAAmB,GADGP,GAAe/mB,IAAQA,KACNonB,OAEvC7Q,IACAna,EAAU4D,GAAOonB,EAEzB,CACJ,CAUA,OATAE,EAAkBA,EAAgBG,OAG9BlR,EACA+Q,EAAkB/Q,EAAkBna,EAAWmrB,EAAqB,GAAKD,GAEpEC,IACLD,EAAkB,QAEfA,CACX,CCf8BI,CAAe7rB,EAAc8F,EAAMvF,UAAWma,GAE3Djb,EAAMc,YAKXd,EAAMc,UAAY,SAOtB+qB,EAAoB,CACpB,MAAM,QAAE7qB,EAAU,MAAK,QAAEE,EAAU,MAAK,QAAEmrB,EAAU,GAAOnK,EAC3DliB,EAAMkiB,gBAAkB,GAAGlhB,KAAWE,KAAWmrB,GACrD,CACJ,CC5DA,MAAMC,GAAW,CACbhsB,OAAQ,oBACRisB,MAAO,oBAELC,GAAY,CACdlsB,OAAQ,mBACRisB,MAAO,mBCNX,SAASE,GAAWzqB,EAAQ1B,EAAQ+I,GAChC,MAAyB,iBAAXrH,EACRA,EACA,EAAAyK,GAAG3L,UAAUR,EAAS+I,EAAOrH,EACvC,CCCA,SAAS0qB,GAAcrmB,GAAO,MAAEsmB,EAAK,MAAEC,EAAK,UAAEC,EAAS,QAAE7rB,EAAO,QAAEE,EAAO,WAAE4rB,EAAU,YAAEC,EAAc,EAAC,WAAEC,EAAa,KAElHxgB,GAAUygB,EAAUhS,GAMnB,GALA0Q,GAAgBtlB,EAAOmG,EAAQyO,GAK3BgS,EAIA,YAHI5mB,EAAMrG,MAAMktB,UACZ7mB,EAAM8mB,MAAMD,QAAU7mB,EAAMrG,MAAMktB,UAI1C7mB,EAAM8mB,MAAQ9mB,EAAMrG,MACpBqG,EAAMrG,MAAQ,CAAC,EACf,MAAM,MAAEmtB,EAAK,MAAEntB,EAAK,WAAEotB,GAAe/mB,EAKjC8mB,EAAMrsB,YACFssB,IACAptB,EAAMc,UAAYqsB,EAAMrsB,kBACrBqsB,EAAMrsB,WAGbssB,SACavuB,IAAZmC,QAAqCnC,IAAZqC,GAAyBlB,EAAMc,aACzDd,EAAMkiB,gBDzBd,SAAgCkL,EAAYpsB,EAASE,GAGjD,MAAO,GAFWurB,GAAWzrB,EAASosB,EAAWvvB,EAAGuvB,EAAWC,UAC7CZ,GAAWvrB,EAASksB,EAAWpvB,EAAGovB,EAAWE,SAEnE,CCqBgCC,CAAuBH,OAAwBvuB,IAAZmC,EAAwBA,EAAU,QAAiBnC,IAAZqC,EAAwBA,EAAU,UAG1HrC,IAAV8tB,IACAQ,EAAMtvB,EAAI8uB,QACA9tB,IAAV+tB,IACAO,EAAMnvB,EAAI4uB,QACI/tB,IAAdguB,IACAM,EAAM3uB,MAAQquB,QAEChuB,IAAfiuB,GF7BR,SAAsBK,EAAO1tB,EAAQ+tB,EAAU,EAAGltB,EAAS,EAAGmtB,GAAc,GAExEN,EAAML,WAAa,EAGnB,MAAMY,EAAOD,EAAcnB,GAAWE,GAEtCW,EAAMO,EAAKptB,QAAU,EAAAmM,GAAG3L,WAAWR,GAEnC,MAAMwsB,EAAa,EAAArgB,GAAG3L,UAAUrB,GAC1BstB,EAAc,EAAAtgB,GAAG3L,UAAU0sB,GACjCL,EAAMO,EAAKnB,OAAS,GAAGO,KAAcC,GACzC,CEkBQY,CAAaR,EAAOL,EAAYC,EAAaC,GAAY,EAEjE,CCjDA,MAAMY,GAAwB,KAAM,CAChC5tB,MAAO,CAAC,EACRc,UAAW,CAAC,EACZohB,gBAAiB,CAAC,EAClB0J,KAAM,CAAC,ICFLiC,GAAuB,KAAM,CDD/B7tB,MAAO,CAAC,EACRc,UAAW,CAAC,EACZohB,gBAAiB,CAAC,EAClB0J,KAAM,CAAC,ECAPuB,MAAO,CAAC,ICJNF,GAAYa,GAAuB,iBAARA,GAA0C,QAAtBA,EAAIzK,c,eCAzD,SAAS0K,GAAWjqB,GAAS,MAAE9D,EAAK,KAAE4rB,GAAQxK,EAAWvT,GACrDG,OAAOC,OAAOnK,EAAQ9D,MAAOA,EAAO6N,GAAcA,EAAWsT,oBAAoBC,IAEjF,IAAK,MAAM1c,KAAOknB,EACd9nB,EAAQ9D,MAAMguB,YAAYtpB,EAAKknB,EAAKlnB,GAE5C,CCHA,MAAMupB,GAAsB,IAAI5mB,IAAI,CAChC,gBACA,kBACA,eACA,mBACA,aACA,WACA,oBACA,eACA,cACA,aACA,UACA,UACA,eACA,mBACA,mBACA,eACA,cACA,UACA,oBACA,aACA,cACA,aACA,iBCtBJ,SAAS6mB,GAAUpqB,EAAS+mB,EAAasD,EAAYtgB,GACjDkgB,GAAWjqB,EAAS+mB,OAAahsB,EAAWgP,GAC5C,IAAK,MAAMnJ,KAAOmmB,EAAYsC,MAC1BrpB,EAAQsqB,aAAcH,GAAoBtpB,IAAID,GAA0BA,GAAnB,QAAYA,GAAYmmB,EAAYsC,MAAMzoB,GAEvG,C,eCNA,SAAS2pB,GAAoB3pB,GAAK,OAAElC,EAAM,SAAEoL,IACxC,OAAQ,KAAejJ,IAAID,IACvBA,EAAIqnB,WAAW,YACbvpB,QAAuB3D,IAAb+O,OACLN,EAAgB5I,IAAgB,YAARA,EACvC,CCLA,SAASgmB,GAA4B3qB,EAAOqL,EAAWvL,GACnD,IAAI+G,EACJ,MAAM,MAAE5G,GAAUD,EACZuuB,EAAY,CAAC,EACnB,IAAK,MAAM5pB,KAAO1E,IACV,QAAcA,EAAM0E,KACnB0G,EAAUpL,QACP,QAAcoL,EAAUpL,MAAM0E,KAClC2pB,GAAoB3pB,EAAK3E,SACgIlB,KAAnD,QAApG+H,EAAK/G,aAAqD,EAASA,EAAciJ,SAASpE,UAAyB,IAAPkC,OAAgB,EAASA,EAAGmC,cAC1IulB,EAAU5pB,GAAO1E,EAAM0E,IAG/B,OAAO4pB,CACX,CCbA,SAAS,GAA4BvuB,EAAOqL,EAAWvL,GACnD,MAAMyuB,EAAY5D,GAA8B3qB,EAAOqL,EAAWvL,GAClE,IAAK,MAAM6E,KAAO3E,EACd,IAAI,QAAcA,EAAM2E,MACpB,QAAc0G,EAAU1G,IAAO,CAI/B4pB,GAHuD,IAArC,KAAmB/D,QAAQ7lB,GACvC,OAASA,EAAI6pB,OAAO,GAAGC,cAAgB9pB,EAAI+pB,UAAU,GACrD/pB,GACiB3E,EAAM2E,EACjC,CAEJ,OAAO4pB,CACX,CCUA,MAAMI,GAAc,CAAC,IAAK,IAAK,QAAS,SAAU,KAAM,KAAM,KACxDC,GAAkB,CACpBxF,eAAgBqB,GAAmB,CAC/BE,4BAA6B,GAC7BC,kBAAmBkD,GACnBxN,SAAU,EAAGtgB,QAAOqL,YAAW8N,UAAS2R,cAAatqB,mBACjD,IAAK2Y,EACD,OACJ,IAAIlW,IAAiBjD,EAAM0O,KAC3B,IAAKzL,EACD,IAAK,MAAM0B,KAAOnE,EACd,GAAI,KAAeoE,IAAID,GAAM,CACzB1B,GAAe,EACf,KACJ,CAGR,IAAKA,EACD,OACJ,IAAI4rB,GAAgBxjB,EACpB,GAAIA,EAKA,IAAK,IAAIzL,EAAI,EAAGA,EAAI+uB,GAAYjvB,OAAQE,IAAK,CACzC,MAAM+E,EAAMgqB,GAAY/uB,GACpBI,EAAM2E,KACN0G,EAAU1G,KACVkqB,GAAe,EAEvB,CAECA,GAEL,KAAMrd,MAAK,MApDvB,SAA6B5N,EAAUknB,GACnC,IACIA,EAAYuC,WACoB,mBAArBzpB,EAASkrB,QACVlrB,EAASkrB,UACTlrB,EAASC,uBACvB,CACA,MAAOkrB,GAEHjE,EAAYuC,WAAa,CACrBvvB,EAAG,EACHG,EAAG,EACHqvB,MAAO,EACPC,OAAQ,EAEhB,CACJ,CAqCgByB,CAAoB7V,EAAS2R,GAC7B,KAAMnb,QAAO,KACTgd,GAAc7B,EAAatqB,EAAc0sB,GAAS/T,EAAQD,SAAUlZ,EAAMkb,mBAC1EiT,GAAUhV,EAAS2R,EAAY,GACjC,GACJ,KC/DRmE,GAAmB,CACrB7F,eAAgBqB,GAAmB,CAC/BE,4BAA2B,GAC3BC,kBAAmBiD,MCD3B,SAASqB,GAAkBvtB,EAAQK,EAAQhC,GACvC,IAAK,MAAM2E,KAAO3C,GACT,QAAcA,EAAO2C,KAAU2pB,GAAoB3pB,EAAK3E,KACzD2B,EAAOgD,GAAO3C,EAAO2C,GAGjC,CAQA,SAASwqB,GAASnvB,EAAOmnB,GACrB,MACMlnB,EAAQ,CAAC,EAMf,OAFAivB,GAAkBjvB,EALAD,EAAMC,OAAS,CAAC,EAKED,GACpCiO,OAAOC,OAAOjO,EAdlB,UAAgC,kBAAEib,GAAqBiM,GACnD,OAAO,IAAAiI,UAAQ,KACX,MAAM9oB,EXfsB,CAChCrG,MAAO,CAAC,EACRc,UAAW,CAAC,EACZohB,gBAAiB,CAAC,EAClB0J,KAAM,CAAC,GWaH,OADAD,GAAgBtlB,EAAO6gB,EAAajM,GAC7BjN,OAAOC,OAAO,CAAC,EAAG5H,EAAMulB,KAAMvlB,EAAMrG,MAAM,GAClD,CAACknB,GACR,CAQyBkI,CAAuBrvB,EAAOmnB,IAC5ClnB,CACX,CACA,SAASqvB,GAAatvB,EAAOmnB,GAEzB,MAAMoI,EAAY,CAAC,EACbtvB,EAAQkvB,GAASnvB,EAAOmnB,GAoB9B,OAnBInnB,EAAM0O,OAA+B,IAAvB1O,EAAMwvB,eAEpBD,EAAUE,WAAY,EAEtBxvB,EAAMyvB,WACFzvB,EAAM0vB,iBACF1vB,EAAM2vB,mBACF,OAEZ3vB,EAAM4vB,aACa,IAAf7vB,EAAM0O,KACA,OACA,QAAsB,MAAf1O,EAAM0O,KAAe,IAAM,WAEzB5P,IAAnBkB,EAAM8vB,WACL9vB,EAAM+vB,OAAS/vB,EAAMgwB,YAAchwB,EAAMyK,YAC1C8kB,EAAUO,SAAW,GAEzBP,EAAUtvB,MAAQA,EACXsvB,CACX,CChDA,MAAMU,GAAmB,IAAI3oB,IAAI,CAC7B,UACA,OACA,WACA,UACA,QACA,SACA,WACA,aACA,oBACA,SACA,UACA,wBACA,mBACA,sBACA,WACA,cACA,SACA,YACA,2BACA,kBACA,sBACA,SACA,SACA,eACA,aACA,kBACA,kBACA,kBACA,eACA,aAUJ,SAAS4oB,GAAkBvrB,GACvB,OAAQA,EAAIqnB,WAAW,UAClBrnB,EAAIqnB,WAAW,SAAmB,cAARrnB,GAC3BA,EAAIqnB,WAAW,WACfrnB,EAAIqnB,WAAW,UACfrnB,EAAIqnB,WAAW,UACfrnB,EAAIqnB,WAAW,aACfiE,GAAiBrrB,IAAID,EAC7B,CCpDA,IAAIwrB,GAAiBxrB,IAASurB,GAAkBvrB,GAoBhD,KAnBiCyrB,GAyBLC,QAAQ,0BAA0BC,WArB1DH,GAAiBxrB,GAAQA,EAAIqnB,WAAW,OAASkE,GAAkBvrB,GAAOyrB,GAAYzrB,GAsB1F,CACA,MAAOkC,GAEP,CA7BA,IAAiCupB,GCGjC,SAASG,GAAYvwB,EAAOmnB,EAAaqJ,EAAW/iB,GAChD,MAAMgjB,GAAc,IAAArB,UAAQ,KACxB,MAAM9oB,EbNqB,CDD/BrG,MAAO,CAAC,EACRc,UAAW,CAAC,EACZohB,gBAAiB,CAAC,EAClB0J,KAAM,CAAC,ECAPuB,MAAO,CAAC,GaMJ,OADAT,GAAcrmB,EAAO6gB,EAAa+F,GAASzf,GAAYzN,EAAMkb,mBACtD,IACA5U,EAAM8mB,MACTntB,MAAO,IAAKqG,EAAMrG,OACrB,GACF,CAACknB,IACJ,GAAInnB,EAAMC,MAAO,CACb,MAAMywB,EAAY,CAAC,EACnBxB,GAAkBwB,EAAW1wB,EAAMC,MAAOD,GAC1CywB,EAAYxwB,MAAQ,IAAKywB,KAAcD,EAAYxwB,MACvD,CACA,OAAOwwB,CACX,CCdA,SAASE,GAAgBC,GAAqB,GAsB1C,MArBkB,CAACnjB,EAAWzN,EAAO0jB,GAAOljB,gBAAgBgpB,KACxD,MAGMiH,GAHiBlG,GAAe9c,GAChC8iB,GACAjB,IAC6BtvB,EAAOQ,EAAcgpB,EAAU/b,GAC5DojB,EFoBd,SAAqB7wB,EAAO8wB,EAAOF,GAC/B,MAAMC,EAAgB,CAAC,EACvB,IAAK,MAAMlsB,KAAO3E,EAQF,WAAR2E,GAA4C,iBAAjB3E,EAAMkD,SAEjCitB,GAAcxrB,KACU,IAAvBisB,GAA+BV,GAAkBvrB,KAChDmsB,IAAUZ,GAAkBvrB,IAE7B3E,EAAiB,WACd2E,EAAIqnB,WAAW,aACnB6E,EAAclsB,GACV3E,EAAM2E,IAGlB,OAAOksB,CACX,CE3C8BE,CAAY/wB,EAA4B,iBAAdyN,EAAwBmjB,GAClEI,EAAevjB,IAAc,EAAAwjB,SAC7B,IAAKJ,KAAkBJ,EAAa/M,OACpC,CAAC,GAMD,SAAE5S,GAAa9Q,EACfkxB,GAAmB,IAAA9B,UAAQ,KAAO,QAActe,GAAYA,EAASrM,MAAQqM,GAAW,CAACA,IAC/F,OAAO,IAAAqgB,eAAc1jB,EAAW,IACzBujB,EACHlgB,SAAUogB,GACZ,CAGV,CCxBA,SAASE,GAA6BlI,EAAmB1B,GACrD,OAAO,SAA+B/Z,GAAW,mBAAEmjB,GAAuB,CAAEA,oBAAoB,IAW5F,OAAO3H,GAPQ,IAHIsB,GAAe9c,GAC5BmhB,GACAK,GAGF/F,oBACAC,UAAWwH,GAAgBC,GAC3BpJ,sBACA/Z,aAGR,CACJ,C,qCCnBA,MAAM4jB,GAAuB,CAAElY,QAAS,MAClCmY,GAA2B,CAAEnY,SAAS,G,2DCM5C,MAAMoY,GAAa,IAAI,KAAqBC,GAAA,EAAOxkB,EAAA,GCR7CykB,GAAqB,IAAIlN,Q,eCsB/B,MAAMmN,GAAoB,CACtB,iBACA,oBACA,SACA,sBACA,gBACA,uBACA,2BAMJ,MAAMC,GAQF,2BAAAhH,CAA4BiH,EAAQC,EAAYC,GAC5C,MAAO,CAAC,CACZ,CACA,WAAA10B,EAAY,OAAEkF,EAAM,MAAEtC,EAAK,gBAAE+G,EAAe,oBAAE+gB,EAAmB,sBAAE1e,EAAqB,YAAE+d,GAAgBpnB,EAAU,CAAC,GAKjHzC,KAAK6b,QAAU,KAIf7b,KAAKwT,SAAW,IAAIxJ,IAIpBhK,KAAKy0B,eAAgB,EACrBz0B,KAAKgI,uBAAwB,EAQ7BhI,KAAKod,mBAAqB,KAM1Bpd,KAAK4F,OAAS,IAAIqB,IAClBjH,KAAK00B,iBAAmB,KAIxB10B,KAAK0sB,SAAW,CAAC,EAKjB1sB,KAAK20B,mBAAqB,IAAI1tB,IAM9BjH,KAAK40B,iBAAmB,CAAC,EAIzB50B,KAAK60B,OAAS,CAAC,EAMf70B,KAAK80B,uBAAyB,CAAC,EAC/B90B,KAAK+0B,aAAe,IAAM/0B,KAAKyb,OAAO,SAAUzb,KAAKkD,cACrDlD,KAAKqS,OAAS,KACLrS,KAAK6b,UAEV7b,KAAKg1B,eACLh1B,KAAKi1B,eAAej1B,KAAK6b,QAAS7b,KAAKwtB,YAAaxtB,KAAK0C,MAAMC,MAAO3C,KAAKwQ,YAAW,EAE1FxQ,KAAKk1B,kBAAoB,EACzBl1B,KAAK2W,eAAiB,KAClB,MAAM7C,EAAM,IAAKA,MACb9T,KAAKk1B,kBAAoBphB,IACzB9T,KAAKk1B,kBAAoBphB,EACzB,KAAMzB,OAAOrS,KAAKqS,QAAQ,GAAO,GACrC,EAEJ,MAAM,aAAEnP,EAAY,YAAEsqB,EAAW,SAAExK,GAAa6G,EAChD7pB,KAAKgjB,SAAWA,EAChBhjB,KAAKkD,aAAeA,EACpBlD,KAAKm1B,WAAa,IAAKjyB,GACvBlD,KAAKo1B,cAAgB1yB,EAAMwF,QAAU,IAAKhF,GAAiB,CAAC,EAC5DlD,KAAKwtB,YAAcA,EACnBxtB,KAAKgF,OAASA,EACdhF,KAAK0C,MAAQA,EACb1C,KAAKyJ,gBAAkBA,EACvBzJ,KAAKsT,MAAQtO,EAASA,EAAOsO,MAAQ,EAAI,EACzCtT,KAAKwqB,oBAAsBA,EAC3BxqB,KAAKyC,QAAUA,EACfzC,KAAK8L,sBAAwBQ,QAAQR,GACrC9L,KAAKgI,uBAAwB,QAAsBtF,GACnD1C,KAAKy0B,eAAgB,QAAc/xB,GAC/B1C,KAAKy0B,gBACLz0B,KAAKyM,gBAAkB,IAAIzC,KAE/BhK,KAAKyK,uBAAyB6B,QAAQtH,GAAUA,EAAO6W,SAWvD,MAAM,WAAEwZ,KAAeC,GAAwBt1B,KAAKqtB,4BAA4B3qB,EAAO,CAAC,EAAG1C,MAC3F,IAAK,MAAMqH,KAAOiuB,EAAqB,CACnC,MAAMlxB,EAAQkxB,EAAoBjuB,QACR7F,IAAtB0B,EAAamE,KAAsB,QAAcjD,IACjDA,EAAMmD,IAAIrE,EAAamE,IAAM,EAErC,CACJ,CACA,KAAAwG,CAAMvH,GACFtG,KAAK6b,QAAUvV,EACf6tB,GAAmB5sB,IAAIjB,EAAUtG,MAC7BA,KAAKwQ,aAAexQ,KAAKwQ,WAAWlK,UACpCtG,KAAKwQ,WAAW3C,MAAMvH,GAEtBtG,KAAKgF,QAAUhF,KAAKy0B,gBAAkBz0B,KAAKgI,wBAC3ChI,KAAKu1B,sBAAwBv1B,KAAKgF,OAAOwwB,gBAAgBx1B,OAE7DA,KAAK4F,OAAOsG,SAAQ,CAAC9H,EAAOiD,IAAQrH,KAAKy1B,kBAAkBpuB,EAAKjD,KAC3D4vB,GAAyBnY,SChKtC,WAEI,GADAmY,GAAyBnY,SAAU,EAC9B,KAEL,GAAI1D,OAAOud,WAAY,CACnB,MAAMC,EAAmBxd,OAAOud,WAAW,4BACrCE,EAA8B,IAAO7B,GAAqBlY,QAAU8Z,EAAiBE,QAC3FF,EAAiBG,YAAYF,GAC7BA,GACJ,MAEI7B,GAAqBlY,SAAU,CAEvC,CDoJYka,GAEJ/1B,KAAKod,mBAC4B,UAA7Bpd,KAAKwqB,sBAE8B,WAA7BxqB,KAAKwqB,qBAEDuJ,GAAqBlY,SAI/B7b,KAAKgF,QACLhF,KAAKgF,OAAOwO,SAAS3H,IAAI7L,MAC7BA,KAAKE,OAAOF,KAAK0C,MAAO1C,KAAKyJ,gBACjC,CACA,OAAAuE,GACImmB,GAAmB7oB,OAAOtL,KAAK6b,SAC/B7b,KAAKwQ,YAAcxQ,KAAKwQ,WAAWxC,WACnC,QAAYhO,KAAK+0B,eACjB,QAAY/0B,KAAKqS,QACjBrS,KAAK20B,mBAAmBzoB,SAASiG,GAAWA,MAC5CnS,KAAK20B,mBAAmB1P,QACxBjlB,KAAKu1B,uBAAyBv1B,KAAKu1B,wBACnCv1B,KAAKgF,QAAUhF,KAAKgF,OAAOwO,SAASlI,OAAOtL,MAC3C,IAAK,MAAMqH,KAAOrH,KAAK60B,OACnB70B,KAAK60B,OAAOxtB,GAAK4d,QAErB,IAAK,MAAM5d,KAAOrH,KAAK0sB,SAAU,CAC7B,MAAMsJ,EAAUh2B,KAAK0sB,SAASrlB,GAC1B2uB,IACAA,EAAQhoB,UACRgoB,EAAQ/1B,WAAY,EAE5B,CACAD,KAAK6b,QAAU,IACnB,CACA,iBAAA4Z,CAAkBpuB,EAAKjD,GACfpE,KAAK20B,mBAAmBrtB,IAAID,IAC5BrH,KAAK20B,mBAAmBxtB,IAAIE,EAA5BrH,GAEJ,MAAMi2B,EAAmB,KAAe3uB,IAAID,GACtC6uB,EAAiB9xB,EAAM+xB,GAAG,UAAWC,IACvCp2B,KAAKkD,aAAamE,GAAO+uB,EACzBp2B,KAAK0C,MAAMsgB,UAAY,KAAMvE,UAAUze,KAAK+0B,cACxCkB,GAAoBj2B,KAAKwQ,aACzBxQ,KAAKwQ,WAAWoJ,kBAAmB,EACvC,IAEEyc,EAAwBjyB,EAAM+xB,GAAG,gBAAiBn2B,KAAK2W,gBAC7D,IAAI2f,EACAne,OAAOoe,wBACPD,EAAkBne,OAAOoe,sBAAsBv2B,KAAMqH,EAAKjD,IAE9DpE,KAAK20B,mBAAmBptB,IAAIF,GAAK,KAC7B6uB,IACAG,IACIC,GACAA,IACAlyB,EAAMoyB,OACNpyB,EAAM2e,MAAM,GAExB,CACA,gBAAA0T,CAAiBC,GAIb,OAAK12B,KAAK6b,SACL7b,KAAK22B,0BACN32B,KAAKoJ,OAASstB,EAAMttB,KAGjBpJ,KAAK22B,yBAAyB32B,KAAK6b,QAAS6a,EAAM7a,SAF9C,CAGf,CACA,cAAAyP,GACI,IAAIjkB,EAAM,YACV,IAAKA,KAAOkiB,GAAoB,CAC5B,MAAMqN,EAAoBrN,GAAmBliB,GAC7C,IAAKuvB,EACD,SACJ,MAAM,UAAEpN,EAAW3pB,QAASg3B,GAAuBD,EAYnD,IARK52B,KAAK0sB,SAASrlB,IACfwvB,GACArN,EAAUxpB,KAAK0C,SACf1C,KAAK0sB,SAASrlB,GAAO,IAAIwvB,EAAmB72B,OAK5CA,KAAK0sB,SAASrlB,GAAM,CACpB,MAAM2uB,EAAUh2B,KAAK0sB,SAASrlB,GAC1B2uB,EAAQ/1B,UACR+1B,EAAQ91B,UAGR81B,EAAQnoB,QACRmoB,EAAQ/1B,WAAY,EAE5B,CACJ,CACJ,CACA,YAAA+0B,GACIh1B,KAAK82B,MAAM92B,KAAKwtB,YAAaxtB,KAAKkD,aAAclD,KAAK0C,MACzD,CAMA,kBAAA2D,GACI,OAAOrG,KAAK6b,QACN7b,KAAK+2B,2BAA2B/2B,KAAK6b,QAAS7b,KAAK0C,QACnD,UACV,CACA,cAAAs0B,CAAe3vB,GACX,OAAOrH,KAAKkD,aAAamE,EAC7B,CACA,cAAAqR,CAAerR,EAAKjD,GAChBpE,KAAKkD,aAAamE,GAAOjD,CAC7B,CAKA,MAAAlE,CAAOwC,EAAO+G,IACN/G,EAAMkb,mBAAqB5d,KAAK0C,MAAMkb,oBACtC5d,KAAK2W,iBAET3W,KAAK+N,UAAY/N,KAAK0C,MACtB1C,KAAK0C,MAAQA,EACb1C,KAAKwO,oBAAsBxO,KAAKyJ,gBAChCzJ,KAAKyJ,gBAAkBA,EAIvB,IAAK,IAAInH,EAAI,EAAGA,EAAI8xB,GAAkBhyB,OAAQE,IAAK,CAC/C,MAAM+E,EAAM+sB,GAAkB9xB,GAC1BtC,KAAK80B,uBAAuBztB,KAC5BrH,KAAK80B,uBAAuBztB,YACrBrH,KAAK80B,uBAAuBztB,IAEvC,MACM4vB,EAAWv0B,EADK,KAAO2E,GAEzB4vB,IACAj3B,KAAK80B,uBAAuBztB,GAAOrH,KAAKm2B,GAAG9uB,EAAK4vB,GAExD,CACAj3B,KAAK40B,iBErTb,SAAqCnuB,EAASgB,EAAMC,GAChD,IAAK,MAAML,KAAOI,EAAM,CACpB,MAAMyvB,EAAYzvB,EAAKJ,GACjB8vB,EAAYzvB,EAAKL,GACvB,IAAI,QAAc6vB,GAKdzwB,EAAQ2wB,SAAS/vB,EAAK6vB,QASrB,IAAI,QAAcC,GAKnB1wB,EAAQ2wB,SAAS/vB,GAAK,SAAY6vB,EAAW,CAAEV,MAAO/vB,UAErD,GAAI0wB,IAAcD,EAMnB,GAAIzwB,EAAQ4wB,SAAShwB,GAAM,CACvB,MAAMiwB,EAAgB7wB,EAAQgF,SAASpE,IACP,IAA5BiwB,EAAc5rB,UACd4rB,EAAcC,KAAKL,GAEbI,EAAcE,aACpBF,EAAc/vB,IAAI2vB,EAE1B,KACK,CACD,MAAMd,EAAc3vB,EAAQuwB,eAAe3vB,GAC3CZ,EAAQ2wB,SAAS/vB,GAAK,cAA4B7F,IAAhB40B,EAA4BA,EAAcc,EAAW,CAAEV,MAAO/vB,IACpG,CAER,CAEA,IAAK,MAAMY,KAAOK,OACIlG,IAAdiG,EAAKJ,IACLZ,EAAQgxB,YAAYpwB,GAE5B,OAAOI,CACX,CFiQgCiwB,CAA4B13B,KAAMA,KAAKqtB,4BAA4B3qB,EAAO1C,KAAK+N,UAAW/N,MAAOA,KAAK40B,kBAC1H50B,KAAK23B,wBACL33B,KAAK23B,yBAET33B,KAAKgjB,UAAYhjB,KAAKgjB,SAAShjB,KACnC,CACA,QAAA0N,GACI,OAAO1N,KAAK0C,KAChB,CAIA,UAAAk1B,CAAWzvB,GACP,OAAOnI,KAAK0C,MAAMm1B,SAAW73B,KAAK0C,MAAMm1B,SAAS1vB,QAAQ3G,CAC7D,CAIA,oBAAAgb,GACI,OAAOxc,KAAK0C,MAAMiH,UACtB,CACA,qBAAAmuB,GACI,OAAO93B,KAAK0C,MAAMiE,kBACtB,CACA,qBAAAoxB,GACI,OAAO/3B,KAAKy0B,cACNz0B,KACAA,KAAKgF,OACDhF,KAAKgF,OAAO+yB,6BACZv2B,CACd,CAIA,eAAAg0B,CAAgB9oB,GACZ,MAAMsrB,EAAqBh4B,KAAK+3B,wBAChC,GAAIC,EAGA,OAFAA,EAAmBvrB,iBACfurB,EAAmBvrB,gBAAgBZ,IAAIa,GACpC,IAAMsrB,EAAmBvrB,gBAAgBnB,OAAOoB,EAE/D,CAIA,QAAA0qB,CAAS/vB,EAAKjD,GAEV,MAAMkzB,EAAgBt3B,KAAK4F,OAAOuB,IAAIE,GAClCjD,IAAUkzB,IACNA,GACAt3B,KAAKy3B,YAAYpwB,GACrBrH,KAAKy1B,kBAAkBpuB,EAAKjD,GAC5BpE,KAAK4F,OAAO2B,IAAIF,EAAKjD,GACrBpE,KAAKkD,aAAamE,GAAOjD,EAAM+C,MAEvC,CAIA,WAAAswB,CAAYpwB,GACRrH,KAAK4F,OAAO0F,OAAOjE,GACnB,MAAM4wB,EAAcj4B,KAAK20B,mBAAmBxtB,IAAIE,GAC5C4wB,IACAA,IACAj4B,KAAK20B,mBAAmBrpB,OAAOjE,WAE5BrH,KAAKkD,aAAamE,GACzBrH,KAAKk4B,2BAA2B7wB,EAAKrH,KAAKwtB,YAC9C,CAIA,QAAA6J,CAAShwB,GACL,OAAOrH,KAAK4F,OAAO0B,IAAID,EAC3B,CACA,QAAAoE,CAASpE,EAAK8wB,GACV,GAAIn4B,KAAK0C,MAAMkD,QAAU5F,KAAK0C,MAAMkD,OAAOyB,GACvC,OAAOrH,KAAK0C,MAAMkD,OAAOyB,GAE7B,IAAIjD,EAAQpE,KAAK4F,OAAOuB,IAAIE,GAK5B,YAJc7F,IAAV4C,QAAwC5C,IAAjB22B,IACvB/zB,GAAQ,SAA6B,OAAjB+zB,OAAwB32B,EAAY22B,EAAc,CAAE3B,MAAOx2B,OAC/EA,KAAKo3B,SAAS/vB,EAAKjD,IAEhBA,CACX,CAMA,SAAAg0B,CAAU/wB,EAAKhD,GACX,IAAIkF,EACJ,IAAInF,OAAmC5C,IAA3BxB,KAAKkD,aAAamE,IAAuBrH,KAAK6b,QAEI,QAAvDtS,EAAKvJ,KAAKq4B,uBAAuBr4B,KAAK0C,MAAO2E,UAAyB,IAAPkC,EAAgBA,EAAKvJ,KAAKs4B,sBAAsBt4B,KAAK6b,QAASxU,EAAKrH,KAAKyC,SADxIzC,KAAKkD,aAAamE,GF3YV,IAACkxB,EEwZf,OAXIn0B,UACqB,iBAAVA,KACN,KAAA9B,GAAkB8B,KAAU,QAAkBA,IAE/CA,EAAQkL,WAAWlL,IFjZZm0B,EEmZan0B,GFnZP6vB,GAAWuE,MAAK,EAAAnpB,GAAA,GAAckpB,KEmZb7oB,EAAA,EAAQL,KAAKhL,KAC3CD,GAAQ,QAAkBiD,EAAKhD,KAEnCrE,KAAKy4B,cAAcpxB,GAAK,QAAcjD,GAASA,EAAM+C,MAAQ/C,KAE1D,QAAcA,GAASA,EAAM+C,MAAQ/C,CAChD,CAKA,aAAAq0B,CAAcpxB,EAAKjD,GACfpE,KAAKm1B,WAAW9tB,GAAOjD,CAC3B,CAKA,aAAAgI,CAAc/E,GACV,IAAIkC,EACJ,MAAM,QAAErB,GAAYlI,KAAK0C,MACzB,IAAIg2B,EACJ,GAAuB,iBAAZxwB,GAA2C,iBAAZA,EAAsB,CAC5D,MAAMywB,GAAU,QAAwB34B,KAAK0C,MAAOwF,EAAyC,QAA/BqB,EAAKvJ,KAAKyJ,uBAAoC,IAAPF,OAAgB,EAASA,EAAGG,QAC7HivB,IACAD,EAAmBC,EAAQtxB,GAEnC,CAIA,GAAIa,QAAgC1G,IAArBk3B,EACX,OAAOA,EAMX,MAAMr0B,EAASrE,KAAKq4B,uBAAuBr4B,KAAK0C,MAAO2E,GACvD,YAAe7F,IAAX6C,IAAyB,QAAcA,QAMR7C,IAA5BxB,KAAKo1B,cAAc/tB,SACD7F,IAArBk3B,OACEl3B,EACAxB,KAAKm1B,WAAW9tB,GARXhD,CASf,CACA,EAAA8xB,CAAGyC,EAAWpzB,GAIV,OAHKxF,KAAK60B,OAAO+D,KACb54B,KAAK60B,OAAO+D,GAAa,IAAI,MAE1B54B,KAAK60B,OAAO+D,GAAW/sB,IAAIrG,EACtC,CACA,MAAAiW,CAAOmd,KAAc1xB,GACblH,KAAK60B,OAAO+D,IACZ54B,KAAK60B,OAAO+D,GAAWnd,UAAUvU,EAEzC,E,eGvdJ,MAAM2xB,WAAyBxE,GAC3B,WAAAv0B,GACI0N,SAASY,WACTpO,KAAK00B,iBAAmBoE,GAAA,CAC5B,CACA,wBAAAnC,CAAyBvjB,EAAGC,GAMxB,OAAsC,EAA/BD,EAAE2lB,wBAAwB1lB,GAAS,GAAK,CACnD,CACA,sBAAAglB,CAAuB31B,EAAO2E,GAC1B,OAAO3E,EAAMC,MACPD,EAAMC,MAAM0E,QACZ7F,CACV,CACA,0BAAA02B,CAA2B7wB,GAAK,KAAEknB,EAAI,MAAE5rB,WAC7B4rB,EAAKlnB,UACL1E,EAAM0E,EACjB,CACA,sBAAAswB,GACQ33B,KAAKg5B,oBACLh5B,KAAKg5B,2BACEh5B,KAAKg5B,mBAEhB,MAAM,SAAExlB,GAAaxT,KAAK0C,OACtB,QAAc8Q,KACdxT,KAAKg5B,kBAAoBxlB,EAAS2iB,GAAG,UAAWhnB,IACxCnP,KAAK6b,UACL7b,KAAK6b,QAAQod,YAAc,GAAG9pB,IAClC,IAGZ,E,eC3BJ,MAAM+pB,WAA0BL,GAC5B,WAAA/4B,GACI0N,SAASY,WACTpO,KAAKoJ,KAAO,OACZpJ,KAAKi1B,eAAiBvE,EAC1B,CACA,qBAAA4H,CAAsBhyB,EAAUe,GAC5B,GAAI,KAAeC,IAAID,GAAM,CACzB,MAAM8xB,GAAc,QAAoB9xB,GACxC,OAAO8xB,GAAcA,EAAYnG,SAAe,CACpD,CACK,CACD,MAAMoG,GAfQ3yB,EAeyBH,EAdxC6R,OAAOyO,iBAAiBngB,IAejBrC,IAAS,QAAkBiD,GAC3B+xB,EAAcC,iBAAiBhyB,GAC/B+xB,EAAc/xB,KAAS,EAC7B,MAAwB,iBAAVjD,EAAqBA,EAAM0qB,OAAS1qB,CACtD,CApBR,IAA0BqC,CAqBtB,CACA,0BAAAswB,CAA2BzwB,GAAU,mBAAEK,IACnC,OAAO,EAAAkY,GAAAya,GAAmBhzB,EAAUK,EACxC,CACA,KAAAmwB,CAAMtJ,EAAatqB,EAAcR,GAC7B4rB,GAAgBd,EAAatqB,EAAcR,EAAMkb,kBACrD,CACA,2BAAAyP,CAA4B3qB,EAAOqL,EAAWvL,GAC1C,OAAO6qB,GAA4B3qB,EAAOqL,EAAWvL,EACzD,EC5BJ,MAAM+2B,WAAyBV,GAC3B,WAAA/4B,GACI0N,SAASY,WACTpO,KAAKoJ,KAAO,MACZpJ,KAAK4vB,UAAW,EAChB5vB,KAAK+2B,2BAA6B,KACtC,CACA,sBAAAsB,CAAuB31B,EAAO2E,GAC1B,OAAO3E,EAAM2E,EACjB,CACA,qBAAAixB,CAAsBhyB,EAAUe,GAC5B,GAAI,KAAeC,IAAID,GAAM,CACzB,MAAM8xB,GAAc,QAAoB9xB,GACxC,OAAO8xB,GAAcA,EAAYnG,SAAe,CACpD,CAEA,OADA3rB,EAAOupB,GAAoBtpB,IAAID,GAA0BA,GAAnB,QAAYA,GAC3Cf,EAASkzB,aAAanyB,EACjC,CACA,2BAAAgmB,CAA4B3qB,EAAOqL,EAAWvL,GAC1C,OAAO,GAA4BE,EAAOqL,EAAWvL,EACzD,CACA,KAAAs0B,CAAMtJ,EAAatqB,EAAcR,GAC7B2sB,GAAc7B,EAAatqB,EAAclD,KAAK4vB,SAAUltB,EAAMkb,kBAClE,CACA,cAAAqX,CAAe3uB,EAAUknB,EAAazJ,EAAWvT,GAC7CqgB,GAAUvqB,EAAUknB,EAAazJ,EAAWvT,EAChD,CACA,KAAA3C,CAAMvH,GACFtG,KAAK4vB,SAAWA,GAAStpB,EAASsV,SAClCpO,MAAMK,MAAMvH,EAChB,ECpCJ,MCFMmzB,GAAuB5yB,ECIeitB,GAA6B,IAClEprB,KACAugB,MACA,MACA9jB,KFNwB,CAACgL,EAAW1N,IAChCwqB,GAAe9c,GAChB,IAAIopB,GAAiB92B,GACrB,IAAIy2B,GAAkBz2B,EAAS,CAC7BipB,gBAAiBvb,IAAc,EAAAwjB,a,8EGA3C,MAAM+F,EAAmB,IAAI1vB,IAAI,CAAC,OAAQ,OAAQ,M,2CCIlD,MAAM2vB,EAEN,2DASA,SAASC,EAAiB/d,EAASpV,EAAS6M,EAAQ,IAChD,OAAUA,GAFG,EAEgB,yDAAyDuI,yDACtF,MAAOge,EAAOC,GAVlB,SAA0Bje,GACtB,MAAMke,EAAQJ,EAAsBK,KAAKne,GACzC,IAAKke,EACD,MAAO,CAAC,GACZ,MAAO,CAAEE,EAAQC,EAAQJ,GAAYC,EACrC,MAAO,CAAC,KAAKE,QAAuCA,EAASC,IAAUJ,EAC3E,CAI8BK,CAAiBte,GAE3C,IAAKge,EACD,OAEJ,MAAMrwB,EAAW2O,OAAOyO,iBAAiBngB,GAAS4yB,iBAAiBQ,GACnE,GAAIrwB,EAAU,CACV,MAAM4wB,EAAU5wB,EAASslB,OACzB,OAAO,IAAAxsB,GAAkB83B,GAAW9qB,WAAW8qB,GAAWA,CAC9D,CACA,OAAO,OAAmBN,GACpBF,EAAiBE,EAAUrzB,EAAS6M,EAAQ,GAC5CwmB,CACV,C,wBC9BA,MAAMhB,UAA6B,IAC/B,WAAAh5B,CAAYu6B,EAAqBld,EAAYhV,EAAMqD,EAAa/E,GAC5D+G,MAAM6sB,EAAqBld,EAAYhV,EAAMqD,EAAa/E,GAAS,EACvE,CACA,aAAA6zB,GACI,MAAM,oBAAED,EAAmB,QAAE5zB,EAAO,KAAE0B,GAASnI,KAC/C,IAAKyG,IAAYA,EAAQoV,QACrB,OACJrO,MAAM8sB,gBAIN,IAAK,IAAIh4B,EAAI,EAAGA,EAAI+3B,EAAoBj4B,OAAQE,IAAK,CACjD,IAAIi4B,EAAWF,EAAoB/3B,GACnC,GAAwB,iBAAbi4B,IACPA,EAAWA,EAASzL,QAChB,OAAmByL,IAAW,CAC9B,MAAM/wB,EAAWowB,EAAiBW,EAAU9zB,EAAQoV,cACnCra,IAAbgI,IACA6wB,EAAoB/3B,GAAKkH,GAEzBlH,IAAM+3B,EAAoBj4B,OAAS,IACnCpC,KAAKw6B,cAAgBD,EAE7B,CAER,CAaA,GAPAv6B,KAAKy6B,wBAOA,IAAenzB,IAAIa,IAAwC,IAA/BkyB,EAAoBj4B,OACjD,OAEJ,MAAOuC,EAAQN,GAAUg2B,EACnBK,GAAa,OAAuB/1B,GACpCg2B,GAAa,OAAuBt2B,GAI1C,GAAIq2B,IAAeC,EAMnB,IAAI,QAAcD,KAAe,QAAcC,GAC3C,IAAK,IAAIr4B,EAAI,EAAGA,EAAI+3B,EAAoBj4B,OAAQE,IAAK,CACjD,MAAM8B,EAAQi2B,EAAoB/3B,GACb,iBAAV8B,IACPi2B,EAAoB/3B,GAAKgN,WAAWlL,GAE5C,MAMApE,KAAKmf,kBAAmB,CAEhC,CACA,oBAAAsb,GACI,MAAM,oBAAEJ,EAAmB,KAAElyB,GAASnI,KAChC46B,EAAsB,GAC5B,IAAK,IAAIt4B,EAAI,EAAGA,EAAI+3B,EAAoBj4B,OAAQE,KACxC,OAAO+3B,EAAoB/3B,KAC3Bs4B,EAAoB7uB,KAAKzJ,GAG7Bs4B,EAAoBx4B,QF5EhC,SAAqCi4B,EAAqBO,EAAqBzyB,GAC3E,IACI0yB,EADAv4B,EAAI,EAER,KAAOA,EAAI+3B,EAAoBj4B,SAAWy4B,GAAoB,CAC1D,MAAMN,EAAWF,EAAoB/3B,GACb,iBAAbi4B,IACNb,EAAiBpyB,IAAIizB,KACtB,OAAoBA,GAAU30B,OAAOxD,SACrCy4B,EAAqBR,EAAoB/3B,IAE7CA,GACJ,CACA,GAAIu4B,GAAsB1yB,EACtB,IAAK,MAAM2yB,KAAaF,EACpBP,EAAoBS,IAAa,OAAkB3yB,EAAM0yB,EAGrE,CE4DYE,CAA4BV,EAAqBO,EAAqBzyB,EAE9E,CACA,mBAAA6yB,GACI,MAAM,QAAEv0B,EAAO,oBAAE4zB,EAAmB,KAAElyB,GAASnI,KAC/C,IAAKyG,IAAYA,EAAQoV,QACrB,OACS,WAAT1T,IACAnI,KAAKi7B,iBAAmB9iB,OAAO+iB,aAEnCl7B,KAAKm7B,eAAiB,KAAiBhzB,GAAM1B,EAAQJ,qBAAsB8R,OAAOyO,iBAAiBngB,EAAQoV,UAC3Gwe,EAAoB,GAAKr6B,KAAKm7B,eAE9B,MAAMC,EAAkBf,EAAoBA,EAAoBj4B,OAAS,QACjDZ,IAApB45B,GACA30B,EAAQgF,SAAStD,EAAMizB,GAAiB7D,KAAK6D,GAAiB,EAEtE,CACA,eAAAC,GACI,IAAI9xB,EACJ,MAAM,QAAE9C,EAAO,KAAE0B,EAAI,oBAAEkyB,GAAwBr6B,KAC/C,IAAKyG,IAAYA,EAAQoV,QACrB,OACJ,MAAMzX,EAAQqC,EAAQgF,SAAStD,GAC/B/D,GAASA,EAAMmzB,KAAKv3B,KAAKm7B,gBAAgB,GACzC,MAAMG,EAAqBjB,EAAoBj4B,OAAS,EAClDo4B,EAAgBH,EAAoBiB,GAC1CjB,EAAoBiB,GAAsB,KAAiBnzB,GAAM1B,EAAQJ,qBAAsB8R,OAAOyO,iBAAiBngB,EAAQoV,UACzG,OAAlB2e,QAAiDh5B,IAAvBxB,KAAKw6B,gBAC/Bx6B,KAAKw6B,cAAgBA,IAGa,QAAjCjxB,EAAKvJ,KAAKu7B,yBAAsC,IAAPhyB,OAAgB,EAASA,EAAGnH,SACtEpC,KAAKu7B,kBAAkBrvB,SAAQ,EAAEsvB,EAAoBC,MACjDh1B,EACKgF,SAAS+vB,GACTj0B,IAAIk0B,EAAoB,IAGrCz7B,KAAKy6B,sBACT,E,kCC5HJ,MAAMiB,EAAeC,GAAQA,EAAIC,QAAQ,mBAAoB,SAAS5V,a,yCCHtE,MAAM6V,EAAyBhC,GAAWxyB,GAAuB,iBAARA,GAAoBA,EAAIqnB,WAAWmL,GACtFiC,EACQD,EAAsB,MAC9BE,EACQF,EAAsB,UAC9BG,EAAsB53B,KACA23B,EAAsB33B,IAIvC63B,EAAuB5sB,KAAKjL,EAAM83B,MAAM,MAAM,GAAGpN,QAEtDmN,EAAyB,qF,uFCR/B,MAAME,EAAiB5D,GAAMA,IAAM,MAAUA,IAAM,EAAAnpB,GAC7CgtB,EAAmB,CAACC,EAAQC,IAAQhtB,WAAW+sB,EAAOH,MAAM,MAAMI,IAClEC,EAAyB,CAACC,EAAMC,IAAS,CAACC,GAASj5B,gBACrD,GAAkB,SAAdA,IAAyBA,EACzB,OAAO,EACX,MAAMk5B,EAAWl5B,EAAUs2B,MAAM,uBACjC,GAAI4C,EACA,OAAOP,EAAiBO,EAAS,GAAIF,GAEpC,CACD,MAAMJ,EAAS54B,EAAUs2B,MAAM,qBAC/B,OAAIsC,EACOD,EAAiBC,EAAO,GAAIG,GAG5B,CAEf,GAEEI,EAAgB,IAAI5yB,IAAI,CAAC,IAAK,IAAK,MACnC6yB,EAAgC,IAAmBC,QAAQz1B,IAASu1B,EAAct1B,IAAID,KAC5F,SAAS01B,EAAgCv6B,GACrC,MAAM+4B,EAAoB,GAQ1B,OAPAsB,EAA8B3wB,SAAS7E,IACnC,MAAMjD,EAAQ5B,EAAciJ,SAASpE,QACvB7F,IAAV4C,IACAm3B,EAAkBxvB,KAAK,CAAC1E,EAAKjD,EAAM+C,QACnC/C,EAAMmD,IAAIF,EAAIqnB,WAAW,SAAW,EAAI,GAC5C,IAEG6M,CACX,CACA,MAAMyB,EAAmB,CAErBhN,MAAO,EAAGxvB,MAAOy8B,cAAc,IAAKC,eAAe,OAAU18B,EAAEE,IAAMF,EAAEC,IAAM6O,WAAW2tB,GAAe3tB,WAAW4tB,GAClHjN,OAAQ,EAAGtvB,MAAOw8B,aAAa,IAAKC,gBAAgB,OAAUz8B,EAAED,IAAMC,EAAEF,IAAM6O,WAAW6tB,GAAc7tB,WAAW8tB,GAClHh9B,IAAK,CAACs8B,GAASt8B,SAAUkP,WAAWlP,GACpCC,KAAM,CAACq8B,GAASr8B,UAAWiP,WAAWjP,GACtCE,OAAQ,EAAGI,MAAOP,SAAUkP,WAAWlP,IAAQO,EAAED,IAAMC,EAAEF,KACzDH,MAAO,EAAGE,MAAOH,UAAWiP,WAAWjP,IAASG,EAAEE,IAAMF,EAAEC,KAE1DD,EAAG+7B,EAAuB,EAAG,IAC7B57B,EAAG47B,EAAuB,EAAG,KAGjCS,EAAiBK,WAAaL,EAAiBx8B,EAC/Cw8B,EAAiBM,WAAaN,EAAiBr8B,C,oEC9C/C,SAAS48B,EAAkBl2B,EAAKjD,GAC5B,IAAIo5B,GAAmB,OAAoBn2B,GAI3C,OAHIm2B,IAAqB,MACrBA,EAAmB,KAEhBA,EAAiBD,kBAClBC,EAAiBD,kBAAkBn5B,QACnC5C,CACV,C,0DCLA,MAAMi8B,EAAoB,I,QACnB,EAEHvJ,MAAK,IACLwJ,gBAAiB,IACjBC,aAAc,IACdC,KAAM,IACNC,OAAQ,IAERC,YAAa,IACbC,eAAgB,IAChBC,iBAAkB,IAClBC,kBAAmB,IACnBC,gBAAiB,IACjBpB,OAAM,IACNqB,aAAc,KAKZC,EAAuB/2B,GAAQo2B,EAAkBp2B,E,4ECxBvD,MCKMg3B,EAAsB,CAAC,KAAQ,EAAAjvB,GAAI,KAAS,KAAS,EAAAkvB,GAAI,EAAAC,GDLlD,CACTlvB,KAAOkpB,GAAY,SAANA,EACb5oB,MAAQ4oB,GAAMA,ICOZiG,EAA0BjG,GAAM8F,EAAoB7F,MAAK,EAAAnpB,EAAA,GAAckpB,G,0DCV7E,MAAMkG,EAA0B,CAE5BC,YAAa,EAAAtvB,GACbuvB,eAAgB,EAAAvvB,GAChBwvB,iBAAkB,EAAAxvB,GAClByvB,kBAAmB,EAAAzvB,GACnB0vB,gBAAiB,EAAA1vB,GACjBwD,aAAc,EAAAxD,GACd2vB,OAAQ,EAAA3vB,GACR0D,oBAAqB,EAAA1D,GACrB2D,qBAAsB,EAAA3D,GACtB6D,wBAAyB,EAAA7D,GACzB4D,uBAAwB,EAAA5D,GAExB4gB,MAAO,EAAA5gB,GACP4vB,SAAU,EAAA5vB,GACV6gB,OAAQ,EAAA7gB,GACR6vB,UAAW,EAAA7vB,GACXhP,IAAK,EAAAgP,GACL9O,MAAO,EAAA8O,GACP7O,OAAQ,EAAA6O,GACR/O,KAAM,EAAA+O,GAEN8vB,QAAS,EAAA9vB,GACT+tB,WAAY,EAAA/tB,GACZ8tB,aAAc,EAAA9tB,GACdguB,cAAe,EAAAhuB,GACf6tB,YAAa,EAAA7tB,GACbmZ,OAAQ,EAAAnZ,GACR+vB,UAAW,EAAA/vB,GACXgwB,YAAa,EAAAhwB,GACbiwB,aAAc,EAAAjwB,GACdkwB,WAAY,EAAAlwB,GAEZmwB,oBAAqB,EAAAnwB,GACrBowB,oBAAqB,EAAApwB,IClCnBqwB,EAAsB,CACxB15B,OAAQ,KACRC,QAAS,KACTC,QAAS,KACT2d,QAAS,KACTziB,MAAK,KACLuC,OAAQ,KACRE,OAAQ,KACR87B,OAAQ,KACRC,KAAM,KACNz5B,MAAO,KACPC,MAAO,KACP/C,SAAU,EAAAgM,GACViuB,WAAY,EAAAjuB,GACZkuB,WAAY,EAAAluB,GACZwwB,WAAY,EAAAxwB,GACZ5O,EAAG,EAAA4O,GACHzO,EAAG,EAAAyO,GACHtJ,EAAG,EAAAsJ,GACHywB,YAAa,EAAAzwB,GACbqV,qBAAsB,EAAArV,GACtBqT,QAAS,KACT9e,QAAS,KACTE,QAAS,KACTmrB,QAAS,EAAA5f,ICzBP,EAAM,IACL,KACH3L,UAAWc,KAAK+R,OCEdwpB,EAAmB,IAClBrB,KACAgB,EACHM,OAAQ,EACR/zB,KAAM,EAAAoD,GAEN4wB,YAAa,KACbC,cAAe,KACfC,WAAY,E,kCCXhB,MAAMC,EAAiB5H,GAAOnvB,GAASA,EAAKiG,KAAKkpB,E,gDCDjD,MAAM6H,EAAiB,IAAIp2B,IAAI,CAC3B,QACA,SACA,MACA,OACA,QACA,YACG,K,0CCNP,MAAMq2B,EAAqB,CACvB,uBACA,IACA,IACA,IACA,aACA,aACA,aACA,QACA,SACA,SACA,SACA,UACA,UACA,UACA,OACA,QACA,SAKEC,EAAiB,IAAIt2B,IAAIq2B,E,iECtB/B,MAAME,EAAY,IAAIv2B,IACtB,IAAIw2B,GAAc,EACdC,GAAsB,EAC1B,SAASC,IACL,GAAID,EAAqB,CACrB,MAAME,EAAqBh5B,MAAMya,KAAKme,GAAWzD,QAAQ8D,GAAaA,EAASzhB,mBACzE0hB,EAAoB,IAAI72B,IAAI22B,EAAmB93B,KAAK+3B,GAAaA,EAASn6B,WAC1Eq6B,EAAsB,IAAI75B,IAKhC45B,EAAkB30B,SAASzF,IACvB,MAAM80B,GAAoB,QAAgC90B,GACrD80B,EAAkBn5B,SAEvB0+B,EAAoBv5B,IAAId,EAAS80B,GACjC90B,EAAQ4L,SAAQ,IAGpBsuB,EAAmBz0B,SAAS00B,GAAaA,EAAS5F,wBAElD6F,EAAkB30B,SAASzF,IACvBA,EAAQ4L,SACR,MAAM0uB,EAAUD,EAAoB35B,IAAIV,GACpCs6B,GACAA,EAAQ70B,SAAQ,EAAE7E,EAAKjD,MACnB,IAAImF,EAC6B,QAAhCA,EAAK9C,EAAQgF,SAASpE,UAAyB,IAAPkC,GAAyBA,EAAGhC,IAAInD,EAAM,GAEvF,IAGJu8B,EAAmBz0B,SAAS00B,GAAaA,EAASvF,oBAElDsF,EAAmBz0B,SAAS00B,SACUp/B,IAA9Bo/B,EAAS3F,kBACT9iB,OAAO6oB,SAAS,EAAGJ,EAAS3F,iBAChC,GAER,CACAwF,GAAsB,EACtBD,GAAc,EACdD,EAAUr0B,SAAS00B,GAAaA,EAASK,aACzCV,EAAUtb,OACd,CACA,SAASic,IACLX,EAAUr0B,SAAS00B,IACfA,EAAStG,gBACLsG,EAASzhB,mBACTshB,GAAsB,EAC1B,GAER,CACA,SAASU,IACLD,IACAR,GACJ,CACA,MAAMhM,EACF,WAAA50B,CAAYu6B,EAAqBld,EAAYhV,EAAMqD,EAAa/E,EAAS26B,GAAU,GAK/EphC,KAAKqhC,YAAa,EAMlBrhC,KAAKohC,SAAU,EAKfphC,KAAKmf,kBAAmB,EAKxBnf,KAAKwgC,aAAc,EACnBxgC,KAAKq6B,oBAAsB,IAAIA,GAC/Br6B,KAAKmd,WAAaA,EAClBnd,KAAKmI,KAAOA,EACZnI,KAAKwL,YAAcA,EACnBxL,KAAKyG,QAAUA,EACfzG,KAAKohC,QAAUA,CACnB,CACA,eAAAE,GACIthC,KAAKwgC,aAAc,EACfxgC,KAAKohC,SACLb,EAAU10B,IAAI7L,MACTwgC,IACDA,GAAc,EACd,KAAMtsB,KAAKgtB,GACX,KAAMK,iBAAiBb,MAI3B1gC,KAAKs6B,gBACLt6B,KAAKihC,WAEb,CACA,aAAA3G,GACI,MAAM,oBAAED,EAAmB,KAAElyB,EAAI,QAAE1B,EAAO,YAAE+E,GAAgBxL,KAK5D,IAAK,IAAIsC,EAAI,EAAGA,EAAI+3B,EAAoBj4B,OAAQE,IAC5C,GAA+B,OAA3B+3B,EAAoB/3B,GAIpB,GAAU,IAANA,EAAS,CACT,MAAMk/B,EAAeh2B,aAAiD,EAASA,EAAYrE,MACrFqzB,EAAgBH,EAAoBA,EAAoBj4B,OAAS,GACvE,QAAqBZ,IAAjBggC,EACAnH,EAAoB,GAAKmH,OAExB,GAAI/6B,GAAW0B,EAAM,CACtB,MAAMs5B,EAAch7B,EAAQ2xB,UAAUjwB,EAAMqyB,GACxCiH,UACApH,EAAoB,GAAKoH,EAEjC,MAC+BjgC,IAA3B64B,EAAoB,KACpBA,EAAoB,GAAKG,GAEzBhvB,QAAgChK,IAAjBggC,GACfh2B,EAAYjE,IAAI8yB,EAAoB,GAE5C,MAEIA,EAAoB/3B,GAAK+3B,EAAoB/3B,EAAI,EAIjE,CACA,gBAAAo/B,GAAqB,CACrB,mBAAA1G,GAAwB,CACxB,eAAA2G,GAAoB,CACpB,eAAAtG,GAAoB,CACpB,QAAA4F,GACIjhC,KAAKqhC,YAAa,EAClBrhC,KAAKmd,WAAWnd,KAAKq6B,oBAAqBr6B,KAAKw6B,eAC/C+F,EAAUj1B,OAAOtL,KACrB,CACA,MAAA4hC,GACS5hC,KAAKqhC,aACNrhC,KAAKwgC,aAAc,EACnBD,EAAUj1B,OAAOtL,MAEzB,CACA,MAAA6hC,GACS7hC,KAAKqhC,YACNrhC,KAAKshC,iBACb,E,2EC5JJ,SAASt5B,EAAsBtF,GAC3B,OAAQ,OAAoBA,EAAM+F,UAC9B,IAAasX,MAAM5X,IAAS,OAAezF,EAAMyF,KACzD,CACA,SAASssB,EAAc/xB,GACnB,OAAO4J,QAAQtE,EAAsBtF,IAAUA,EAAMm1B,SACzD,C,iBCPA,SAASiK,EAAevJ,GACpB,MAAoB,iBAANA,GAAkB5wB,MAAMC,QAAQ2wB,EAClD,C,gECHA,SAASwJ,EAAev/B,EAAe8G,EAAYI,GAC/C,MAAMhH,EAAQF,EAAckL,WAC5B,OAAO,OAAwBhL,EAAO4G,OAAuB9H,IAAXkI,EAAuBA,EAAShH,EAAMgH,OAAQlH,EACpG,C,iBCLA,SAASw/B,EAAcx/B,GACnB,MAAMwG,EAAQ,CAAC,CAAC,EAAG,CAAC,GAKpB,OAJAxG,SAA8DA,EAAcoD,OAAOsG,SAAQ,CAAC9H,EAAOiD,KAC/F2B,EAAM,GAAG3B,GAAOjD,EAAM+C,MACtB6B,EAAM,GAAG3B,GAAOjD,EAAM69B,aAAa,IAEhCj5B,CACX,CACA,SAASk5B,EAAwBx/B,EAAO4G,EAAYI,EAAQlH,GAIxD,GAA0B,mBAAf8G,EAA2B,CAClC,MAAOuS,EAASsmB,GAAYH,EAAcx/B,GAC1C8G,EAAaA,OAAsB9H,IAAXkI,EAAuBA,EAAShH,EAAMgH,OAAQmS,EAASsmB,EACnF,CAaA,GAR0B,iBAAf74B,IACPA,EAAa5G,EAAMm1B,UAAYn1B,EAAMm1B,SAASvuB,IAOxB,mBAAfA,EAA2B,CAClC,MAAOuS,EAASsmB,GAAYH,EAAcx/B,GAC1C8G,EAAaA,OAAsB9H,IAAXkI,EAAuBA,EAAShH,EAAMgH,OAAQmS,EAASsmB,EACnF,CACA,OAAO74B,CACX,C,oFCzBA,SAAS84B,EAAe5/B,EAAe6E,EAAKjD,GACpC5B,EAAc60B,SAAShwB,GACvB7E,EAAciJ,SAASpE,GAAKE,IAAInD,GAGhC5B,EAAc40B,SAAS/vB,GAAK,QAAYjD,GAEhD,CACA,SAASi+B,EAAU7/B,EAAe8G,GAC9B,MAAME,GAAW,OAAehH,EAAe8G,GAC/C,IAAI,cAAEM,EAAgB,CAAC,EAAC,WAAED,EAAa,CAAC,KAAMtF,GAAWmF,GAAY,CAAC,EACtEnF,EAAS,IAAKA,KAAWuF,GACzB,IAAK,MAAMvC,KAAOhD,EAAQ,CAEtB+9B,EAAe5/B,EAAe6E,GADhB,OAA6BhD,EAAOgD,IAEtD,CACJ,C,0CCxBA,MAAMi7B,EAAuB,CACzB,UACA,cACA,aACA,aACA,WACA,YACA,QAEEC,EAAe,CAAC,aAAcD,E,kCCTpC,MAAME,EAAqB,CACvBC,gBAAgB,EAChBC,iBAAiB,E,iBCFrB,SAASC,EAAcC,EAAKC,IACG,IAAvBD,EAAI1V,QAAQ2V,IACZD,EAAI72B,KAAK82B,EACjB,CACA,SAASC,EAAWF,EAAKC,GACrB,MAAME,EAAQH,EAAI1V,QAAQ2V,GACtBE,GAAS,GACTH,EAAII,OAAOD,EAAO,EAC1B,C,4DCRA,MAAMzkB,EAAQ,CAAC7d,EAAKC,EAAK63B,IACjBA,EAAI73B,EACGA,EACP63B,EAAI93B,EACGA,EACJ83B,C,kCCLX,MAAMn1B,EAAW,CAACgQ,EAAGC,IAAM9O,KAAKC,IAAI4O,EAAIC,GACxC,SAAS4vB,EAAW7vB,EAAGC,GAEnB,MAAM6vB,EAAS9/B,EAASgQ,EAAE5S,EAAG6S,EAAE7S,GACzB2iC,EAAS//B,EAASgQ,EAAEzS,EAAG0S,EAAE1S,GAC/B,OAAO4D,KAAK6+B,KAAKF,GAAU,EAAIC,GAAU,EAC7C,C,kCCLA,MAAME,EAAmB,EAAGxnB,aACjBA,EAAUA,EAAQynB,cAAcC,YAAc,I,kGCoCzD,SAASC,EAAYC,EAAOthB,GAAU7D,MAAOolB,GAAU,EAAI,KAAE/d,EAAI,MAAEge,GAAU,CAAC,GAC1E,MAAMC,EAAcH,EAAMrhC,OAM1B,IALA,OAAUwhC,IAAgBzhB,EAAO/f,OAAQ,wDAKrB,IAAhBwhC,EACA,MAAO,IAAMzhB,EAAO,GACxB,GAAoB,IAAhByhB,GAAqBzhB,EAAO,KAAOA,EAAO,GAC1C,MAAO,IAAMA,EAAO,GACxB,MAAM0hB,EAAmBJ,EAAM,KAAOA,EAAM,GAExCA,EAAM,GAAKA,EAAMG,EAAc,KAC/BH,EAAQ,IAAIA,GAAOn7B,UACnB6Z,EAAS,IAAIA,GAAQ7Z,WAEzB,MAAMw7B,EAlDV,SAAsB3hB,EAAQwD,EAAMoe,GAChC,MAAMD,EAAS,GACTE,EAAeD,GAAe,IAC9BE,EAAY9hB,EAAO/f,OAAS,EAClC,IAAK,IAAIE,EAAI,EAAGA,EAAI2hC,EAAW3hC,IAAK,CAChC,IAAIqhC,EAAQK,EAAa7hB,EAAO7f,GAAI6f,EAAO7f,EAAI,IAC/C,GAAIqjB,EAAM,CACN,MAAMue,EAAiBv8B,MAAMC,QAAQ+d,GAAQA,EAAKrjB,IAAM,IAAOqjB,EAC/Dge,GAAQ,OAAKO,EAAgBP,EACjC,CACAG,EAAO/3B,KAAK43B,EAChB,CACA,OAAOG,CACX,CAqCmBK,CAAahiB,EAAQwD,EAAMge,GACpCM,EAAYH,EAAO1hC,OACnBgiC,EAAgB7L,IAClB,GAAIsL,GAAoBtL,EAAIkL,EAAM,GAC9B,OAAOthB,EAAO,GAClB,IAAI7f,EAAI,EACR,GAAI2hC,EAAY,EACZ,KAAO3hC,EAAImhC,EAAMrhC,OAAS,KAClBm2B,EAAIkL,EAAMnhC,EAAI,IADOA,KAKjC,MAAM+hC,GAAkB,OAASZ,EAAMnhC,GAAImhC,EAAMnhC,EAAI,GAAIi2B,GACzD,OAAOuL,EAAOxhC,GAAG+hC,EAAgB,EAErC,OAAOX,EACAnL,GAAM6L,GAAa,OAAMX,EAAM,GAAIA,EAAMG,EAAc,GAAIrL,IAC5D6L,CACV,C,kCCzEA,MAAME,EAA8B,oBAAXnsB,M,kCCGzB,MAAMosB,EAAqBhM,GAAM,+BAA+BlpB,KAAKkpB,E,iBCHrE,SAASiM,EAAYpe,GACjB,OAAQA,GACW,iBAARA,GACPzV,OAAO8zB,UAAU94B,eAAesC,KAAKmY,EAAK,UAClD,C,kDCDA,MAAMse,EAAqBnM,GAAM,cAAclpB,KAAKkpB,E,0DCFpD,SAASoM,EAAS5vB,EAAG6vB,EAAGC,GAKpB,OAJIA,EAAI,IACJA,GAAK,GACLA,EAAI,IACJA,GAAK,GACLA,EAAI,EAAI,EACD9vB,EAAc,GAAT6vB,EAAI7vB,GAAS8vB,EACzBA,EAAI,GACGD,EACPC,EAAI,EAAI,EACD9vB,GAAK6vB,EAAI7vB,IAAM,EAAI,EAAI8vB,GAAK,EAChC9vB,CACX,C,kCCbA,SAAS+vB,EAAa1xB,EAAGC,GACrB,OAAQ0B,GAAOA,EAAI,EAAI1B,EAAID,CAC/B,CCSA,MAAM2xB,EAAiB,CAAC3iB,EAAMC,EAAIkW,KAC9B,MAAMyM,EAAW5iB,EAAOA,EAClB6iB,EAAO1M,GAAKlW,EAAKA,EAAK2iB,GAAYA,EACxC,OAAOC,EAAO,EAAI,EAAI1gC,KAAK6+B,KAAK6B,EAAK,EAEnCC,EAAa,CAACC,EAAA,EAAKC,EAAA,EAAMC,EAAA,GAE/B,SAASC,EAAOpR,GACZ,MAAM9qB,GAFYmvB,EAEQrE,EAFFgR,EAAW1M,MAAMpvB,GAASA,EAAKiG,KAAKkpB,MAA3C,IAACA,EAIlB,IADA,OAAQjsB,QAAQlD,GAAO,IAAI8qB,0EACtB5nB,QAAQlD,GACT,OAAO,EACX,IAAIm8B,EAAQn8B,EAAKuG,MAAMukB,GAKvB,OAJI9qB,IAASi8B,EAAA,IAETE,EFZR,UAAoB,IAAEC,EAAG,WAAEC,EAAU,UAAEC,EAAS,MAAEC,IAC9CH,GAAO,IAEPE,GAAa,IACb,IAAIE,EAAM,EACNC,EAAQ,EACRC,EAAO,EACX,GALAL,GAAc,IAQT,CACD,MAAMb,EAAIc,EAAY,GAChBA,GAAa,EAAID,GACjBC,EAAYD,EAAaC,EAAYD,EACrC1wB,EAAI,EAAI2wB,EAAYd,EAC1BgB,EAAMjB,EAAS5vB,EAAG6vB,EAAGY,EAAM,EAAI,GAC/BK,EAAQlB,EAAS5vB,EAAG6vB,EAAGY,GACvBM,EAAOnB,EAAS5vB,EAAG6vB,EAAGY,EAAM,EAAI,EACpC,MAVII,EAAMC,EAAQC,EAAOJ,EAWzB,MAAO,CACHE,IAAKrhC,KAAK+R,MAAY,IAANsvB,GAChBC,MAAOthC,KAAK+R,MAAc,IAARuvB,GAClBC,KAAMvhC,KAAK+R,MAAa,IAAPwvB,GACjBH,QAER,CEbgBI,CAAWR,IAEhBA,CACX,CACA,MAAMS,EAAW,CAAC5jB,EAAMC,KACpB,MAAM4jB,EAAWX,EAAOljB,GAClB8jB,EAASZ,EAAOjjB,GACtB,IAAK4jB,IAAaC,EACd,OAAOpB,EAAa1iB,EAAMC,GAE9B,MAAM8jB,EAAU,IAAKF,GACrB,OAAQ1N,IACJ4N,EAAQP,IAAMb,EAAekB,EAASL,IAAKM,EAAON,IAAKrN,GACvD4N,EAAQN,MAAQd,EAAekB,EAASJ,MAAOK,EAAOL,MAAOtN,GAC7D4N,EAAQL,KAAOf,EAAekB,EAASH,KAAMI,EAAOJ,KAAMvN,GAC1D4N,EAAQR,OAAQ,OAAUM,EAASN,MAAOO,EAAOP,MAAOpN,GACjD6M,EAAA,EAAK3hC,UAAU0iC,GACzB,E,2CC3CL,MAAMC,EAAkB,IAAIp8B,IAAI,CAAC,OAAQ,WCUzC,SAASq8B,EAAUjzB,EAAGC,GAClB,OAAQ0B,IAAM,OAAY3B,EAAGC,EAAG0B,EACpC,CACA,SAASuxB,EAASlzB,GACd,MAAiB,iBAANA,EACAizB,EAEW,iBAANjzB,GACL,OAAmBA,GACpB0xB,EACA5Q,EAAA,EAAM7kB,KAAK+D,GACP4yB,EACAO,EAEL5+B,MAAMC,QAAQwL,GACZozB,EAEW,iBAANpzB,EACL8gB,EAAA,EAAM7kB,KAAK+D,GAAK4yB,EAAWS,EAE/B3B,CACX,CACA,SAAS0B,EAASpzB,EAAGC,GACjB,MAAM8O,EAAS,IAAI/O,GACbszB,EAAYvkB,EAAO/f,OACnBukC,EAAavzB,EAAEvK,KAAI,CAAC0vB,EAAGj2B,IAAMgkC,EAAS/N,EAAT+N,CAAY/N,EAAGllB,EAAE/Q,MACpD,OAAQyS,IACJ,IAAK,IAAIzS,EAAI,EAAGA,EAAIokC,EAAWpkC,IAC3B6f,EAAO7f,GAAKqkC,EAAWrkC,GAAGyS,GAE9B,OAAOoN,CAAM,CAErB,CACA,SAASskB,EAAUrzB,EAAGC,GAClB,MAAM8O,EAAS,IAAK/O,KAAMC,GACpBszB,EAAa,CAAC,EACpB,IAAK,MAAMt/B,KAAO8a,OACC3gB,IAAX4R,EAAE/L,SAAiC7F,IAAX6R,EAAEhM,KAC1Bs/B,EAAWt/B,GAAOi/B,EAASlzB,EAAE/L,GAAXi/B,CAAiBlzB,EAAE/L,GAAMgM,EAAEhM,KAGrD,OAAQkxB,IACJ,IAAK,MAAMlxB,KAAOs/B,EACdxkB,EAAO9a,GAAOs/B,EAAWt/B,GAAKkxB,GAElC,OAAOpW,CAAM,CAErB,CAcA,MAAMokB,EAAa,CAAC5hC,EAAQN,KACxB,MAAMuL,EAAWF,EAAA,EAAQG,kBAAkBxL,GACrCuiC,GAAc,OAAoBjiC,GAClCkiC,GAAc,OAAoBxiC,GAIxC,OAHuBuiC,EAAYE,QAAQC,IAAI3kC,SAAWykC,EAAYC,QAAQC,IAAI3kC,QAC9EwkC,EAAYE,QAAQ5S,MAAM9xB,SAAWykC,EAAYC,QAAQ5S,MAAM9xB,QAC/DwkC,EAAYE,QAAQE,OAAO5kC,QAAUykC,EAAYC,QAAQE,OAAO5kC,OAE3DgkC,EAAgB9+B,IAAI3C,KACpBkiC,EAAYjhC,OAAOxD,QACnBgkC,EAAgB9+B,IAAIjD,KAChBuiC,EAAYhhC,OAAOxD,OD5EpC,SAAuBuC,EAAQN,GAC3B,OAAI+hC,EAAgB9+B,IAAI3C,GACZoQ,GAAOA,GAAK,EAAIpQ,EAASN,EAGzB0Q,GAAOA,GAAK,EAAI1Q,EAASM,CAEzC,CCsEmBsiC,CAActiC,EAAQN,IAE1B,EAAA6iC,EAAA,GAAKV,EA3BpB,SAAoB7hC,EAAQN,GACxB,IAAIkF,EACJ,MAAM49B,EAAgB,GAChBC,EAAW,CAAElT,MAAO,EAAG6S,IAAK,EAAGC,OAAQ,GAC7C,IAAK,IAAI1kC,EAAI,EAAGA,EAAI+B,EAAOuB,OAAOxD,OAAQE,IAAK,CAC3C,MAAM8G,EAAO/E,EAAOgjC,MAAM/kC,GACpBglC,EAAc3iC,EAAOmiC,QAAQ19B,GAAMg+B,EAASh+B,IAC5Cm+B,EAAoD,QAArCh+B,EAAK5E,EAAOiB,OAAO0hC,UAAiC,IAAP/9B,EAAgBA,EAAK,EACvF49B,EAAc7kC,GAAKilC,EACnBH,EAASh+B,IACb,CACA,OAAO+9B,CACX,CAe6BK,CAAWZ,EAAaC,GAAcA,EAAYjhC,QAASgK,KAGhF,QAAQ,EAAM,mBAAmBjL,WAAgBN,6KAC1CygC,EAAangC,EAAQN,GAChC,ECvFJ,SAASojC,EAAIrlB,EAAMC,EAAItN,GACnB,GAAoB,iBAATqN,GACO,iBAAPC,GACM,iBAANtN,EACP,OAAO,OAAUqN,EAAMC,EAAItN,GAG/B,OADcuxB,EAASlkB,EAChBuhB,CAAMvhB,EAAMC,EACvB,C,kCCUA,MAAMgkB,EAAY,CAACjkB,EAAMC,EAAIrN,IAClBoN,GAAQC,EAAKD,GAAQpN,C,0DCpBhC,SAAS0yB,EAAc9E,GACnB,MAAM3/B,EAAS,CAAC,GAEhB,OCFJ,SAAoBA,EAAQ0kC,GACxB,MAAMlnC,EAAMwC,EAAOA,EAAOb,OAAS,GACnC,IAAK,IAAIE,EAAI,EAAGA,GAAKqlC,EAAWrlC,IAAK,CACjC,MAAMslC,GAAiB,EAAA5yB,EAAA,GAAS,EAAG2yB,EAAWrlC,GAC9CW,EAAO8I,MAAK,OAAUtL,EAAK,EAAGmnC,GAClC,CACJ,CDLIC,CAAW5kC,EAAQ2/B,EAAIxgC,OAAS,GACzBa,CACX,C,gBENA,SAAS6kC,EAAqB7kC,EAAQyiB,GAClC,OAAOziB,EAAO4F,KAAKk/B,GAAMA,EAAIriB,GACjC,C,kDCKA,MAAMsiB,EAAmB,CAAC50B,EAAGC,IAAOklB,GAAMllB,EAAED,EAAEmlB,IACxC2O,EAAO,IAAIe,IAAiBA,EAAa/8B,OAAO88B,E,wDCNtD,MAAME,EAAiB3P,GACZjsB,QAAQisB,GAAkB,iBAANA,GAAkBA,EAAEkP,KAAOlP,EAAE4P,SAEtDC,EAAgC7P,IAE3B,OAAkBA,GAAKA,EAAEA,EAAEn2B,OAAS,IAAM,EAAIm2B,C,gDCLzD,MAAM8P,EACF,WAAAvoC,GACIE,KAAKsoC,cAAgB,EACzB,CACA,GAAAz8B,CAAIyP,GAEA,OADA,QAActb,KAAKsoC,cAAehtB,GAC3B,KAAM,QAAWtb,KAAKsoC,cAAehtB,EAChD,CACA,MAAAG,CAAOrI,EAAGC,EAAGk1B,GACT,MAAMC,EAAmBxoC,KAAKsoC,cAAclmC,OAC5C,GAAKomC,EAEL,GAAyB,IAArBA,EAIAxoC,KAAKsoC,cAAc,GAAGl1B,EAAGC,EAAGk1B,QAG5B,IAAK,IAAIjmC,EAAI,EAAGA,EAAIkmC,EAAkBlmC,IAAK,CAKvC,MAAMgZ,EAAUtb,KAAKsoC,cAAchmC,GACnCgZ,GAAWA,EAAQlI,EAAGC,EAAGk1B,EAC7B,CAER,CACA,OAAAE,GACI,OAAOzoC,KAAKsoC,cAAclmC,MAC9B,CACA,KAAA6iB,GACIjlB,KAAKsoC,cAAclmC,OAAS,CAChC,E,gDC3BJ,SAASsmC,EAAYC,GACjB,MAAMviB,GAAM,IAAAwE,QAAO,MAInB,OAHoB,OAAhBxE,EAAIvK,UACJuK,EAAIvK,QAAU8sB,KAEXviB,EAAIvK,OACf,C,kCCfA,MAAM+sB,EAAwB,CAC1B/sB,SAAS,E,gDCEb,MAAMgtB,E,QAA4B,EAAY,EAAAC,gBAAkB,EAAAvd,S,iBCGhE,SAASwd,EAAkB5G,EAAU6G,GACjC,OAAOA,EAAgB7G,GAAY,IAAO6G,GAAiB,CAC/D,C","sources":["webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/Feature.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/geometry/models.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/utils/measure.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/components/create-proxy.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/shallow-compare.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/get-variant-context.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/animation-state.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/animation/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/animations.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/node/state.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/delay.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/geometry/copy.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/geometry/utils.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/shared/stack.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/utils/is-svg-element.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/styles/transform.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/drag.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/gestures.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/layout.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/definitions.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/utils/symbol.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/features/load-features.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/utils/path.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/utils/render.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/utils/render.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/config-motion.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/config-motion.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/use-props.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/use-props.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/use-render.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/components/create-factory.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/store.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/VisualElement.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/motion-values.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/components/motion/create.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/utils/make-none-animatable.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/number-browser.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/transform.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/utils/keys-position.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/utils/keys-transform.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/KeyframesResolver.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/setters.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/variant-props.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/GlobalConfig.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/array.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/clamp.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/distance.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/get-context-window.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/interpolate.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/is-browser.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/is-ref-object.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/hsla-to-rgba.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/mix/immediate.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/mix/color.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/mix/visibility.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/mix/complex.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/mix/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/mix/number.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/offsets/default.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/offsets/fill.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/offsets/time.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/pipe.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/resolve-value.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/subscription-manager.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/use-constant.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs"],"sourcesContent":["class Feature {\n    constructor(node) {\n        this.isMounted = false;\n        this.node = node;\n    }\n    update() { }\n}\n\nexport { Feature };\n","/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToBox({ top, left, right, bottom, }) {\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertBoxToBoundingBox({ x, y }) {\n    return { top: y.min, right: x.max, bottom: y.max, left: x.min };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoxPoints(point, transformPoint) {\n    if (!transformPoint)\n        return point;\n    const topLeft = transformPoint({ x: point.left, y: point.top });\n    const bottomRight = transformPoint({ x: point.right, y: point.bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n\nexport { convertBoundingBoxToBox, convertBoxToBoundingBox, transformBoxPoints };\n","import { mixNumber } from '../../utils/mix/number.mjs';\nimport { hasTransform } from '../utils/has-transform.mjs';\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const { visualElement } = node.options;\n        if (visualElement &&\n            visualElement.props.style &&\n            visualElement.props.style.display === \"contents\") {\n            continue;\n        }\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\n        treeScale.x = 1.0;\n    }\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\n        treeScale.y = 1.0;\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n}\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n}\n\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\n","import { mixNumber } from '../../utils/mix/number.mjs';\n\nconst SCALE_PRECISION = 0.0001;\nconst SCALE_MIN = 1 - SCALE_PRECISION;\nconst SCALE_MAX = 1 + SCALE_PRECISION;\nconst TRANSLATE_PRECISION = 0.01;\nconst TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;\nconst TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\nfunction isNear(value, target, maxDistance) {\n    return Math.abs(value - target) <= maxDistance;\n}\nfunction calcAxisDelta(delta, source, target, origin = 0.5) {\n    delta.origin = origin;\n    delta.originPoint = mixNumber(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    delta.translate =\n        mixNumber(target.min, target.max, delta.origin) - delta.originPoint;\n    if ((delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX) ||\n        isNaN(delta.scale)) {\n        delta.scale = 1.0;\n    }\n    if ((delta.translate >= TRANSLATE_MIN &&\n        delta.translate <= TRANSLATE_MAX) ||\n        isNaN(delta.translate)) {\n        delta.translate = 0.0;\n    }\n}\nfunction calcBoxDelta(delta, source, target, origin) {\n    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);\n    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);\n}\nfunction calcRelativeAxis(target, relative, parent) {\n    target.min = parent.min + relative.min;\n    target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(target, relative, parent) {\n    calcRelativeAxis(target.x, relative.x, parent.x);\n    calcRelativeAxis(target.y, relative.y, parent.y);\n}\nfunction calcRelativeAxisPosition(target, layout, parent) {\n    target.min = layout.min - parent.min;\n    target.max = target.min + calcLength(layout);\n}\nfunction calcRelativePosition(target, layout, parent) {\n    calcRelativeAxisPosition(target.x, layout.x, parent.x);\n    calcRelativeAxisPosition(target.y, layout.y, parent.y);\n}\n\nexport { calcAxisDelta, calcBoxDelta, calcLength, calcRelativeAxis, calcRelativeAxisPosition, calcRelativeBox, calcRelativePosition, isNear };\n","const createAxisDelta = () => ({\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n});\nconst createDelta = () => ({\n    x: createAxisDelta(),\n    y: createAxisDelta(),\n});\nconst createAxis = () => ({ min: 0, max: 0 });\nconst createBox = () => ({\n    x: createAxis(),\n    y: createAxis(),\n});\n\nexport { createAxis, createAxisDelta, createBox, createDelta };\n","function eachAxis(callback) {\n    return [callback(\"x\"), callback(\"y\")];\n}\n\nexport { eachAxis };\n","function isIdentityScale(scale) {\n    return scale === undefined || scale === 1;\n}\nfunction hasScale({ scale, scaleX, scaleY }) {\n    return (!isIdentityScale(scale) ||\n        !isIdentityScale(scaleX) ||\n        !isIdentityScale(scaleY));\n}\nfunction hasTransform(values) {\n    return (hasScale(values) ||\n        has2DTranslate(values) ||\n        values.z ||\n        values.rotate ||\n        values.rotateX ||\n        values.rotateY ||\n        values.skewX ||\n        values.skewY);\n}\nfunction has2DTranslate(values) {\n    return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\nfunction is2DTranslate(value) {\n    return value && value !== \"0%\";\n}\n\nexport { has2DTranslate, hasScale, hasTransform };\n","import { convertBoundingBoxToBox, transformBoxPoints } from '../geometry/conversion.mjs';\nimport { translateAxis } from '../geometry/delta-apply.mjs';\n\nfunction measureViewportBox(instance, transformPoint) {\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\n}\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\n    const viewportBox = measureViewportBox(element, transformPagePoint);\n    const { scroll } = rootProjectionNode;\n    if (scroll) {\n        translateAxis(viewportBox.x, scroll.offset.x);\n        translateAxis(viewportBox.y, scroll.offset.y);\n    }\n    return viewportBox;\n}\n\nexport { measurePageBox, measureViewportBox };\n","import { warnOnce } from '../../utils/warn-once.mjs';\n\nfunction createDOMMotionComponentProxy(componentFactory) {\n    if (typeof Proxy === \"undefined\") {\n        return componentFactory;\n    }\n    /**\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n     * Rather than generating them anew every render.\n     */\n    const componentCache = new Map();\n    const deprecatedFactoryFunction = (...args) => {\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(false, \"motion() is deprecated. Use motion.create() instead.\");\n        }\n        return componentFactory(...args);\n    };\n    return new Proxy(deprecatedFactoryFunction, {\n        /**\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\n         * DOM component with that name.\n         */\n        get: (_target, key) => {\n            if (key === \"create\")\n                return componentFactory;\n            /**\n             * If this element doesn't exist in the component cache, create it and cache.\n             */\n            if (!componentCache.has(key)) {\n                componentCache.set(key, componentFactory(key));\n            }\n            return componentCache.get(key);\n        },\n    });\n}\n\nexport { createDOMMotionComponentProxy };\n","function shallowCompare(next, prev) {\n    if (!Array.isArray(prev))\n        return false;\n    const prevLength = prev.length;\n    if (prevLength !== next.length)\n        return false;\n    for (let i = 0; i < prevLength; i++) {\n        if (prev[i] !== next[i])\n            return false;\n    }\n    return true;\n}\n\nexport { shallowCompare };\n","import { isVariantLabel } from './is-variant-label.mjs';\nimport { variantProps } from './variant-props.mjs';\n\nconst numVariantProps = variantProps.length;\nfunction getVariantContext(visualElement) {\n    if (!visualElement)\n        return undefined;\n    if (!visualElement.isControllingVariants) {\n        const context = visualElement.parent\n            ? getVariantContext(visualElement.parent) || {}\n            : {};\n        if (visualElement.props.initial !== undefined) {\n            context.initial = visualElement.props.initial;\n        }\n        return context;\n    }\n    const context = {};\n    for (let i = 0; i < numVariantProps; i++) {\n        const name = variantProps[i];\n        const prop = visualElement.props[name];\n        if (isVariantLabel(prop) || prop === false) {\n            context[name] = prop;\n        }\n    }\n    return context;\n}\n\nexport { getVariantContext };\n","import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { variantPriorityOrder } from './variant-props.mjs';\nimport { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\nimport { getVariantContext } from './get-variant-context.mjs';\n\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n    let animate = animateList(visualElement);\n    let state = createState();\n    let isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    const buildResolvedTypeValues = (type) => (acc, definition) => {\n        var _a;\n        const resolved = resolveVariant(visualElement, definition, type === \"exit\"\n            ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\n            : undefined);\n        if (resolved) {\n            const { transition, transitionEnd, ...target } = resolved;\n            acc = { ...acc, ...target, ...transitionEnd };\n        }\n        return acc;\n    };\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(changedActiveType) {\n        const { props } = visualElement;\n        const context = getVariantContext(visualElement.parent) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        const animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        const removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        let encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        let removedVariantIndex = Infinity;\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (let i = 0; i < numAnimationTypes; i++) {\n            const type = reversePriorityOrder[i];\n            const typeState = state[type];\n            const prop = props[type] !== undefined\n                ? props[type]\n                : context[type];\n            const propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            let isInherited = prop === context[type] &&\n                prop !== props[type] &&\n                propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = { ...encounteredKeys };\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                continue;\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            let shouldAnimateType = variantDidChange ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            let handledRemovedValues = false;\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            const definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            const { prevResolvedValues = {} } = typeState;\n            const allKeys = {\n                ...prevResolvedValues,\n                ...resolvedValues,\n            };\n            const markToAnimate = (key) => {\n                shouldAnimateType = true;\n                if (removedKeys.has(key)) {\n                    handledRemovedValues = true;\n                    removedKeys.delete(key);\n                }\n                typeState.needsAnimating[key] = true;\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = false;\n            };\n            for (const key in allKeys) {\n                const next = resolvedValues[key];\n                const prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                let valueHasChanged = false;\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                    valueHasChanged = !shallowCompare(next, prev);\n                }\n                else {\n                    valueHasChanged = next !== prev;\n                }\n                if (valueHasChanged) {\n                    if (next !== undefined && next !== null) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to skip this animation\n             * unless the inherited variants haven't changed on this render.\n             */\n            const willAnimateViaParent = isInherited && variantDidChange;\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues;\n            if (shouldAnimateType && needsAnimating) {\n                animations.push(...definitionList.map((animation) => ({\n                    animation: animation,\n                    options: { type },\n                })));\n            }\n        }\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            const fallbackAnimation = {};\n            removedKeys.forEach((key) => {\n                const fallbackTarget = visualElement.getBaseTarget(key);\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = true;\n                // @ts-expect-error - @mattgperry to figure if we should do something here\n                fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;\n            });\n            animations.push({ animation: fallbackAnimation });\n        }\n        let shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            (props.initial === false || props.initial === props.animate) &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive) {\n        var _a;\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\n        state[type].isActive = isActive;\n        const animations = animateChanges(type);\n        for (const key in state) {\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        animateChanges,\n        setActive,\n        setAnimateFunction,\n        getState: () => state,\n        reset: () => {\n            state = createState();\n            isInitialRender = true;\n        },\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (Array.isArray(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive = false) {\n    return {\n        isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    return {\n        animate: createTypeState(true),\n        whileInView: createTypeState(),\n        whileHover: createTypeState(),\n        whileTap: createTypeState(),\n        whileDrag: createTypeState(),\n        whileFocus: createTypeState(),\n        exit: createTypeState(),\n    };\n}\n\nexport { checkVariantsDidChange, createAnimationState };\n","import { isAnimationControls } from '../../../animation/utils/is-animation-controls.mjs';\nimport { createAnimationState } from '../../../render/utils/animation-state.mjs';\nimport { Feature } from '../Feature.mjs';\n\nclass AnimationFeature extends Feature {\n    /**\n     * We dynamically generate the AnimationState manager as it contains a reference\n     * to the underlying animation library. We only want to load that if we load this,\n     * so people can optionally code split it out using the `m` component.\n     */\n    constructor(node) {\n        super(node);\n        node.animationState || (node.animationState = createAnimationState(node));\n    }\n    updateAnimationControlsSubscription() {\n        const { animate } = this.node.getProps();\n        if (isAnimationControls(animate)) {\n            this.unmountControls = animate.subscribe(this.node);\n        }\n    }\n    /**\n     * Subscribe any provided AnimationControls to the component's VisualElement\n     */\n    mount() {\n        this.updateAnimationControlsSubscription();\n    }\n    update() {\n        const { animate } = this.node.getProps();\n        const { animate: prevAnimate } = this.node.prevProps || {};\n        if (animate !== prevAnimate) {\n            this.updateAnimationControlsSubscription();\n        }\n    }\n    unmount() {\n        var _a;\n        this.node.animationState.reset();\n        (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n}\n\nexport { AnimationFeature };\n","import { Feature } from '../Feature.mjs';\n\nlet id = 0;\nclass ExitAnimationFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.id = id++;\n    }\n    update() {\n        if (!this.node.presenceContext)\n            return;\n        const { isPresent, onExitComplete } = this.node.presenceContext;\n        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};\n        if (!this.node.animationState || isPresent === prevIsPresent) {\n            return;\n        }\n        const exitAnimation = this.node.animationState.setActive(\"exit\", !isPresent);\n        if (onExitComplete && !isPresent) {\n            exitAnimation.then(() => onExitComplete(this.id));\n        }\n    }\n    mount() {\n        const { register } = this.node.presenceContext || {};\n        if (register) {\n            this.unmount = register(this.id);\n        }\n    }\n    unmount() { }\n}\n\nexport { ExitAnimationFeature };\n","import { AnimationFeature } from './animation/index.mjs';\nimport { ExitAnimationFeature } from './animation/exit.mjs';\n\nconst animations = {\n    animation: {\n        Feature: AnimationFeature,\n    },\n    exit: {\n        Feature: ExitAnimationFeature,\n    },\n};\n\nexport { animations };\n","/**\n * This should only ever be modified on the client otherwise it'll\n * persist through server requests. If we need instanced states we\n * could lazy-init via root.\n */\nconst globalProjectionState = {\n    /**\n     * Global flag as to whether the tree has animated since the last time\n     * we resized the window\n     */\n    hasAnimatedSinceResize: true,\n    /**\n     * We set this to true once, on the first update. Any nodes added to the tree beyond that\n     * update will be given a `data-projection-id` attribute.\n     */\n    hasEverUpdated: false,\n};\n\nexport { globalProjectionState };\n","import { px } from '../../value/types/numbers/units.mjs';\n\nfunction pixelsToPercent(pixels, axis) {\n    if (axis.max === axis.min)\n        return 0;\n    return (pixels / (axis.max - axis.min)) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\nconst correctBorderRadius = {\n    correct: (latest, node) => {\n        if (!node.target)\n            return latest;\n        /**\n         * If latest is a string, if it's a percentage we can return immediately as it's\n         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n         */\n        if (typeof latest === \"string\") {\n            if (px.test(latest)) {\n                latest = parseFloat(latest);\n            }\n            else {\n                return latest;\n            }\n        }\n        /**\n         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n         * pixel value as a percentage of each axis\n         */\n        const x = pixelsToPercent(latest, node.target.x);\n        const y = pixelsToPercent(latest, node.target.y);\n        return `${x}% ${y}%`;\n    },\n};\n\nexport { correctBorderRadius, pixelsToPercent };\n","import { mixNumber } from '../../utils/mix/number.mjs';\nimport { complex } from '../../value/types/complex/index.mjs';\n\nconst correctBoxShadow = {\n    correct: (latest, { treeScale, projectionDelta }) => {\n        const original = latest;\n        const shadow = complex.parse(latest);\n        // TODO: Doesn't support multiple shadows\n        if (shadow.length > 5)\n            return original;\n        const template = complex.createTransformer(latest);\n        const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n        // Calculate the overall context scale\n        const xScale = projectionDelta.x.scale * treeScale.x;\n        const yScale = projectionDelta.y.scale * treeScale.y;\n        shadow[0 + offset] /= xScale;\n        shadow[1 + offset] /= yScale;\n        /**\n         * Ideally we'd correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */\n        const averageScale = mixNumber(xScale, yScale, 0.5);\n        // Blur\n        if (typeof shadow[2 + offset] === \"number\")\n            shadow[2 + offset] /= averageScale;\n        // Spread\n        if (typeof shadow[3 + offset] === \"number\")\n            shadow[3 + offset] /= averageScale;\n        return template(shadow);\n    },\n};\n\nexport { correctBoxShadow };\n","const scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n    Object.assign(scaleCorrectors, correctors);\n}\n\nexport { addScaleCorrector, scaleCorrectors };\n","\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport { useContext, Component } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\nimport { microtask } from '../../../frameloop/microtask.mjs';\nimport { frame } from '../../../frameloop/frame.mjs';\n\nclass MeasureLayoutWithContext extends Component {\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */\n    componentDidMount() {\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\n        const { projection } = visualElement;\n        addScaleCorrector(defaultScaleCorrectors);\n        if (projection) {\n            if (layoutGroup.group)\n                layoutGroup.group.add(projection);\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n                switchLayoutGroup.register(projection);\n            }\n            projection.root.didUpdate();\n            projection.addEventListener(\"animationComplete\", () => {\n                this.safeToRemove();\n            });\n            projection.setOptions({\n                ...projection.options,\n                onExitComplete: () => this.safeToRemove(),\n            });\n        }\n        globalProjectionState.hasEverUpdated = true;\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n        const { layoutDependency, visualElement, drag, isPresent } = this.props;\n        const projection = visualElement.projection;\n        if (!projection)\n            return null;\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There's no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */\n        projection.isPresent = isPresent;\n        if (drag ||\n            prevProps.layoutDependency !== layoutDependency ||\n            layoutDependency === undefined) {\n            projection.willUpdate();\n        }\n        else {\n            this.safeToRemove();\n        }\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote();\n            }\n            else if (!projection.relegate()) {\n                /**\n                 * If there's another stack member taking over from this one,\n                 * it's in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */\n                frame.postRender(() => {\n                    const stack = projection.getStack();\n                    if (!stack || !stack.members.length) {\n                        this.safeToRemove();\n                    }\n                });\n            }\n        }\n        return null;\n    }\n    componentDidUpdate() {\n        const { projection } = this.props.visualElement;\n        if (projection) {\n            projection.root.didUpdate();\n            microtask.postRender(() => {\n                if (!projection.currentAnimation && projection.isLead()) {\n                    this.safeToRemove();\n                }\n            });\n        }\n    }\n    componentWillUnmount() {\n        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;\n        const { projection } = visualElement;\n        if (projection) {\n            projection.scheduleCheckAfterUnmount();\n            if (layoutGroup && layoutGroup.group)\n                layoutGroup.group.remove(projection);\n            if (promoteContext && promoteContext.deregister)\n                promoteContext.deregister(projection);\n        }\n    }\n    safeToRemove() {\n        const { safeToRemove } = this.props;\n        safeToRemove && safeToRemove();\n    }\n    render() {\n        return null;\n    }\n}\nfunction MeasureLayout(props) {\n    const [isPresent, safeToRemove] = usePresence();\n    const layoutGroup = useContext(LayoutGroupContext);\n    return (jsx(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));\n}\nconst defaultScaleCorrectors = {\n    borderRadius: {\n        ...correctBorderRadius,\n        applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ],\n    },\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow,\n};\n\nexport { MeasureLayout };\n","const compareByDepth = (a, b) => a.depth - b.depth;\n\nexport { compareByDepth };\n","import { addUniqueItem, removeItem } from '../../utils/array.mjs';\nimport { compareByDepth } from './compare-by-depth.mjs';\n\nclass FlatTree {\n    constructor() {\n        this.children = [];\n        this.isDirty = false;\n    }\n    add(child) {\n        addUniqueItem(this.children, child);\n        this.isDirty = true;\n    }\n    remove(child) {\n        removeItem(this.children, child);\n        this.isDirty = true;\n    }\n    forEach(callback) {\n        this.isDirty && this.children.sort(compareByDepth);\n        this.isDirty = false;\n        this.children.forEach(callback);\n    }\n}\n\nexport { FlatTree };\n","import { secondsToMilliseconds } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { frame, cancelFrame } from '../frameloop/frame.mjs';\n\n/**\n * Timeout defined in ms\n */\nfunction delay(callback, timeout) {\n    const start = time.now();\n    const checkElapsed = ({ timestamp }) => {\n        const elapsed = timestamp - start;\n        if (elapsed >= timeout) {\n            cancelFrame(checkElapsed);\n            callback(elapsed - timeout);\n        }\n    };\n    frame.read(checkElapsed, true);\n    return () => cancelFrame(checkElapsed);\n}\nfunction delayInSeconds(callback, timeout) {\n    return delay(callback, secondsToMilliseconds(timeout));\n}\n\nexport { delay, delayInSeconds };\n","import { progress, noop } from 'motion-utils';\nimport { circOut } from '../../easing/circ.mjs';\nimport { mixNumber } from '../../utils/mix/number.mjs';\nimport { percent, px } from '../../value/types/numbers/units.mjs';\n\nconst borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nconst numBorders = borders.length;\nconst asNumber = (value) => typeof value === \"string\" ? parseFloat(value) : value;\nconst isPx = (value) => typeof value === \"number\" || px.test(value);\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n    if (shouldCrossfadeOpacity) {\n        target.opacity = mixNumber(0, \n        // TODO Reinstate this if only child\n        lead.opacity !== undefined ? lead.opacity : 1, easeCrossfadeIn(progress));\n        target.opacityExit = mixNumber(follow.opacity !== undefined ? follow.opacity : 1, 0, easeCrossfadeOut(progress));\n    }\n    else if (isOnlyMember) {\n        target.opacity = mixNumber(follow.opacity !== undefined ? follow.opacity : 1, lead.opacity !== undefined ? lead.opacity : 1, progress);\n    }\n    /**\n     * Mix border radius\n     */\n    for (let i = 0; i < numBorders; i++) {\n        const borderLabel = `border${borders[i]}Radius`;\n        let followRadius = getRadius(follow, borderLabel);\n        let leadRadius = getRadius(lead, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        const canMix = followRadius === 0 ||\n            leadRadius === 0 ||\n            isPx(followRadius) === isPx(leadRadius);\n        if (canMix) {\n            target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\n                target[borderLabel] += \"%\";\n            }\n        }\n        else {\n            target[borderLabel] = leadRadius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (follow.rotate || lead.rotate) {\n        target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress);\n    }\n}\nfunction getRadius(values, radiusName) {\n    return values[radiusName] !== undefined\n        ? values[radiusName]\n        : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nconst easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);\nconst easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop);\nfunction compress(min, max, easing) {\n    return (p) => {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\n\nexport { mixValues };\n","/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyAxisInto(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyBoxInto(box, originBox) {\n    copyAxisInto(box.x, originBox.x);\n    copyAxisInto(box.y, originBox.y);\n}\n/**\n * Reset a delta to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyAxisDeltaInto(delta, originDelta) {\n    delta.translate = originDelta.translate;\n    delta.scale = originDelta.scale;\n    delta.originPoint = originDelta.originPoint;\n    delta.origin = originDelta.origin;\n}\n\nexport { copyAxisDeltaInto, copyAxisInto, copyBoxInto };\n","import { mixNumber } from '../../utils/mix/number.mjs';\nimport { percent } from '../../value/types/numbers/units.mjs';\nimport { scalePoint } from './delta-apply.mjs';\n\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point -= translate;\n    point = scalePoint(point, 1 / scale, originPoint);\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint);\n    }\n    return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nfunction removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {\n    if (percent.test(translate)) {\n        translate = parseFloat(translate);\n        const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);\n        translate = relativeProgress - sourceAxis.min;\n    }\n    if (typeof translate !== \"number\")\n        return;\n    let originPoint = mixNumber(originAxis.min, originAxis.max, origin);\n    if (axis === originAxis)\n        originPoint -= translate;\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nconst xKeys = [\"x\", \"scaleX\", \"originX\"];\nconst yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\n    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);\n    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);\n}\n\nexport { removeAxisDelta, removeAxisTransforms, removeBoxTransforms, removePointDelta };\n","import { calcLength } from './delta-calc.mjs';\n\nfunction isAxisDeltaZero(delta) {\n    return delta.translate === 0 && delta.scale === 1;\n}\nfunction isDeltaZero(delta) {\n    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\n}\nfunction axisEquals(a, b) {\n    return a.min === b.min && a.max === b.max;\n}\nfunction boxEquals(a, b) {\n    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);\n}\nfunction axisEqualsRounded(a, b) {\n    return (Math.round(a.min) === Math.round(b.min) &&\n        Math.round(a.max) === Math.round(b.max));\n}\nfunction boxEqualsRounded(a, b) {\n    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);\n}\nfunction aspectRatio(box) {\n    return calcLength(box.x) / calcLength(box.y);\n}\nfunction axisDeltaEquals(a, b) {\n    return (a.translate === b.translate &&\n        a.scale === b.scale &&\n        a.originPoint === b.originPoint);\n}\n\nexport { aspectRatio, axisDeltaEquals, axisEquals, axisEqualsRounded, boxEquals, boxEqualsRounded, isDeltaZero };\n","import { addUniqueItem, removeItem } from '../../utils/array.mjs';\n\nclass NodeStack {\n    constructor() {\n        this.members = [];\n    }\n    add(node) {\n        addUniqueItem(this.members, node);\n        node.scheduleRender();\n    }\n    remove(node) {\n        removeItem(this.members, node);\n        if (node === this.prevLead) {\n            this.prevLead = undefined;\n        }\n        if (node === this.lead) {\n            const prevLead = this.members[this.members.length - 1];\n            if (prevLead) {\n                this.promote(prevLead);\n            }\n        }\n    }\n    relegate(node) {\n        const indexOfNode = this.members.findIndex((member) => node === member);\n        if (indexOfNode === 0)\n            return false;\n        /**\n         * Find the next projection node that is present\n         */\n        let prevLead;\n        for (let i = indexOfNode; i >= 0; i--) {\n            const member = this.members[i];\n            if (member.isPresent !== false) {\n                prevLead = member;\n                break;\n            }\n        }\n        if (prevLead) {\n            this.promote(prevLead);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    promote(node, preserveFollowOpacity) {\n        const prevLead = this.lead;\n        if (node === prevLead)\n            return;\n        this.prevLead = prevLead;\n        this.lead = node;\n        node.show();\n        if (prevLead) {\n            prevLead.instance && prevLead.scheduleRender();\n            node.scheduleRender();\n            node.resumeFrom = prevLead;\n            if (preserveFollowOpacity) {\n                node.resumeFrom.preserveOpacity = true;\n            }\n            if (prevLead.snapshot) {\n                node.snapshot = prevLead.snapshot;\n                node.snapshot.latestValues =\n                    prevLead.animationValues || prevLead.latestValues;\n            }\n            if (node.root && node.root.isUpdating) {\n                node.isLayoutDirty = true;\n            }\n            const { crossfade } = node.options;\n            if (crossfade === false) {\n                prevLead.hide();\n            }\n            /**\n             * TODO:\n             *   - Test border radius when previous node was deleted\n             *   - boxShadow mixing\n             *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)\n             *   - Shared between element A in transformed container and element B (transform stays the same or changes)\n             *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)\n             * ---\n             *   - Crossfade opacity of root nodes\n             *   - layoutId changes after animation\n             *   - layoutId changes mid animation\n             */\n        }\n    }\n    exitAnimationComplete() {\n        this.members.forEach((node) => {\n            const { options, resumingFrom } = node;\n            options.onExitComplete && options.onExitComplete();\n            if (resumingFrom) {\n                resumingFrom.options.onExitComplete &&\n                    resumingFrom.options.onExitComplete();\n            }\n        });\n    }\n    scheduleRender() {\n        this.members.forEach((node) => {\n            node.instance && node.scheduleRender(false);\n        });\n    }\n    /**\n     * Clear any leads that have been removed this render to prevent them from being\n     * used in future animations and to prevent memory leaks\n     */\n    removeLeadSnapshot() {\n        if (this.lead && this.lead.snapshot) {\n            this.lead.snapshot = undefined;\n        }\n    }\n}\n\nexport { NodeStack };\n","import { getValueTransition } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { animateSingleValue } from '../../animation/animate/single-value.mjs';\nimport { getOptimisedAppearId } from '../../animation/optimized-appear/get-appear-id.mjs';\nimport { cancelFrame, frameData, frameSteps, frame } from '../../frameloop/frame.mjs';\nimport { microtask } from '../../frameloop/microtask.mjs';\nimport { time } from '../../frameloop/sync-time.mjs';\nimport { isSVGElement } from '../../render/dom/utils/is-svg-element.mjs';\nimport { FlatTree } from '../../render/utils/flat-tree.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { delay } from '../../utils/delay.mjs';\nimport { mixNumber } from '../../utils/mix/number.mjs';\nimport { SubscriptionManager } from '../../utils/subscription-manager.mjs';\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\nimport { mixValues } from '../animation/mix-values.mjs';\nimport { copyBoxInto, copyAxisDeltaInto } from '../geometry/copy.mjs';\nimport { translateAxis, transformBox, applyBoxDelta, applyTreeDeltas } from '../geometry/delta-apply.mjs';\nimport { calcRelativePosition, calcRelativeBox, calcBoxDelta, calcLength, isNear } from '../geometry/delta-calc.mjs';\nimport { removeBoxTransforms } from '../geometry/delta-remove.mjs';\nimport { createBox, createDelta } from '../geometry/models.mjs';\nimport { boxEqualsRounded, isDeltaZero, axisDeltaEquals, aspectRatio, boxEquals } from '../geometry/utils.mjs';\nimport { NodeStack } from '../shared/stack.mjs';\nimport { scaleCorrectors } from '../styles/scale-correction.mjs';\nimport { buildProjectionTransform } from '../styles/transform.mjs';\nimport { eachAxis } from '../utils/each-axis.mjs';\nimport { hasTransform, hasScale, has2DTranslate } from '../utils/has-transform.mjs';\nimport { globalProjectionState } from './state.mjs';\n\nconst metrics = {\n    type: \"projectionFrame\",\n    totalNodes: 0,\n    resolvedTargetDeltas: 0,\n    recalculatedProjection: 0,\n};\nconst isDebug = typeof window !== \"undefined\" && window.MotionDebug !== undefined;\nconst transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\nconst hiddenVisibility = { visibility: \"hidden\" };\n/**\n * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1\n * which has a noticeable difference in spring animations\n */\nconst animationTarget = 1000;\nlet id = 0;\nfunction resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {\n    const { latestValues } = visualElement;\n    // Record the distorting transform and then temporarily set it to 0\n    if (latestValues[key]) {\n        values[key] = latestValues[key];\n        visualElement.setStaticValue(key, 0);\n        if (sharedAnimationValues) {\n            sharedAnimationValues[key] = 0;\n        }\n    }\n}\nfunction cancelTreeOptimisedTransformAnimations(projectionNode) {\n    projectionNode.hasCheckedOptimisedAppear = true;\n    if (projectionNode.root === projectionNode)\n        return;\n    const { visualElement } = projectionNode.options;\n    if (!visualElement)\n        return;\n    const appearId = getOptimisedAppearId(visualElement);\n    if (window.MotionHasOptimisedAnimation(appearId, \"transform\")) {\n        const { layout, layoutId } = projectionNode.options;\n        window.MotionCancelOptimisedAnimation(appearId, \"transform\", frame, !(layout || layoutId));\n    }\n    const { parent } = projectionNode;\n    if (parent && !parent.hasCheckedOptimisedAppear) {\n        cancelTreeOptimisedTransformAnimations(parent);\n    }\n}\nfunction createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform, }) {\n    return class ProjectionNode {\n        constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {\n            /**\n             * A unique ID generated for every projection node.\n             */\n            this.id = id++;\n            /**\n             * An id that represents a unique session instigated by startUpdate.\n             */\n            this.animationId = 0;\n            /**\n             * A Set containing all this component's children. This is used to iterate\n             * through the children.\n             *\n             * TODO: This could be faster to iterate as a flat array stored on the root node.\n             */\n            this.children = new Set();\n            /**\n             * Options for the node. We use this to configure what kind of layout animations\n             * we should perform (if any).\n             */\n            this.options = {};\n            /**\n             * We use this to detect when its safe to shut down part of a projection tree.\n             * We have to keep projecting children for scale correction and relative projection\n             * until all their parents stop performing layout animations.\n             */\n            this.isTreeAnimating = false;\n            this.isAnimationBlocked = false;\n            /**\n             * Flag to true if we think this layout has been changed. We can't always know this,\n             * currently we set it to true every time a component renders, or if it has a layoutDependency\n             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup\n             * and if one node is dirtied, they all are.\n             */\n            this.isLayoutDirty = false;\n            /**\n             * Flag to true if we think the projection calculations for this node needs\n             * recalculating as a result of an updated transform or layout animation.\n             */\n            this.isProjectionDirty = false;\n            /**\n             * Flag to true if the layout *or* transform has changed. This then gets propagated\n             * throughout the projection tree, forcing any element below to recalculate on the next frame.\n             */\n            this.isSharedProjectionDirty = false;\n            /**\n             * Flag transform dirty. This gets propagated throughout the whole tree but is only\n             * respected by shared nodes.\n             */\n            this.isTransformDirty = false;\n            /**\n             * Block layout updates for instant layout transitions throughout the tree.\n             */\n            this.updateManuallyBlocked = false;\n            this.updateBlockedByResize = false;\n            /**\n             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`\n             * call.\n             */\n            this.isUpdating = false;\n            /**\n             * If this is an SVG element we currently disable projection transforms\n             */\n            this.isSVG = false;\n            /**\n             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset\n             * its projection styles.\n             */\n            this.needsReset = false;\n            /**\n             * Flags whether this node should have its transform reset prior to measuring.\n             */\n            this.shouldResetTransform = false;\n            /**\n             * Store whether this node has been checked for optimised appear animations. As\n             * effects fire bottom-up, and we want to look up the tree for appear animations,\n             * this makes sure we only check each path once, stopping at nodes that\n             * have already been checked.\n             */\n            this.hasCheckedOptimisedAppear = false;\n            /**\n             * An object representing the calculated contextual/accumulated/tree scale.\n             * This will be used to scale calculcated projection transforms, as these are\n             * calculated in screen-space but need to be scaled for elements to layoutly\n             * make it to their calculated destinations.\n             *\n             * TODO: Lazy-init\n             */\n            this.treeScale = { x: 1, y: 1 };\n            /**\n             *\n             */\n            this.eventHandlers = new Map();\n            this.hasTreeAnimated = false;\n            // Note: Currently only running on root node\n            this.updateScheduled = false;\n            this.scheduleUpdate = () => this.update();\n            this.projectionUpdateScheduled = false;\n            this.checkUpdateFailed = () => {\n                if (this.isUpdating) {\n                    this.isUpdating = false;\n                    this.clearAllSnapshots();\n                }\n            };\n            /**\n             * This is a multi-step process as shared nodes might be of different depths. Nodes\n             * are sorted by depth order, so we need to resolve the entire tree before moving to\n             * the next step.\n             */\n            this.updateProjection = () => {\n                this.projectionUpdateScheduled = false;\n                /**\n                 * Reset debug counts. Manually resetting rather than creating a new\n                 * object each frame.\n                 */\n                if (isDebug) {\n                    metrics.totalNodes =\n                        metrics.resolvedTargetDeltas =\n                            metrics.recalculatedProjection =\n                                0;\n                }\n                this.nodes.forEach(propagateDirtyNodes);\n                this.nodes.forEach(resolveTargetDelta);\n                this.nodes.forEach(calcProjection);\n                this.nodes.forEach(cleanDirtyNodes);\n                if (isDebug) {\n                    window.MotionDebug.record(metrics);\n                }\n            };\n            /**\n             * Frame calculations\n             */\n            this.resolvedRelativeTargetAt = 0.0;\n            this.hasProjected = false;\n            this.isVisible = true;\n            this.animationProgress = 0;\n            /**\n             * Shared layout\n             */\n            // TODO Only running on root node\n            this.sharedNodes = new Map();\n            this.latestValues = latestValues;\n            this.root = parent ? parent.root || parent : this;\n            this.path = parent ? [...parent.path, parent] : [];\n            this.parent = parent;\n            this.depth = parent ? parent.depth + 1 : 0;\n            for (let i = 0; i < this.path.length; i++) {\n                this.path[i].shouldResetTransform = true;\n            }\n            if (this.root === this)\n                this.nodes = new FlatTree();\n        }\n        addEventListener(name, handler) {\n            if (!this.eventHandlers.has(name)) {\n                this.eventHandlers.set(name, new SubscriptionManager());\n            }\n            return this.eventHandlers.get(name).add(handler);\n        }\n        notifyListeners(name, ...args) {\n            const subscriptionManager = this.eventHandlers.get(name);\n            subscriptionManager && subscriptionManager.notify(...args);\n        }\n        hasListeners(name) {\n            return this.eventHandlers.has(name);\n        }\n        /**\n         * Lifecycles\n         */\n        mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {\n            if (this.instance)\n                return;\n            this.isSVG = isSVGElement(instance);\n            this.instance = instance;\n            const { layoutId, layout, visualElement } = this.options;\n            if (visualElement && !visualElement.current) {\n                visualElement.mount(instance);\n            }\n            this.root.nodes.add(this);\n            this.parent && this.parent.children.add(this);\n            if (isLayoutDirty && (layout || layoutId)) {\n                this.isLayoutDirty = true;\n            }\n            if (attachResizeListener) {\n                let cancelDelay;\n                const resizeUnblockUpdate = () => (this.root.updateBlockedByResize = false);\n                attachResizeListener(instance, () => {\n                    this.root.updateBlockedByResize = true;\n                    cancelDelay && cancelDelay();\n                    cancelDelay = delay(resizeUnblockUpdate, 250);\n                    if (globalProjectionState.hasAnimatedSinceResize) {\n                        globalProjectionState.hasAnimatedSinceResize = false;\n                        this.nodes.forEach(finishAnimation);\n                    }\n                });\n            }\n            if (layoutId) {\n                this.root.registerSharedNode(layoutId, this);\n            }\n            // Only register the handler if it requires layout animation\n            if (this.options.animate !== false &&\n                visualElement &&\n                (layoutId || layout)) {\n                this.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout, }) => {\n                    if (this.isTreeAnimationBlocked()) {\n                        this.target = undefined;\n                        this.relativeTarget = undefined;\n                        return;\n                    }\n                    // TODO: Check here if an animation exists\n                    const layoutTransition = this.options.transition ||\n                        visualElement.getDefaultTransition() ||\n                        defaultLayoutTransition;\n                    const { onLayoutAnimationStart, onLayoutAnimationComplete, } = visualElement.getProps();\n                    /**\n                     * The target layout of the element might stay the same,\n                     * but its position relative to its parent has changed.\n                     */\n                    const targetChanged = !this.targetLayout ||\n                        !boxEqualsRounded(this.targetLayout, newLayout) ||\n                        hasRelativeTargetChanged;\n                    /**\n                     * If the layout hasn't seemed to have changed, it might be that the\n                     * element is visually in the same place in the document but its position\n                     * relative to its parent has indeed changed. So here we check for that.\n                     */\n                    const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;\n                    if (this.options.layoutRoot ||\n                        (this.resumeFrom && this.resumeFrom.instance) ||\n                        hasOnlyRelativeTargetChanged ||\n                        (hasLayoutChanged &&\n                            (targetChanged || !this.currentAnimation))) {\n                        if (this.resumeFrom) {\n                            this.resumingFrom = this.resumeFrom;\n                            this.resumingFrom.resumingFrom = undefined;\n                        }\n                        this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n                        const animationOptions = {\n                            ...getValueTransition(layoutTransition, \"layout\"),\n                            onPlay: onLayoutAnimationStart,\n                            onComplete: onLayoutAnimationComplete,\n                        };\n                        if (visualElement.shouldReduceMotion ||\n                            this.options.layoutRoot) {\n                            animationOptions.delay = 0;\n                            animationOptions.type = false;\n                        }\n                        this.startAnimation(animationOptions);\n                    }\n                    else {\n                        /**\n                         * If the layout hasn't changed and we have an animation that hasn't started yet,\n                         * finish it immediately. Otherwise it will be animating from a location\n                         * that was probably never commited to screen and look like a jumpy box.\n                         */\n                        if (!hasLayoutChanged) {\n                            finishAnimation(this);\n                        }\n                        if (this.isLead() && this.options.onExitComplete) {\n                            this.options.onExitComplete();\n                        }\n                    }\n                    this.targetLayout = newLayout;\n                });\n            }\n        }\n        unmount() {\n            this.options.layoutId && this.willUpdate();\n            this.root.nodes.remove(this);\n            const stack = this.getStack();\n            stack && stack.remove(this);\n            this.parent && this.parent.children.delete(this);\n            this.instance = undefined;\n            cancelFrame(this.updateProjection);\n        }\n        // only on the root\n        blockUpdate() {\n            this.updateManuallyBlocked = true;\n        }\n        unblockUpdate() {\n            this.updateManuallyBlocked = false;\n        }\n        isUpdateBlocked() {\n            return this.updateManuallyBlocked || this.updateBlockedByResize;\n        }\n        isTreeAnimationBlocked() {\n            return (this.isAnimationBlocked ||\n                (this.parent && this.parent.isTreeAnimationBlocked()) ||\n                false);\n        }\n        // Note: currently only running on root node\n        startUpdate() {\n            if (this.isUpdateBlocked())\n                return;\n            this.isUpdating = true;\n            this.nodes && this.nodes.forEach(resetSkewAndRotation);\n            this.animationId++;\n        }\n        getTransformTemplate() {\n            const { visualElement } = this.options;\n            return visualElement && visualElement.getProps().transformTemplate;\n        }\n        willUpdate(shouldNotifyListeners = true) {\n            this.root.hasTreeAnimated = true;\n            if (this.root.isUpdateBlocked()) {\n                this.options.onExitComplete && this.options.onExitComplete();\n                return;\n            }\n            /**\n             * If we're running optimised appear animations then these must be\n             * cancelled before measuring the DOM. This is so we can measure\n             * the true layout of the element rather than the WAAPI animation\n             * which will be unaffected by the resetSkewAndRotate step.\n             *\n             * Note: This is a DOM write. Worst case scenario is this is sandwiched\n             * between other snapshot reads which will cause unnecessary style recalculations.\n             * This has to happen here though, as we don't yet know which nodes will need\n             * snapshots in startUpdate(), but we only want to cancel optimised animations\n             * if a layout animation measurement is actually going to be affected by them.\n             */\n            if (window.MotionCancelOptimisedAnimation &&\n                !this.hasCheckedOptimisedAppear) {\n                cancelTreeOptimisedTransformAnimations(this);\n            }\n            !this.root.isUpdating && this.root.startUpdate();\n            if (this.isLayoutDirty)\n                return;\n            this.isLayoutDirty = true;\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                node.shouldResetTransform = true;\n                node.updateScroll(\"snapshot\");\n                if (node.options.layoutRoot) {\n                    node.willUpdate(false);\n                }\n            }\n            const { layoutId, layout } = this.options;\n            if (layoutId === undefined && !layout)\n                return;\n            const transformTemplate = this.getTransformTemplate();\n            this.prevTransformTemplateValue = transformTemplate\n                ? transformTemplate(this.latestValues, \"\")\n                : undefined;\n            this.updateSnapshot();\n            shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\n        }\n        update() {\n            this.updateScheduled = false;\n            const updateWasBlocked = this.isUpdateBlocked();\n            // When doing an instant transition, we skip the layout update,\n            // but should still clean up the measurements so that the next\n            // snapshot could be taken correctly.\n            if (updateWasBlocked) {\n                this.unblockUpdate();\n                this.clearAllSnapshots();\n                this.nodes.forEach(clearMeasurements);\n                return;\n            }\n            if (!this.isUpdating) {\n                this.nodes.forEach(clearIsLayoutDirty);\n            }\n            this.isUpdating = false;\n            /**\n             * Write\n             */\n            this.nodes.forEach(resetTransformStyle);\n            /**\n             * Read ==================\n             */\n            // Update layout measurements of updated children\n            this.nodes.forEach(updateLayout);\n            /**\n             * Write\n             */\n            // Notify listeners that the layout is updated\n            this.nodes.forEach(notifyLayoutUpdate);\n            this.clearAllSnapshots();\n            /**\n             * Manually flush any pending updates. Ideally\n             * we could leave this to the following requestAnimationFrame but this seems\n             * to leave a flash of incorrectly styled content.\n             */\n            const now = time.now();\n            frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);\n            frameData.timestamp = now;\n            frameData.isProcessing = true;\n            frameSteps.update.process(frameData);\n            frameSteps.preRender.process(frameData);\n            frameSteps.render.process(frameData);\n            frameData.isProcessing = false;\n        }\n        didUpdate() {\n            if (!this.updateScheduled) {\n                this.updateScheduled = true;\n                microtask.read(this.scheduleUpdate);\n            }\n        }\n        clearAllSnapshots() {\n            this.nodes.forEach(clearSnapshot);\n            this.sharedNodes.forEach(removeLeadSnapshots);\n        }\n        scheduleUpdateProjection() {\n            if (!this.projectionUpdateScheduled) {\n                this.projectionUpdateScheduled = true;\n                frame.preRender(this.updateProjection, false, true);\n            }\n        }\n        scheduleCheckAfterUnmount() {\n            /**\n             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,\n             * we manually call didUpdate to give a chance to the siblings to animate.\n             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.\n             */\n            frame.postRender(() => {\n                if (this.isLayoutDirty) {\n                    this.root.didUpdate();\n                }\n                else {\n                    this.root.checkUpdateFailed();\n                }\n            });\n        }\n        /**\n         * Update measurements\n         */\n        updateSnapshot() {\n            if (this.snapshot || !this.instance)\n                return;\n            this.snapshot = this.measure();\n        }\n        updateLayout() {\n            if (!this.instance)\n                return;\n            // TODO: Incorporate into a forwarded scroll offset\n            this.updateScroll();\n            if (!(this.options.alwaysMeasureLayout && this.isLead()) &&\n                !this.isLayoutDirty) {\n                return;\n            }\n            /**\n             * When a node is mounted, it simply resumes from the prevLead's\n             * snapshot instead of taking a new one, but the ancestors scroll\n             * might have updated while the prevLead is unmounted. We need to\n             * update the scroll again to make sure the layout we measure is\n             * up to date.\n             */\n            if (this.resumeFrom && !this.resumeFrom.instance) {\n                for (let i = 0; i < this.path.length; i++) {\n                    const node = this.path[i];\n                    node.updateScroll();\n                }\n            }\n            const prevLayout = this.layout;\n            this.layout = this.measure(false);\n            this.layoutCorrected = createBox();\n            this.isLayoutDirty = false;\n            this.projectionDelta = undefined;\n            this.notifyListeners(\"measure\", this.layout.layoutBox);\n            const { visualElement } = this.options;\n            visualElement &&\n                visualElement.notify(\"LayoutMeasure\", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);\n        }\n        updateScroll(phase = \"measure\") {\n            let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);\n            if (this.scroll &&\n                this.scroll.animationId === this.root.animationId &&\n                this.scroll.phase === phase) {\n                needsMeasurement = false;\n            }\n            if (needsMeasurement) {\n                const isRoot = checkIsScrollRoot(this.instance);\n                this.scroll = {\n                    animationId: this.root.animationId,\n                    phase,\n                    isRoot,\n                    offset: measureScroll(this.instance),\n                    wasRoot: this.scroll ? this.scroll.isRoot : isRoot,\n                };\n            }\n        }\n        resetTransform() {\n            if (!resetTransform)\n                return;\n            const isResetRequested = this.isLayoutDirty ||\n                this.shouldResetTransform ||\n                this.options.alwaysMeasureLayout;\n            const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n            const transformTemplate = this.getTransformTemplate();\n            const transformTemplateValue = transformTemplate\n                ? transformTemplate(this.latestValues, \"\")\n                : undefined;\n            const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n            if (isResetRequested &&\n                (hasProjection ||\n                    hasTransform(this.latestValues) ||\n                    transformTemplateHasChanged)) {\n                resetTransform(this.instance, transformTemplateValue);\n                this.shouldResetTransform = false;\n                this.scheduleRender();\n            }\n        }\n        measure(removeTransform = true) {\n            const pageBox = this.measurePageBox();\n            let layoutBox = this.removeElementScroll(pageBox);\n            /**\n             * Measurements taken during the pre-render stage\n             * still have transforms applied so we remove them\n             * via calculation.\n             */\n            if (removeTransform) {\n                layoutBox = this.removeTransform(layoutBox);\n            }\n            roundBox(layoutBox);\n            return {\n                animationId: this.root.animationId,\n                measuredBox: pageBox,\n                layoutBox,\n                latestValues: {},\n                source: this.id,\n            };\n        }\n        measurePageBox() {\n            var _a;\n            const { visualElement } = this.options;\n            if (!visualElement)\n                return createBox();\n            const box = visualElement.measureViewportBox();\n            const wasInScrollRoot = ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);\n            if (!wasInScrollRoot) {\n                // Remove viewport scroll to give page-relative coordinates\n                const { scroll } = this.root;\n                if (scroll) {\n                    translateAxis(box.x, scroll.offset.x);\n                    translateAxis(box.y, scroll.offset.y);\n                }\n            }\n            return box;\n        }\n        removeElementScroll(box) {\n            var _a;\n            const boxWithoutScroll = createBox();\n            copyBoxInto(boxWithoutScroll, box);\n            if ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) {\n                return boxWithoutScroll;\n            }\n            /**\n             * Performance TODO: Keep a cumulative scroll offset down the tree\n             * rather than loop back up the path.\n             */\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                const { scroll, options } = node;\n                if (node !== this.root && scroll && options.layoutScroll) {\n                    /**\n                     * If this is a new scroll root, we want to remove all previous scrolls\n                     * from the viewport box.\n                     */\n                    if (scroll.wasRoot) {\n                        copyBoxInto(boxWithoutScroll, box);\n                    }\n                    translateAxis(boxWithoutScroll.x, scroll.offset.x);\n                    translateAxis(boxWithoutScroll.y, scroll.offset.y);\n                }\n            }\n            return boxWithoutScroll;\n        }\n        applyTransform(box, transformOnly = false) {\n            const withTransforms = createBox();\n            copyBoxInto(withTransforms, box);\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                if (!transformOnly &&\n                    node.options.layoutScroll &&\n                    node.scroll &&\n                    node !== node.root) {\n                    transformBox(withTransforms, {\n                        x: -node.scroll.offset.x,\n                        y: -node.scroll.offset.y,\n                    });\n                }\n                if (!hasTransform(node.latestValues))\n                    continue;\n                transformBox(withTransforms, node.latestValues);\n            }\n            if (hasTransform(this.latestValues)) {\n                transformBox(withTransforms, this.latestValues);\n            }\n            return withTransforms;\n        }\n        removeTransform(box) {\n            const boxWithoutTransform = createBox();\n            copyBoxInto(boxWithoutTransform, box);\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                if (!node.instance)\n                    continue;\n                if (!hasTransform(node.latestValues))\n                    continue;\n                hasScale(node.latestValues) && node.updateSnapshot();\n                const sourceBox = createBox();\n                const nodeBox = node.measurePageBox();\n                copyBoxInto(sourceBox, nodeBox);\n                removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : undefined, sourceBox);\n            }\n            if (hasTransform(this.latestValues)) {\n                removeBoxTransforms(boxWithoutTransform, this.latestValues);\n            }\n            return boxWithoutTransform;\n        }\n        setTargetDelta(delta) {\n            this.targetDelta = delta;\n            this.root.scheduleUpdateProjection();\n            this.isProjectionDirty = true;\n        }\n        setOptions(options) {\n            this.options = {\n                ...this.options,\n                ...options,\n                crossfade: options.crossfade !== undefined ? options.crossfade : true,\n            };\n        }\n        clearMeasurements() {\n            this.scroll = undefined;\n            this.layout = undefined;\n            this.snapshot = undefined;\n            this.prevTransformTemplateValue = undefined;\n            this.targetDelta = undefined;\n            this.target = undefined;\n            this.isLayoutDirty = false;\n        }\n        forceRelativeParentToResolveTarget() {\n            if (!this.relativeParent)\n                return;\n            /**\n             * If the parent target isn't up-to-date, force it to update.\n             * This is an unfortunate de-optimisation as it means any updating relative\n             * projection will cause all the relative parents to recalculate back\n             * up the tree.\n             */\n            if (this.relativeParent.resolvedRelativeTargetAt !==\n                frameData.timestamp) {\n                this.relativeParent.resolveTargetDelta(true);\n            }\n        }\n        resolveTargetDelta(forceRecalculation = false) {\n            var _a;\n            /**\n             * Once the dirty status of nodes has been spread through the tree, we also\n             * need to check if we have a shared node of a different depth that has itself\n             * been dirtied.\n             */\n            const lead = this.getLead();\n            this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);\n            this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);\n            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\n            /**\n             * We don't use transform for this step of processing so we don't\n             * need to check whether any nodes have changed transform.\n             */\n            const canSkip = !(forceRecalculation ||\n                (isShared && this.isSharedProjectionDirty) ||\n                this.isProjectionDirty ||\n                ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) ||\n                this.attemptToResolveRelativeTarget ||\n                this.root.updateBlockedByResize);\n            if (canSkip)\n                return;\n            const { layout, layoutId } = this.options;\n            /**\n             * If we have no layout, we can't perform projection, so early return\n             */\n            if (!this.layout || !(layout || layoutId))\n                return;\n            this.resolvedRelativeTargetAt = frameData.timestamp;\n            /**\n             * If we don't have a targetDelta but do have a layout, we can attempt to resolve\n             * a relativeParent. This will allow a component to perform scale correction\n             * even if no animation has started.\n             */\n            if (!this.targetDelta && !this.relativeTarget) {\n                const relativeParent = this.getClosestProjectingParent();\n                if (relativeParent &&\n                    relativeParent.layout &&\n                    this.animationProgress !== 1) {\n                    this.relativeParent = relativeParent;\n                    this.forceRelativeParentToResolveTarget();\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n                else {\n                    this.relativeParent = this.relativeTarget = undefined;\n                }\n            }\n            /**\n             * If we have no relative target or no target delta our target isn't valid\n             * for this frame.\n             */\n            if (!this.relativeTarget && !this.targetDelta)\n                return;\n            /**\n             * Lazy-init target data structure\n             */\n            if (!this.target) {\n                this.target = createBox();\n                this.targetWithTransforms = createBox();\n            }\n            /**\n             * If we've got a relative box for this component, resolve it into a target relative to the parent.\n             */\n            if (this.relativeTarget &&\n                this.relativeTargetOrigin &&\n                this.relativeParent &&\n                this.relativeParent.target) {\n                this.forceRelativeParentToResolveTarget();\n                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n                /**\n                 * If we've only got a targetDelta, resolve it into a target\n                 */\n            }\n            else if (this.targetDelta) {\n                if (Boolean(this.resumingFrom)) {\n                    // TODO: This is creating a new object every frame\n                    this.target = this.applyTransform(this.layout.layoutBox);\n                }\n                else {\n                    copyBoxInto(this.target, this.layout.layoutBox);\n                }\n                applyBoxDelta(this.target, this.targetDelta);\n            }\n            else {\n                /**\n                 * If no target, use own layout as target\n                 */\n                copyBoxInto(this.target, this.layout.layoutBox);\n            }\n            /**\n             * If we've been told to attempt to resolve a relative target, do so.\n             */\n            if (this.attemptToResolveRelativeTarget) {\n                this.attemptToResolveRelativeTarget = false;\n                const relativeParent = this.getClosestProjectingParent();\n                if (relativeParent &&\n                    Boolean(relativeParent.resumingFrom) ===\n                        Boolean(this.resumingFrom) &&\n                    !relativeParent.options.layoutScroll &&\n                    relativeParent.target &&\n                    this.animationProgress !== 1) {\n                    this.relativeParent = relativeParent;\n                    this.forceRelativeParentToResolveTarget();\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n                else {\n                    this.relativeParent = this.relativeTarget = undefined;\n                }\n            }\n            /**\n             * Increase debug counter for resolved target deltas\n             */\n            if (isDebug) {\n                metrics.resolvedTargetDeltas++;\n            }\n        }\n        getClosestProjectingParent() {\n            if (!this.parent ||\n                hasScale(this.parent.latestValues) ||\n                has2DTranslate(this.parent.latestValues)) {\n                return undefined;\n            }\n            if (this.parent.isProjecting()) {\n                return this.parent;\n            }\n            else {\n                return this.parent.getClosestProjectingParent();\n            }\n        }\n        isProjecting() {\n            return Boolean((this.relativeTarget ||\n                this.targetDelta ||\n                this.options.layoutRoot) &&\n                this.layout);\n        }\n        calcProjection() {\n            var _a;\n            const lead = this.getLead();\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\n            let canSkip = true;\n            /**\n             * If this is a normal layout animation and neither this node nor its nearest projecting\n             * is dirty then we can't skip.\n             */\n            if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {\n                canSkip = false;\n            }\n            /**\n             * If this is a shared layout animation and this node's shared projection is dirty then\n             * we can't skip.\n             */\n            if (isShared &&\n                (this.isSharedProjectionDirty || this.isTransformDirty)) {\n                canSkip = false;\n            }\n            /**\n             * If we have resolved the target this frame we must recalculate the\n             * projection to ensure it visually represents the internal calculations.\n             */\n            if (this.resolvedRelativeTargetAt === frameData.timestamp) {\n                canSkip = false;\n            }\n            if (canSkip)\n                return;\n            const { layout, layoutId } = this.options;\n            /**\n             * If this section of the tree isn't animating we can\n             * delete our target sources for the following frame.\n             */\n            this.isTreeAnimating = Boolean((this.parent && this.parent.isTreeAnimating) ||\n                this.currentAnimation ||\n                this.pendingAnimation);\n            if (!this.isTreeAnimating) {\n                this.targetDelta = this.relativeTarget = undefined;\n            }\n            if (!this.layout || !(layout || layoutId))\n                return;\n            /**\n             * Reset the corrected box with the latest values from box, as we're then going\n             * to perform mutative operations on it.\n             */\n            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);\n            /**\n             * Record previous tree scales before updating.\n             */\n            const prevTreeScaleX = this.treeScale.x;\n            const prevTreeScaleY = this.treeScale.y;\n            /**\n             * Apply all the parent deltas to this box to produce the corrected box. This\n             * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n             */\n            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);\n            /**\n             * If this layer needs to perform scale correction but doesn't have a target,\n             * use the layout as the target.\n             */\n            if (lead.layout &&\n                !lead.target &&\n                (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {\n                lead.target = lead.layout.layoutBox;\n                lead.targetWithTransforms = createBox();\n            }\n            const { target } = lead;\n            if (!target) {\n                /**\n                 * If we don't have a target to project into, but we were previously\n                 * projecting, we want to remove the stored transform and schedule\n                 * a render to ensure the elements reflect the removed transform.\n                 */\n                if (this.prevProjectionDelta) {\n                    this.createProjectionDeltas();\n                    this.scheduleRender();\n                }\n                return;\n            }\n            if (!this.projectionDelta || !this.prevProjectionDelta) {\n                this.createProjectionDeltas();\n            }\n            else {\n                copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);\n                copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);\n            }\n            /**\n             * Update the delta between the corrected box and the target box before user-set transforms were applied.\n             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n             * for our layout reprojection, but still allow them to be scaled correctly by the user.\n             * It might be that to simplify this we may want to accept that user-set scale is also corrected\n             * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n             * to allow people to choose whether these styles are corrected based on just the\n             * layout reprojection or the final bounding box.\n             */\n            calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n            if (this.treeScale.x !== prevTreeScaleX ||\n                this.treeScale.y !== prevTreeScaleY ||\n                !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) ||\n                !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {\n                this.hasProjected = true;\n                this.scheduleRender();\n                this.notifyListeners(\"projectionUpdate\", target);\n            }\n            /**\n             * Increase debug counter for recalculated projections\n             */\n            if (isDebug) {\n                metrics.recalculatedProjection++;\n            }\n        }\n        hide() {\n            this.isVisible = false;\n            // TODO: Schedule render\n        }\n        show() {\n            this.isVisible = true;\n            // TODO: Schedule render\n        }\n        scheduleRender(notifyAll = true) {\n            var _a;\n            (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.scheduleRender();\n            if (notifyAll) {\n                const stack = this.getStack();\n                stack && stack.scheduleRender();\n            }\n            if (this.resumingFrom && !this.resumingFrom.instance) {\n                this.resumingFrom = undefined;\n            }\n        }\n        createProjectionDeltas() {\n            this.prevProjectionDelta = createDelta();\n            this.projectionDelta = createDelta();\n            this.projectionDeltaWithTransform = createDelta();\n        }\n        setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {\n            const snapshot = this.snapshot;\n            const snapshotLatestValues = snapshot\n                ? snapshot.latestValues\n                : {};\n            const mixedValues = { ...this.latestValues };\n            const targetDelta = createDelta();\n            if (!this.relativeParent ||\n                !this.relativeParent.options.layoutRoot) {\n                this.relativeTarget = this.relativeTargetOrigin = undefined;\n            }\n            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n            const relativeLayout = createBox();\n            const snapshotSource = snapshot ? snapshot.source : undefined;\n            const layoutSource = this.layout ? this.layout.source : undefined;\n            const isSharedLayoutAnimation = snapshotSource !== layoutSource;\n            const stack = this.getStack();\n            const isOnlyMember = !stack || stack.members.length <= 1;\n            const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &&\n                !isOnlyMember &&\n                this.options.crossfade === true &&\n                !this.path.some(hasOpacityCrossfade));\n            this.animationProgress = 0;\n            let prevRelativeTarget;\n            this.mixTargetDelta = (latest) => {\n                const progress = latest / 1000;\n                mixAxisDelta(targetDelta.x, delta.x, progress);\n                mixAxisDelta(targetDelta.y, delta.y, progress);\n                this.setTargetDelta(targetDelta);\n                if (this.relativeTarget &&\n                    this.relativeTargetOrigin &&\n                    this.layout &&\n                    this.relativeParent &&\n                    this.relativeParent.layout) {\n                    calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);\n                    mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);\n                    /**\n                     * If this is an unchanged relative target we can consider the\n                     * projection not dirty.\n                     */\n                    if (prevRelativeTarget &&\n                        boxEquals(this.relativeTarget, prevRelativeTarget)) {\n                        this.isProjectionDirty = false;\n                    }\n                    if (!prevRelativeTarget)\n                        prevRelativeTarget = createBox();\n                    copyBoxInto(prevRelativeTarget, this.relativeTarget);\n                }\n                if (isSharedLayoutAnimation) {\n                    this.animationValues = mixedValues;\n                    mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);\n                }\n                this.root.scheduleUpdateProjection();\n                this.scheduleRender();\n                this.animationProgress = progress;\n            };\n            this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);\n        }\n        startAnimation(options) {\n            this.notifyListeners(\"animationStart\");\n            this.currentAnimation && this.currentAnimation.stop();\n            if (this.resumingFrom && this.resumingFrom.currentAnimation) {\n                this.resumingFrom.currentAnimation.stop();\n            }\n            if (this.pendingAnimation) {\n                cancelFrame(this.pendingAnimation);\n                this.pendingAnimation = undefined;\n            }\n            /**\n             * Start the animation in the next frame to have a frame with progress 0,\n             * where the target is the same as when the animation started, so we can\n             * calculate the relative positions correctly for instant transitions.\n             */\n            this.pendingAnimation = frame.update(() => {\n                globalProjectionState.hasAnimatedSinceResize = true;\n                this.currentAnimation = animateSingleValue(0, animationTarget, {\n                    ...options,\n                    onUpdate: (latest) => {\n                        this.mixTargetDelta(latest);\n                        options.onUpdate && options.onUpdate(latest);\n                    },\n                    onComplete: () => {\n                        options.onComplete && options.onComplete();\n                        this.completeAnimation();\n                    },\n                });\n                if (this.resumingFrom) {\n                    this.resumingFrom.currentAnimation = this.currentAnimation;\n                }\n                this.pendingAnimation = undefined;\n            });\n        }\n        completeAnimation() {\n            if (this.resumingFrom) {\n                this.resumingFrom.currentAnimation = undefined;\n                this.resumingFrom.preserveOpacity = undefined;\n            }\n            const stack = this.getStack();\n            stack && stack.exitAnimationComplete();\n            this.resumingFrom =\n                this.currentAnimation =\n                    this.animationValues =\n                        undefined;\n            this.notifyListeners(\"animationComplete\");\n        }\n        finishAnimation() {\n            if (this.currentAnimation) {\n                this.mixTargetDelta && this.mixTargetDelta(animationTarget);\n                this.currentAnimation.stop();\n            }\n            this.completeAnimation();\n        }\n        applyTransformsToTarget() {\n            const lead = this.getLead();\n            let { targetWithTransforms, target, layout, latestValues } = lead;\n            if (!targetWithTransforms || !target || !layout)\n                return;\n            /**\n             * If we're only animating position, and this element isn't the lead element,\n             * then instead of projecting into the lead box we instead want to calculate\n             * a new target that aligns the two boxes but maintains the layout shape.\n             */\n            if (this !== lead &&\n                this.layout &&\n                layout &&\n                shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {\n                target = this.target || createBox();\n                const xLength = calcLength(this.layout.layoutBox.x);\n                target.x.min = lead.target.x.min;\n                target.x.max = target.x.min + xLength;\n                const yLength = calcLength(this.layout.layoutBox.y);\n                target.y.min = lead.target.y.min;\n                target.y.max = target.y.min + yLength;\n            }\n            copyBoxInto(targetWithTransforms, target);\n            /**\n             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n             * This is the final box that we will then project into by calculating a transform delta and\n             * applying it to the corrected box.\n             */\n            transformBox(targetWithTransforms, latestValues);\n            /**\n             * Update the delta between the corrected box and the final target box, after\n             * user-set transforms are applied to it. This will be used by the renderer to\n             * create a transform style that will reproject the element from its layout layout\n             * into the desired bounding box.\n             */\n            calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n        }\n        registerSharedNode(layoutId, node) {\n            if (!this.sharedNodes.has(layoutId)) {\n                this.sharedNodes.set(layoutId, new NodeStack());\n            }\n            const stack = this.sharedNodes.get(layoutId);\n            stack.add(node);\n            const config = node.options.initialPromotionConfig;\n            node.promote({\n                transition: config ? config.transition : undefined,\n                preserveFollowOpacity: config && config.shouldPreserveFollowOpacity\n                    ? config.shouldPreserveFollowOpacity(node)\n                    : undefined,\n            });\n        }\n        isLead() {\n            const stack = this.getStack();\n            return stack ? stack.lead === this : true;\n        }\n        getLead() {\n            var _a;\n            const { layoutId } = this.options;\n            return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\n        }\n        getPrevLead() {\n            var _a;\n            const { layoutId } = this.options;\n            return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;\n        }\n        getStack() {\n            const { layoutId } = this.options;\n            if (layoutId)\n                return this.root.sharedNodes.get(layoutId);\n        }\n        promote({ needsReset, transition, preserveFollowOpacity, } = {}) {\n            const stack = this.getStack();\n            if (stack)\n                stack.promote(this, preserveFollowOpacity);\n            if (needsReset) {\n                this.projectionDelta = undefined;\n                this.needsReset = true;\n            }\n            if (transition)\n                this.setOptions({ transition });\n        }\n        relegate() {\n            const stack = this.getStack();\n            if (stack) {\n                return stack.relegate(this);\n            }\n            else {\n                return false;\n            }\n        }\n        resetSkewAndRotation() {\n            const { visualElement } = this.options;\n            if (!visualElement)\n                return;\n            // If there's no detected skew or rotation values, we can early return without a forced render.\n            let hasDistortingTransform = false;\n            /**\n             * An unrolled check for rotation values. Most elements don't have any rotation and\n             * skipping the nested loop and new object creation is 50% faster.\n             */\n            const { latestValues } = visualElement;\n            if (latestValues.z ||\n                latestValues.rotate ||\n                latestValues.rotateX ||\n                latestValues.rotateY ||\n                latestValues.rotateZ ||\n                latestValues.skewX ||\n                latestValues.skewY) {\n                hasDistortingTransform = true;\n            }\n            // If there's no distorting values, we don't need to do any more.\n            if (!hasDistortingTransform)\n                return;\n            const resetValues = {};\n            if (latestValues.z) {\n                resetDistortingTransform(\"z\", visualElement, resetValues, this.animationValues);\n            }\n            // Check the skew and rotate value of all axes and reset to 0\n            for (let i = 0; i < transformAxes.length; i++) {\n                resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\n                resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\n            }\n            // Force a render of this element to apply the transform with all skews and rotations\n            // set to 0.\n            visualElement.render();\n            // Put back all the values we reset\n            for (const key in resetValues) {\n                visualElement.setStaticValue(key, resetValues[key]);\n                if (this.animationValues) {\n                    this.animationValues[key] = resetValues[key];\n                }\n            }\n            // Schedule a render for the next frame. This ensures we won't visually\n            // see the element with the reset rotate value applied.\n            visualElement.scheduleRender();\n        }\n        getProjectionStyles(styleProp) {\n            var _a, _b;\n            if (!this.instance || this.isSVG)\n                return undefined;\n            if (!this.isVisible) {\n                return hiddenVisibility;\n            }\n            const styles = {\n                visibility: \"\",\n            };\n            const transformTemplate = this.getTransformTemplate();\n            if (this.needsReset) {\n                this.needsReset = false;\n                styles.opacity = \"\";\n                styles.pointerEvents =\n                    resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\";\n                styles.transform = transformTemplate\n                    ? transformTemplate(this.latestValues, \"\")\n                    : \"none\";\n                return styles;\n            }\n            const lead = this.getLead();\n            if (!this.projectionDelta || !this.layout || !lead.target) {\n                const emptyStyles = {};\n                if (this.options.layoutId) {\n                    emptyStyles.opacity =\n                        this.latestValues.opacity !== undefined\n                            ? this.latestValues.opacity\n                            : 1;\n                    emptyStyles.pointerEvents =\n                        resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\";\n                }\n                if (this.hasProjected && !hasTransform(this.latestValues)) {\n                    emptyStyles.transform = transformTemplate\n                        ? transformTemplate({}, \"\")\n                        : \"none\";\n                    this.hasProjected = false;\n                }\n                return emptyStyles;\n            }\n            const valuesToRender = lead.animationValues || lead.latestValues;\n            this.applyTransformsToTarget();\n            styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n            if (transformTemplate) {\n                styles.transform = transformTemplate(valuesToRender, styles.transform);\n            }\n            const { x, y } = this.projectionDelta;\n            styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;\n            if (lead.animationValues) {\n                /**\n                 * If the lead component is animating, assign this either the entering/leaving\n                 * opacity\n                 */\n                styles.opacity =\n                    lead === this\n                        ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1\n                        : this.preserveOpacity\n                            ? this.latestValues.opacity\n                            : valuesToRender.opacityExit;\n            }\n            else {\n                /**\n                 * Or we're not animating at all, set the lead component to its layout\n                 * opacity and other components to hidden.\n                 */\n                styles.opacity =\n                    lead === this\n                        ? valuesToRender.opacity !== undefined\n                            ? valuesToRender.opacity\n                            : \"\"\n                        : valuesToRender.opacityExit !== undefined\n                            ? valuesToRender.opacityExit\n                            : 0;\n            }\n            /**\n             * Apply scale correction\n             */\n            for (const key in scaleCorrectors) {\n                if (valuesToRender[key] === undefined)\n                    continue;\n                const { correct, applyTo } = scaleCorrectors[key];\n                /**\n                 * Only apply scale correction to the value if we have an\n                 * active projection transform. Otherwise these values become\n                 * vulnerable to distortion if the element changes size without\n                 * a corresponding layout animation.\n                 */\n                const corrected = styles.transform === \"none\"\n                    ? valuesToRender[key]\n                    : correct(valuesToRender[key], lead);\n                if (applyTo) {\n                    const num = applyTo.length;\n                    for (let i = 0; i < num; i++) {\n                        styles[applyTo[i]] = corrected;\n                    }\n                }\n                else {\n                    styles[key] = corrected;\n                }\n            }\n            /**\n             * Disable pointer events on follow components. This is to ensure\n             * that if a follow component covers a lead component it doesn't block\n             * pointer events on the lead.\n             */\n            if (this.options.layoutId) {\n                styles.pointerEvents =\n                    lead === this\n                        ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\"\n                        : \"none\";\n            }\n            return styles;\n        }\n        clearSnapshot() {\n            this.resumeFrom = this.snapshot = undefined;\n        }\n        // Only run on root\n        resetTree() {\n            this.root.nodes.forEach((node) => { var _a; return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop(); });\n            this.root.nodes.forEach(clearMeasurements);\n            this.root.sharedNodes.clear();\n        }\n    };\n}\nfunction updateLayout(node) {\n    node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n    var _a;\n    const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;\n    if (node.isLead() &&\n        node.layout &&\n        snapshot &&\n        node.hasListeners(\"didUpdate\")) {\n        const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;\n        const { animationType } = node.options;\n        const isShared = snapshot.source !== node.layout.source;\n        // TODO Maybe we want to also resize the layout snapshot so we don't trigger\n        // animations for instance if layout=\"size\" and an element has only changed position\n        if (animationType === \"size\") {\n            eachAxis((axis) => {\n                const axisSnapshot = isShared\n                    ? snapshot.measuredBox[axis]\n                    : snapshot.layoutBox[axis];\n                const length = calcLength(axisSnapshot);\n                axisSnapshot.min = layout[axis].min;\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        }\n        else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {\n            eachAxis((axis) => {\n                const axisSnapshot = isShared\n                    ? snapshot.measuredBox[axis]\n                    : snapshot.layoutBox[axis];\n                const length = calcLength(layout[axis]);\n                axisSnapshot.max = axisSnapshot.min + length;\n                /**\n                 * Ensure relative target gets resized and rerendererd\n                 */\n                if (node.relativeTarget && !node.currentAnimation) {\n                    node.isProjectionDirty = true;\n                    node.relativeTarget[axis].max =\n                        node.relativeTarget[axis].min + length;\n                }\n            });\n        }\n        const layoutDelta = createDelta();\n        calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);\n        const visualDelta = createDelta();\n        if (isShared) {\n            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);\n        }\n        else {\n            calcBoxDelta(visualDelta, layout, snapshot.layoutBox);\n        }\n        const hasLayoutChanged = !isDeltaZero(layoutDelta);\n        let hasRelativeTargetChanged = false;\n        if (!node.resumeFrom) {\n            const relativeParent = node.getClosestProjectingParent();\n            /**\n             * If the relativeParent is itself resuming from a different element then\n             * the relative snapshot is not relavent\n             */\n            if (relativeParent && !relativeParent.resumeFrom) {\n                const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;\n                if (parentSnapshot && parentLayout) {\n                    const relativeSnapshot = createBox();\n                    calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);\n                    const relativeLayout = createBox();\n                    calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);\n                    if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {\n                        hasRelativeTargetChanged = true;\n                    }\n                    if (relativeParent.options.layoutRoot) {\n                        node.relativeTarget = relativeLayout;\n                        node.relativeTargetOrigin = relativeSnapshot;\n                        node.relativeParent = relativeParent;\n                    }\n                }\n            }\n        }\n        node.notifyListeners(\"didUpdate\", {\n            layout,\n            snapshot,\n            delta: visualDelta,\n            layoutDelta,\n            hasLayoutChanged,\n            hasRelativeTargetChanged,\n        });\n    }\n    else if (node.isLead()) {\n        const { onExitComplete } = node.options;\n        onExitComplete && onExitComplete();\n    }\n    /**\n     * Clearing transition\n     * TODO: Investigate why this transition is being passed in as {type: false } from Framer\n     * and why we need it at all\n     */\n    node.options.transition = undefined;\n}\nfunction propagateDirtyNodes(node) {\n    /**\n     * Increase debug counter for nodes encountered this frame\n     */\n    if (isDebug) {\n        metrics.totalNodes++;\n    }\n    if (!node.parent)\n        return;\n    /**\n     * If this node isn't projecting, propagate isProjectionDirty. It will have\n     * no performance impact but it will allow the next child that *is* projecting\n     * but *isn't* dirty to just check its parent to see if *any* ancestor needs\n     * correcting.\n     */\n    if (!node.isProjecting()) {\n        node.isProjectionDirty = node.parent.isProjectionDirty;\n    }\n    /**\n     * Propagate isSharedProjectionDirty and isTransformDirty\n     * throughout the whole tree. A future revision can take another look at\n     * this but for safety we still recalcualte shared nodes.\n     */\n    node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty ||\n        node.parent.isProjectionDirty ||\n        node.parent.isSharedProjectionDirty));\n    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);\n}\nfunction cleanDirtyNodes(node) {\n    node.isProjectionDirty =\n        node.isSharedProjectionDirty =\n            node.isTransformDirty =\n                false;\n}\nfunction clearSnapshot(node) {\n    node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n    node.clearMeasurements();\n}\nfunction clearIsLayoutDirty(node) {\n    node.isLayoutDirty = false;\n}\nfunction resetTransformStyle(node) {\n    const { visualElement } = node.options;\n    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {\n        visualElement.notify(\"BeforeLayoutMeasure\");\n    }\n    node.resetTransform();\n}\nfunction finishAnimation(node) {\n    node.finishAnimation();\n    node.targetDelta = node.relativeTarget = node.target = undefined;\n    node.isProjectionDirty = true;\n}\nfunction resolveTargetDelta(node) {\n    node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n    node.calcProjection();\n}\nfunction resetSkewAndRotation(node) {\n    node.resetSkewAndRotation();\n}\nfunction removeLeadSnapshots(stack) {\n    stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p) {\n    output.translate = mixNumber(delta.translate, 0, p);\n    output.scale = mixNumber(delta.scale, 1, p);\n    output.origin = delta.origin;\n    output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p) {\n    output.min = mixNumber(from.min, to.min, p);\n    output.max = mixNumber(from.max, to.max, p);\n}\nfunction mixBox(output, from, to, p) {\n    mixAxis(output.x, from.x, to.x, p);\n    mixAxis(output.y, from.y, to.y, p);\n}\nfunction hasOpacityCrossfade(node) {\n    return (node.animationValues && node.animationValues.opacityExit !== undefined);\n}\nconst defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\nconst userAgentContains = (string) => typeof navigator !== \"undefined\" &&\n    navigator.userAgent &&\n    navigator.userAgent.toLowerCase().includes(string);\n/**\n * Measured bounding boxes must be rounded in Safari and\n * left untouched in Chrome, otherwise non-integer layouts within scaled-up elements\n * can appear to jump.\n */\nconst roundPoint = userAgentContains(\"applewebkit/\") && !userAgentContains(\"chrome/\")\n    ? Math.round\n    : noop;\nfunction roundAxis(axis) {\n    // Round to the nearest .5 pixels to support subpixel layouts\n    axis.min = roundPoint(axis.min);\n    axis.max = roundPoint(axis.max);\n}\nfunction roundBox(box) {\n    roundAxis(box.x);\n    roundAxis(box.y);\n}\nfunction shouldAnimatePositionOnly(animationType, snapshot, layout) {\n    return (animationType === \"position\" ||\n        (animationType === \"preserve-aspect\" &&\n            !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2)));\n}\nfunction checkNodeWasScrollRoot(node) {\n    var _a;\n    return node !== node.root && ((_a = node.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot);\n}\n\nexport { cleanDirtyNodes, createProjectionNode, mixAxis, mixAxisDelta, mixBox, propagateDirtyNodes };\n","function isSVGElement(element) {\n    return element instanceof SVGElement && element.tagName !== \"svg\";\n}\n\nexport { isSVGElement };\n","function buildProjectionTransform(delta, treeScale, latestTransform) {\n    let transform = \"\";\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    const xTranslate = delta.x.translate / treeScale.x;\n    const yTranslate = delta.y.translate / treeScale.y;\n    const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;\n    if (xTranslate || yTranslate || zTranslate) {\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\n    }\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */\n    if (treeScale.x !== 1 || treeScale.y !== 1) {\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n    }\n    if (latestTransform) {\n        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;\n        if (transformPerspective)\n            transform = `perspective(${transformPerspective}px) ${transform}`;\n        if (rotate)\n            transform += `rotate(${rotate}deg) `;\n        if (rotateX)\n            transform += `rotateX(${rotateX}deg) `;\n        if (rotateY)\n            transform += `rotateY(${rotateY}deg) `;\n        if (skewX)\n            transform += `skewX(${skewX}deg) `;\n        if (skewY)\n            transform += `skewY(${skewY}deg) `;\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */\n    const elementScaleX = delta.x.scale * treeScale.x;\n    const elementScaleY = delta.y.scale * treeScale.y;\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\n        transform += `scale(${elementScaleX}, ${elementScaleY})`;\n    }\n    return transform || \"none\";\n}\n\nexport { buildProjectionTransform };\n","import { createProjectionNode } from './create-projection-node.mjs';\nimport { addDomEvent } from '../../events/add-dom-event.mjs';\n\nconst DocumentProjectionNode = createProjectionNode({\n    attachResizeListener: (ref, notify) => addDomEvent(ref, \"resize\", notify),\n    measureScroll: () => ({\n        x: document.documentElement.scrollLeft || document.body.scrollLeft,\n        y: document.documentElement.scrollTop || document.body.scrollTop,\n    }),\n    checkIsScrollRoot: () => true,\n});\n\nexport { DocumentProjectionNode };\n","import { createProjectionNode } from './create-projection-node.mjs';\nimport { DocumentProjectionNode } from './DocumentProjectionNode.mjs';\n\nconst rootProjectionNode = {\n    current: undefined,\n};\nconst HTMLProjectionNode = createProjectionNode({\n    measureScroll: (instance) => ({\n        x: instance.scrollLeft,\n        y: instance.scrollTop,\n    }),\n    defaultParent: () => {\n        if (!rootProjectionNode.current) {\n            const documentNode = new DocumentProjectionNode({});\n            documentNode.mount(window);\n            documentNode.setOptions({ layoutScroll: true });\n            rootProjectionNode.current = documentNode;\n        }\n        return rootProjectionNode.current;\n    },\n    resetTransform: (instance, value) => {\n        instance.style.transform = value !== undefined ? value : \"none\";\n    },\n    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === \"fixed\"),\n});\n\nexport { HTMLProjectionNode, rootProjectionNode };\n","import { DragGesture } from '../../gestures/drag/index.mjs';\nimport { PanGesture } from '../../gestures/pan/index.mjs';\nimport { MeasureLayout } from './layout/MeasureLayout.mjs';\nimport { HTMLProjectionNode } from '../../projection/node/HTMLProjectionNode.mjs';\n\nconst drag = {\n    pan: {\n        Feature: PanGesture,\n    },\n    drag: {\n        Feature: DragGesture,\n        ProjectionNode: HTMLProjectionNode,\n        MeasureLayout,\n    },\n};\n\nexport { drag };\n","/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap();\nconst fireObserverCallback = (entry) => {\n    const callback = observerCallbacks.get(entry.target);\n    callback && callback(entry);\n};\nconst fireAllObserverCallbacks = (entries) => {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver({ root, ...options }) {\n    const lookupRoot = root || document;\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    const rootObservers = observers.get(lookupRoot);\n    const key = JSON.stringify(options);\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    const rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return () => {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\n\nexport { observeIntersection };\n","import { Feature } from '../Feature.mjs';\nimport { observeIntersection } from './observers.mjs';\n\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n};\nclass InViewFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.hasEnteredView = false;\n        this.isInView = false;\n    }\n    startObserver() {\n        this.unmount();\n        const { viewport = {} } = this.node.getProps();\n        const { root, margin: rootMargin, amount = \"some\", once } = viewport;\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\n        };\n        const onIntersectionUpdate = (entry) => {\n            const { isIntersecting } = entry;\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (this.isInView === isIntersecting)\n                return;\n            this.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && this.hasEnteredView) {\n                return;\n            }\n            else if (isIntersecting) {\n                this.hasEnteredView = true;\n            }\n            if (this.node.animationState) {\n                this.node.animationState.setActive(\"whileInView\", isIntersecting);\n            }\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const { onViewportEnter, onViewportLeave } = this.node.getProps();\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n            callback && callback(entry);\n        };\n        return observeIntersection(this.node.current, options, onIntersectionUpdate);\n    }\n    mount() {\n        this.startObserver();\n    }\n    update() {\n        if (typeof IntersectionObserver === \"undefined\")\n            return;\n        const { props, prevProps } = this.node;\n        const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n        if (hasOptionsChanged) {\n            this.startObserver();\n        }\n    }\n    unmount() { }\n}\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\n    return (name) => viewport[name] !== prevViewport[name];\n}\n\nexport { InViewFeature };\n","import { HoverGesture } from '../../gestures/hover.mjs';\nimport { FocusGesture } from '../../gestures/focus.mjs';\nimport { PressGesture } from '../../gestures/press.mjs';\nimport { InViewFeature } from './viewport/index.mjs';\n\nconst gestureAnimations = {\n    inView: {\n        Feature: InViewFeature,\n    },\n    tap: {\n        Feature: PressGesture,\n    },\n    focus: {\n        Feature: FocusGesture,\n    },\n    hover: {\n        Feature: HoverGesture,\n    },\n};\n\nexport { gestureAnimations };\n","import { HTMLProjectionNode } from '../../projection/node/HTMLProjectionNode.mjs';\nimport { MeasureLayout } from './layout/MeasureLayout.mjs';\n\nconst layout = {\n    layout: {\n        ProjectionNode: HTMLProjectionNode,\n        MeasureLayout,\n    },\n};\n\nexport { layout };\n","const featureProps = {\n    animation: [\n        \"animate\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"exit\",\n        \"whileInView\",\n        \"whileFocus\",\n        \"whileDrag\",\n    ],\n    exit: [\"exit\"],\n    drag: [\"drag\", \"dragControls\"],\n    focus: [\"whileFocus\"],\n    hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\n    tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\n    pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\n    inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\n    layout: [\"layout\", \"layoutId\"],\n};\nconst featureDefinitions = {};\nfor (const key in featureProps) {\n    featureDefinitions[key] = {\n        isEnabled: (props) => featureProps[key].some((name) => !!props[name]),\n    };\n}\n\nexport { featureDefinitions };\n","const motionComponentSymbol = Symbol.for(\"motionComponentSymbol\");\n\nexport { motionComponentSymbol };\n","import { useCallback } from 'react';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nfunction useMotionRef(visualState, visualElement, externalRef) {\n    return useCallback((instance) => {\n        if (instance) {\n            visualState.onMount && visualState.onMount(instance);\n        }\n        if (visualElement) {\n            if (instance) {\n                visualElement.mount(instance);\n            }\n            else {\n                visualElement.unmount();\n            }\n        }\n        if (externalRef) {\n            if (typeof externalRef === \"function\") {\n                externalRef(instance);\n            }\n            else if (isRefObject(externalRef)) {\n                externalRef.current = instance;\n            }\n        }\n    }, \n    /**\n     * Only pass a new ref callback to React if we've received a visual element\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */\n    [visualElement]);\n}\n\nexport { useMotionRef };\n","import { useContext, useRef, useInsertionEffect, useEffect } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { LazyContext } from '../../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\nimport { microtask } from '../../frameloop/microtask.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { SwitchLayoutGroupContext } from '../../context/SwitchLayoutGroupContext.mjs';\n\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\n    var _a, _b;\n    const { visualElement: parent } = useContext(MotionContext);\n    const lazyContext = useContext(LazyContext);\n    const presenceContext = useContext(PresenceContext);\n    const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;\n    const visualElementRef = useRef(null);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement = createVisualElement || lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext\n                ? presenceContext.initial === false\n                : false,\n            reducedMotionConfig,\n        });\n    }\n    const visualElement = visualElementRef.current;\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */\n    const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n    if (visualElement &&\n        !visualElement.projection &&\n        ProjectionNodeConstructor &&\n        (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\n        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n    }\n    const isMounted = useRef(false);\n    useInsertionEffect(() => {\n        /**\n         * Check the component has already mounted before calling\n         * `update` unnecessarily. This ensures we skip the initial update.\n         */\n        if (visualElement && isMounted.current) {\n            visualElement.update(props, presenceContext);\n        }\n    });\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\n    const wantsHandoff = useRef(Boolean(optimisedAppearId) &&\n        !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) &&\n        ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));\n    useIsomorphicLayoutEffect(() => {\n        if (!visualElement)\n            return;\n        isMounted.current = true;\n        window.MotionIsMounted = true;\n        visualElement.updateFeatures();\n        microtask.render(visualElement.render);\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there's no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */\n        if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n    });\n    useEffect(() => {\n        if (!visualElement)\n            return;\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n        if (wantsHandoff.current) {\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\n            queueMicrotask(() => {\n                var _a;\n                (_a = window.MotionHandoffMarkAsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId);\n            });\n            wantsHandoff.current = false;\n        }\n    });\n    return visualElement;\n}\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, } = props;\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"]\n        ? undefined\n        : getClosestProjectingNode(visualElement.parent));\n    visualElement.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement,\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig,\n        layoutScroll,\n        layoutRoot,\n    });\n}\nfunction getClosestProjectingNode(visualElement) {\n    if (!visualElement)\n        return undefined;\n    return visualElement.options.allowProjection !== false\n        ? visualElement.projection\n        : getClosestProjectingNode(visualElement.parent);\n}\n\nexport { useVisualElement };\n","\"use client\";\nimport { jsxs, jsx } from 'react/jsx-runtime';\nimport { warning, invariant } from 'motion-utils';\nimport { forwardRef, useContext } from 'react';\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\nimport { LazyContext } from '../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../context/MotionContext/index.mjs';\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\nimport { isBrowser } from '../utils/is-browser.mjs';\nimport { featureDefinitions } from './features/definitions.mjs';\nimport { loadFeatures } from './features/load-features.mjs';\nimport { motionComponentSymbol } from './utils/symbol.mjs';\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\nimport { useVisualElement } from './utils/use-visual-element.mjs';\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */\nfunction createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component, }) {\n    var _a, _b;\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        /**\n         * If we need to measure the element we load this functionality in a\n         * separate class component in order to gain access to getSnapshotBeforeUpdate.\n         */\n        let MeasureLayout;\n        const configAndProps = {\n            ...useContext(MotionConfigContext),\n            ...props,\n            layoutId: useLayoutId(props),\n        };\n        const { isStatic } = configAndProps;\n        const context = useCreateMotionContext(props);\n        const visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            useStrictMode(configAndProps, preloadedFeatures);\n            const layoutProjection = getProjectionFunctionality(configAndProps);\n            MeasureLayout = layoutProjection.MeasureLayout;\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? (jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] }));\n    }\n    MotionComponent.displayName = `motion.${typeof Component === \"string\"\n        ? Component\n        : `create(${(_b = (_a = Component.displayName) !== null && _a !== void 0 ? _a : Component.name) !== null && _b !== void 0 ? _b : \"\"})`}`;\n    const ForwardRefMotionComponent = forwardRef(MotionComponent);\n    ForwardRefMotionComponent[motionComponentSymbol] = Component;\n    return ForwardRefMotionComponent;\n}\nfunction useLayoutId({ layoutId }) {\n    const layoutGroupId = useContext(LayoutGroupContext).id;\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + \"-\" + layoutId\n        : layoutId;\n}\nfunction useStrictMode(configAndProps, preloadedFeatures) {\n    const isStrict = useContext(LazyContext).strict;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (process.env.NODE_ENV !== \"production\" &&\n        preloadedFeatures &&\n        isStrict) {\n        const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n        configAndProps.ignoreStrict\n            ? warning(false, strictMessage)\n            : invariant(false, strictMessage);\n    }\n}\nfunction getProjectionFunctionality(props) {\n    const { drag, layout } = featureDefinitions;\n    if (!drag && !layout)\n        return {};\n    const combined = { ...drag, ...layout };\n    return {\n        MeasureLayout: (drag === null || drag === void 0 ? void 0 : drag.isEnabled(props)) || (layout === null || layout === void 0 ? void 0 : layout.isEnabled(props))\n            ? combined.MeasureLayout\n            : undefined,\n        ProjectionNode: combined.ProjectionNode,\n    };\n}\n\nexport { createRendererMotionComponent };\n","import { featureDefinitions } from './definitions.mjs';\n\nfunction loadFeatures(features) {\n    for (const key in features) {\n        featureDefinitions[key] = {\n            ...featureDefinitions[key],\n            ...features[key],\n        };\n    }\n}\n\nexport { loadFeatures };\n","/**\n * We keep these listed separately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\nconst lowercaseSVGElements = [\n    \"animate\",\n    \"circle\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"filter\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"rect\",\n    \"stop\",\n    \"switch\",\n    \"symbol\",\n    \"svg\",\n    \"text\",\n    \"tspan\",\n    \"use\",\n    \"view\",\n];\n\nexport { lowercaseSVGElements };\n","import { lowercaseSVGElements } from '../../svg/lowercase-elements.mjs';\n\nfunction isSVGComponent(Component) {\n    if (\n    /**\n     * If it's not a string, it's a custom React component. Currently we only support\n     * HTML custom React components.\n     */\n    typeof Component !== \"string\" ||\n        /**\n         * If it contains a dash, the element is a custom HTML webcomponent.\n         */\n        Component.includes(\"-\")) {\n        return false;\n    }\n    else if (\n    /**\n     * If it's in our list of lowercase SVG tags, it's an SVG component\n     */\n    lowercaseSVGElements.indexOf(Component) > -1 ||\n        /**\n         * If it contains a capital letter, it's an SVG component\n         */\n        /[A-Z]/u.test(Component)) {\n        return true;\n    }\n    return false;\n}\n\nexport { isSVGComponent };\n","import { useContext } from 'react';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { isControllingVariants, isVariantNode } from '../../render/utils/is-controlling-variants.mjs';\nimport { resolveVariantFromProps } from '../../render/utils/resolve-variants.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\n\nfunction makeState({ scrapeMotionValuesFromProps, createRenderState, onUpdate, }, props, context, presenceContext) {\n    const state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    if (onUpdate) {\n        /**\n         * onMount works without the VisualElement because it could be\n         * called before the VisualElement payload has been hydrated.\n         * (e.g. if someone is using m components <m.circle />)\n         */\n        state.onMount = (instance) => onUpdate({ props, current: instance, ...state });\n        state.onUpdate = (visualElement) => onUpdate(visualElement);\n    }\n    return state;\n}\nconst makeUseVisualState = (config) => (props, isStatic) => {\n    const context = useContext(MotionContext);\n    const presenceContext = useContext(PresenceContext);\n    const make = () => makeState(config, props, context, presenceContext);\n    return isStatic ? make() : useConstant(make);\n};\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    const values = {};\n    const motionValues = scrapeMotionValues(props, {});\n    for (const key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    let { initial, animate } = props;\n    const isControllingVariants$1 = isControllingVariants(props);\n    const isVariantNode$1 = isVariantNode(props);\n    if (context &&\n        isVariantNode$1 &&\n        !isControllingVariants$1 &&\n        props.inherit !== false) {\n        if (initial === undefined)\n            initial = context.initial;\n        if (animate === undefined)\n            animate = context.animate;\n    }\n    let isInitialAnimationBlocked = presenceContext\n        ? presenceContext.initial === false\n        : false;\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n    const variantToSet = isInitialAnimationBlocked ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== \"boolean\" &&\n        !isAnimationControls(variantToSet)) {\n        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n        for (let i = 0; i < list.length; i++) {\n            const resolved = resolveVariantFromProps(props, list[i]);\n            if (resolved) {\n                const { transitionEnd, transition, ...target } = resolved;\n                for (const key in target) {\n                    let valueTarget = target[key];\n                    if (Array.isArray(valueTarget)) {\n                        /**\n                         * Take final keyframe if the initial animation is blocked because\n                         * we want to initialise at the end of that blocked animation.\n                         */\n                        const index = isInitialAnimationBlocked\n                            ? valueTarget.length - 1\n                            : 0;\n                        valueTarget = valueTarget[index];\n                    }\n                    if (valueTarget !== null) {\n                        values[key] = valueTarget;\n                    }\n                }\n                for (const key in transitionEnd) {\n                    values[key] = transitionEnd[key];\n                }\n            }\n        }\n    }\n    return values;\n}\n\nexport { makeUseVisualState };\n","/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nconst getValueAsType = (value, type) => {\n    return type && typeof value === \"number\"\n        ? type.transform(value)\n        : value;\n};\n\nexport { getValueAsType };\n","import { getValueAsType } from '../../dom/value-types/get-as-type.mjs';\nimport { numberValueTypes } from '../../dom/value-types/number.mjs';\nimport { transformPropOrder } from './keys-transform.mjs';\n\nconst translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\",\n};\nconst numTransforms = transformPropOrder.length;\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(latestValues, transform, transformTemplate) {\n    // The transform string we're going to build into.\n    let transformString = \"\";\n    let transformIsDefault = true;\n    /**\n     * Loop over all possible transforms in order, adding the ones that\n     * are present to the transform string.\n     */\n    for (let i = 0; i < numTransforms; i++) {\n        const key = transformPropOrder[i];\n        const value = latestValues[key];\n        if (value === undefined)\n            continue;\n        let valueIsDefault = true;\n        if (typeof value === \"number\") {\n            valueIsDefault = value === (key.startsWith(\"scale\") ? 1 : 0);\n        }\n        else {\n            valueIsDefault = parseFloat(value) === 0;\n        }\n        if (!valueIsDefault || transformTemplate) {\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\n            if (!valueIsDefault) {\n                transformIsDefault = false;\n                const transformName = translateAlias[key] || key;\n                transformString += `${transformName}(${valueAsType}) `;\n            }\n            if (transformTemplate) {\n                transform[key] = valueAsType;\n            }\n        }\n    }\n    transformString = transformString.trim();\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    }\n    else if (transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n\nexport { buildTransform };\n","import { isCSSVariableName } from '../../dom/utils/is-css-variable.mjs';\nimport { getValueAsType } from '../../dom/value-types/get-as-type.mjs';\nimport { numberValueTypes } from '../../dom/value-types/number.mjs';\nimport { buildTransform } from './build-transform.mjs';\nimport { transformProps } from './keys-transform.mjs';\n\nfunction buildHTMLStyles(state, latestValues, transformTemplate) {\n    const { style, vars, transformOrigin } = state;\n    // Track whether we encounter any transform or transformOrigin values.\n    let hasTransform = false;\n    let hasTransformOrigin = false;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept separately for further processing.\n     */\n    for (const key in latestValues) {\n        const value = latestValues[key];\n        if (transformProps.has(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            continue;\n        }\n        else if (isCSSVariableName(key)) {\n            vars[key] = value;\n            continue;\n        }\n        else {\n            // Convert the value to its default value type, ie 0 -> \"0px\"\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\n            if (key.startsWith(\"origin\")) {\n                // If this is a transform origin, flag and enable further transform-origin processing\n                hasTransformOrigin = true;\n                transformOrigin[key] =\n                    valueAsType;\n            }\n            else {\n                style[key] = valueAsType;\n            }\n        }\n    }\n    if (!latestValues.transform) {\n        if (hasTransform || transformTemplate) {\n            style.transform = buildTransform(latestValues, state.transform, transformTemplate);\n        }\n        else if (style.transform) {\n            /**\n             * If we have previously created a transform but currently don't have any,\n             * reset transform style to none.\n             */\n            style.transform = \"none\";\n        }\n    }\n    /**\n     * Build a transformOrigin style. Uses the same defaults as the browser for\n     * undefined origins.\n     */\n    if (hasTransformOrigin) {\n        const { originX = \"50%\", originY = \"50%\", originZ = 0, } = transformOrigin;\n        style.transformOrigin = `${originX} ${originY} ${originZ}`;\n    }\n}\n\nexport { buildHTMLStyles };\n","import { px } from '../../../value/types/numbers/units.mjs';\n\nconst dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\",\n};\nconst camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\",\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n    // Normalise path length by setting SVG attribute pathLength to 1\n    attrs.pathLength = 1;\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    const keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = px.transform(-offset);\n    // Build the dash array\n    const pathLength = px.transform(length);\n    const pathSpacing = px.transform(spacing);\n    attrs[keys.array] = `${pathLength} ${pathSpacing}`;\n}\n\nexport { buildSVGPath };\n","import { px } from '../../../value/types/numbers/units.mjs';\n\nfunction calcOrigin(origin, offset, size) {\n    return typeof origin === \"string\"\n        ? origin\n        : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n    const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\n    const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\n    return `${pxOriginX} ${pxOriginY}`;\n}\n\nexport { calcSVGTransformOrigin };\n","import { buildHTMLStyles } from '../../html/utils/build-styles.mjs';\nimport { buildSVGPath } from './path.mjs';\nimport { calcSVGTransformOrigin } from './transform-origin.mjs';\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, \n// This is object creation, which we try to avoid per-frame.\n...latest }, isSVGTag, transformTemplate) {\n    buildHTMLStyles(state, latest, transformTemplate);\n    /**\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\n     * as normal HTML tags.\n     */\n    if (isSVGTag) {\n        if (state.style.viewBox) {\n            state.attrs.viewBox = state.style.viewBox;\n        }\n        return;\n    }\n    state.attrs = state.style;\n    state.style = {};\n    const { attrs, style, dimensions } = state;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */\n    if (attrs.transform) {\n        if (dimensions)\n            style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions &&\n        (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Render attrX/attrY/attrScale as attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    if (attrScale !== undefined)\n        attrs.scale = attrScale;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\nexport { buildSVGAttrs };\n","const createHtmlRenderState = () => ({\n    style: {},\n    transform: {},\n    transformOrigin: {},\n    vars: {},\n});\n\nexport { createHtmlRenderState };\n","import { createHtmlRenderState } from '../../html/utils/create-render-state.mjs';\n\nconst createSvgRenderState = () => ({\n    ...createHtmlRenderState(),\n    attrs: {},\n});\n\nexport { createSvgRenderState };\n","const isSVGTag = (tag) => typeof tag === \"string\" && tag.toLowerCase() === \"svg\";\n\nexport { isSVGTag };\n","function renderHTML(element, { style, vars }, styleProp, projection) {\n    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n    // Loop over any CSS variables and assign those.\n    for (const key in vars) {\n        element.style.setProperty(key, vars[key]);\n    }\n}\n\nexport { renderHTML };\n","/**\n * A set of attribute names that are always read/written as camel case.\n */\nconst camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n    \"viewBox\",\n    \"gradientTransform\",\n    \"pathLength\",\n    \"startOffset\",\n    \"textLength\",\n    \"lengthAdjust\",\n]);\n\nexport { camelCaseAttributes };\n","import { camelToDash } from '../../dom/utils/camel-to-dash.mjs';\nimport { renderHTML } from '../../html/utils/render.mjs';\nimport { camelCaseAttributes } from './camel-case-attrs.mjs';\n\nfunction renderSVG(element, renderState, _styleProp, projection) {\n    renderHTML(element, renderState, undefined, projection);\n    for (const key in renderState.attrs) {\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\n\nexport { renderSVG };\n","import { scaleCorrectors } from '../../projection/styles/scale-correction.mjs';\nimport { transformProps } from '../../render/html/utils/keys-transform.mjs';\n\nfunction isForcedMotionValue(key, { layout, layoutId }) {\n    return (transformProps.has(key) ||\n        key.startsWith(\"origin\") ||\n        ((layout || layoutId !== undefined) &&\n            (!!scaleCorrectors[key] || key === \"opacity\")));\n}\n\nexport { isForcedMotionValue };\n","import { isForcedMotionValue } from '../../../motion/utils/is-forced-motion-value.mjs';\nimport { isMotionValue } from '../../../value/utils/is-motion-value.mjs';\n\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    var _a;\n    const { style } = props;\n    const newValues = {};\n    for (const key in style) {\n        if (isMotionValue(style[key]) ||\n            (prevProps.style &&\n                isMotionValue(prevProps.style[key])) ||\n            isForcedMotionValue(key, props) ||\n            ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== undefined) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\n\nexport { scrapeMotionValuesFromProps };\n","import { isMotionValue } from '../../../value/utils/is-motion-value.mjs';\nimport { transformPropOrder } from '../../html/utils/keys-transform.mjs';\nimport { scrapeMotionValuesFromProps as scrapeMotionValuesFromProps$1 } from '../../html/utils/scrape-motion-values.mjs';\n\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);\n    for (const key in props) {\n        if (isMotionValue(props[key]) ||\n            isMotionValue(prevProps[key])) {\n            const targetKey = transformPropOrder.indexOf(key) !== -1\n                ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1)\n                : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\n\nexport { scrapeMotionValuesFromProps };\n","import { frame } from '../../frameloop/frame.mjs';\nimport { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';\nimport { transformProps } from '../html/utils/keys-transform.mjs';\nimport { buildSVGAttrs } from './utils/build-attrs.mjs';\nimport { createSvgRenderState } from './utils/create-render-state.mjs';\nimport { isSVGTag } from './utils/is-svg-tag.mjs';\nimport { renderSVG } from './utils/render.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\n\nfunction updateSVGDimensions(instance, renderState) {\n    try {\n        renderState.dimensions =\n            typeof instance.getBBox === \"function\"\n                ? instance.getBBox()\n                : instance.getBoundingClientRect();\n    }\n    catch (e) {\n        // Most likely trying to measure an unrendered element under Firefox\n        renderState.dimensions = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n        };\n    }\n}\nconst layoutProps = [\"x\", \"y\", \"width\", \"height\", \"cx\", \"cy\", \"r\"];\nconst svgMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n        createRenderState: createSvgRenderState,\n        onUpdate: ({ props, prevProps, current, renderState, latestValues, }) => {\n            if (!current)\n                return;\n            let hasTransform = !!props.drag;\n            if (!hasTransform) {\n                for (const key in latestValues) {\n                    if (transformProps.has(key)) {\n                        hasTransform = true;\n                        break;\n                    }\n                }\n            }\n            if (!hasTransform)\n                return;\n            let needsMeasure = !prevProps;\n            if (prevProps) {\n                /**\n                 * Check the layout props for changes, if any are found we need to\n                 * measure the element again.\n                 */\n                for (let i = 0; i < layoutProps.length; i++) {\n                    const key = layoutProps[i];\n                    if (props[key] !==\n                        prevProps[key]) {\n                        needsMeasure = true;\n                    }\n                }\n            }\n            if (!needsMeasure)\n                return;\n            frame.read(() => {\n                updateSVGDimensions(current, renderState);\n                frame.render(() => {\n                    buildSVGAttrs(renderState, latestValues, isSVGTag(current.tagName), props.transformTemplate);\n                    renderSVG(current, renderState);\n                });\n            });\n        },\n    }),\n};\n\nexport { svgMotionConfig };\n","import { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\nimport { createHtmlRenderState } from './utils/create-render-state.mjs';\n\nconst htmlMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps,\n        createRenderState: createHtmlRenderState,\n    }),\n};\n\nexport { htmlMotionConfig };\n","import { useMemo } from 'react';\nimport { isForcedMotionValue } from '../../motion/utils/is-forced-motion-value.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\nimport { createHtmlRenderState } from './utils/create-render-state.mjs';\n\nfunction copyRawValuesOnly(target, source, props) {\n    for (const key in source) {\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues({ transformTemplate }, visualState) {\n    return useMemo(() => {\n        const state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, transformTemplate);\n        return Object.assign({}, state.vars, state.style);\n    }, [visualState]);\n}\nfunction useStyle(props, visualState) {\n    const styleProp = props.style || {};\n    const style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */\n    copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState));\n    return style;\n}\nfunction useHTMLProps(props, visualState) {\n    // The `any` isn't ideal but it is the type of createElement props argument\n    const htmlProps = {};\n    const style = useStyle(props, visualState);\n    if (props.drag && props.dragListener !== false) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect =\n            style.WebkitUserSelect =\n                style.WebkitTouchCallout =\n                    \"none\";\n        // Disable scrolling on the draggable direction\n        style.touchAction =\n            props.drag === true\n                ? \"none\"\n                : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`;\n    }\n    if (props.tabIndex === undefined &&\n        (props.onTap || props.onTapStart || props.whileTap)) {\n        htmlProps.tabIndex = 0;\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n\nexport { copyRawValuesOnly, useHTMLProps };\n","/**\n * A list of all valid MotionProps.\n *\n * @privateRemarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\nconst validMotionProps = new Set([\n    \"animate\",\n    \"exit\",\n    \"variants\",\n    \"initial\",\n    \"style\",\n    \"values\",\n    \"variants\",\n    \"transition\",\n    \"transformTemplate\",\n    \"custom\",\n    \"inherit\",\n    \"onBeforeLayoutMeasure\",\n    \"onAnimationStart\",\n    \"onAnimationComplete\",\n    \"onUpdate\",\n    \"onDragStart\",\n    \"onDrag\",\n    \"onDragEnd\",\n    \"onMeasureDragConstraints\",\n    \"onDirectionLock\",\n    \"onDragTransitionEnd\",\n    \"_dragX\",\n    \"_dragY\",\n    \"onHoverStart\",\n    \"onHoverEnd\",\n    \"onViewportEnter\",\n    \"onViewportLeave\",\n    \"globalTapTarget\",\n    \"ignoreStrict\",\n    \"viewport\",\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nfunction isValidMotionProp(key) {\n    return (key.startsWith(\"while\") ||\n        (key.startsWith(\"drag\") && key !== \"draggable\") ||\n        key.startsWith(\"layout\") ||\n        key.startsWith(\"onTap\") ||\n        key.startsWith(\"onPan\") ||\n        key.startsWith(\"onLayout\") ||\n        validMotionProps.has(key));\n}\n\nexport { isValidMotionProp };\n","import { isValidMotionProp } from '../../../motion/utils/valid-prop.mjs';\n\nlet shouldForward = (key) => !isValidMotionProp(key);\nfunction loadExternalIsValidProp(isValidProp) {\n    if (!isValidProp)\n        return;\n    // Explicitly filter our events\n    shouldForward = (key) => key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\n}\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\ntry {\n    /**\n     * We attempt to import this package but require won't be defined in esm environments, in that case\n     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed\n     * in favour of explicit injection.\n     */\n    loadExternalIsValidProp(require(\"@emotion/is-prop-valid\").default);\n}\ncatch (_a) {\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n    const filteredProps = {};\n    for (const key in props) {\n        /**\n         * values is considered a valid prop by Emotion, so if it's present\n         * this will be rendered out to the DOM unless explicitly filtered.\n         *\n         * We check the type as it could be used with the `feColorMatrix`\n         * element, which we support.\n         */\n        if (key === \"values\" && typeof props.values === \"object\")\n            continue;\n        if (shouldForward(key) ||\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\n            (!isDom && !isValidMotionProp(key)) ||\n            // If trying to use native HTML drag events, forward drag listeners\n            (props[\"draggable\"] &&\n                key.startsWith(\"onDrag\"))) {\n            filteredProps[key] =\n                props[key];\n        }\n    }\n    return filteredProps;\n}\n\nexport { filterProps, loadExternalIsValidProp };\n","import { useMemo } from 'react';\nimport { copyRawValuesOnly } from '../html/use-props.mjs';\nimport { buildSVGAttrs } from './utils/build-attrs.mjs';\nimport { createSvgRenderState } from './utils/create-render-state.mjs';\nimport { isSVGTag } from './utils/is-svg-tag.mjs';\n\nfunction useSVGProps(props, visualState, _isStatic, Component) {\n    const visualProps = useMemo(() => {\n        const state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);\n        return {\n            ...state.attrs,\n            style: { ...state.style },\n        };\n    }, [visualState]);\n    if (props.style) {\n        const rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = { ...rawStyles, ...visualProps.style };\n    }\n    return visualProps;\n}\n\nexport { useSVGProps };\n","import { Fragment, useMemo, createElement } from 'react';\nimport { useHTMLProps } from '../html/use-props.mjs';\nimport { filterProps } from './utils/filter-props.mjs';\nimport { isSVGComponent } from './utils/is-svg-component.mjs';\nimport { useSVGProps } from '../svg/use-props.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\n\nfunction createUseRender(forwardMotionProps = false) {\n    const useRender = (Component, props, ref, { latestValues }, isStatic) => {\n        const useVisualProps = isSVGComponent(Component)\n            ? useSVGProps\n            : useHTMLProps;\n        const visualProps = useVisualProps(props, latestValues, isStatic, Component);\n        const filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n        const elementProps = Component !== Fragment\n            ? { ...filteredProps, ...visualProps, ref }\n            : {};\n        /**\n         * If component has been handed a motion value as its child,\n         * memoise its initial value and render that. Subsequent updates\n         * will be handled by the onChange handler\n         */\n        const { children } = props;\n        const renderedChildren = useMemo(() => (isMotionValue(children) ? children.get() : children), [children]);\n        return createElement(Component, {\n            ...elementProps,\n            children: renderedChildren,\n        });\n    };\n    return useRender;\n}\n\nexport { createUseRender };\n","import { createRendererMotionComponent } from '../../motion/index.mjs';\nimport { isSVGComponent } from '../dom/utils/is-svg-component.mjs';\nimport { svgMotionConfig } from '../svg/config-motion.mjs';\nimport { htmlMotionConfig } from '../html/config-motion.mjs';\nimport { createUseRender } from '../dom/use-render.mjs';\n\nfunction createMotionComponentFactory(preloadedFeatures, createVisualElement) {\n    return function createMotionComponent(Component, { forwardMotionProps } = { forwardMotionProps: false }) {\n        const baseConfig = isSVGComponent(Component)\n            ? svgMotionConfig\n            : htmlMotionConfig;\n        const config = {\n            ...baseConfig,\n            preloadedFeatures,\n            useRender: createUseRender(forwardMotionProps),\n            createVisualElement,\n            Component,\n        };\n        return createRendererMotionComponent(config);\n    };\n}\n\nexport { createMotionComponentFactory };\n","// Does this device prefer reduced motion? Returns `null` server-side.\nconst prefersReducedMotion = { current: null };\nconst hasReducedMotionListener = { current: false };\n\nexport { hasReducedMotionListener, prefersReducedMotion };\n","import { color } from '../../../value/types/color/index.mjs';\nimport { complex } from '../../../value/types/complex/index.mjs';\nimport { dimensionValueTypes } from './dimensions.mjs';\nimport { testValueType } from './test.mjs';\n\n/**\n * A list of all ValueTypes\n */\nconst valueTypes = [...dimensionValueTypes, color, complex];\n/**\n * Tests a value against the list of ValueTypes\n */\nconst findValueType = (v) => valueTypes.find(testValueType(v));\n\nexport { findValueType };\n","const visualElementStore = new WeakMap();\n\nexport { visualElementStore };\n","import { time } from '../frameloop/sync-time.mjs';\nimport { featureDefinitions } from '../motion/features/definitions.mjs';\nimport { createBox } from '../projection/geometry/models.mjs';\nimport { isNumericalString } from '../utils/is-numerical-string.mjs';\nimport { isZeroValueString } from '../utils/is-zero-value-string.mjs';\nimport { initPrefersReducedMotion } from '../utils/reduced-motion/index.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from '../utils/reduced-motion/state.mjs';\nimport { SubscriptionManager } from '../utils/subscription-manager.mjs';\nimport { warnOnce } from '../utils/warn-once.mjs';\nimport { motionValue } from '../value/index.mjs';\nimport { complex } from '../value/types/complex/index.mjs';\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\nimport { getAnimatableNone } from './dom/value-types/animatable-none.mjs';\nimport { findValueType } from './dom/value-types/find.mjs';\nimport { transformProps } from './html/utils/keys-transform.mjs';\nimport { visualElementStore } from './store.mjs';\nimport { isControllingVariants, isVariantNode } from './utils/is-controlling-variants.mjs';\nimport { KeyframeResolver } from './utils/KeyframesResolver.mjs';\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\nimport { resolveVariantFromProps } from './utils/resolve-variants.mjs';\nimport { frame, cancelFrame } from '../frameloop/frame.mjs';\n\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\",\n];\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n        return {};\n    }\n    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {\n        /**\n         * A reference to the current underlying Instance, e.g. a HTMLElement\n         * or Three.Mesh etc.\n         */\n        this.current = null;\n        /**\n         * A set containing references to this VisualElement's children.\n         */\n        this.children = new Set();\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        this.isVariantNode = false;\n        this.isControllingVariants = false;\n        /**\n         * Decides whether this VisualElement should animate in reduced motion\n         * mode.\n         *\n         * TODO: This is currently set on every individual VisualElement but feels\n         * like it could be set globally.\n         */\n        this.shouldReduceMotion = null;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        this.values = new Map();\n        this.KeyframeResolver = KeyframeResolver;\n        /**\n         * Cleanup functions for active features (hover/tap/exit etc)\n         */\n        this.features = {};\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        this.valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        this.prevMotionValues = {};\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        /**\n         * An object containing an unsubscribe function for each prop event subscription.\n         * For example, every \"Update\" event can have multiple subscribers via\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n         */\n        this.propEventSubscriptions = {};\n        this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n        this.render = () => {\n            if (!this.current)\n                return;\n            this.triggerBuild();\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n        };\n        this.renderScheduledAt = 0.0;\n        this.scheduleRender = () => {\n            const now = time.now();\n            if (this.renderScheduledAt < now) {\n                this.renderScheduledAt = now;\n                frame.render(this.render, false, true);\n            }\n        };\n        const { latestValues, renderState, onUpdate } = visualState;\n        this.onUpdate = onUpdate;\n        this.latestValues = latestValues;\n        this.baseTarget = { ...latestValues };\n        this.initialValues = props.initial ? { ...latestValues } : {};\n        this.renderState = renderState;\n        this.parent = parent;\n        this.props = props;\n        this.presenceContext = presenceContext;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.reducedMotionConfig = reducedMotionConfig;\n        this.options = options;\n        this.blockInitialAnimation = Boolean(blockInitialAnimation);\n        this.isControllingVariants = isControllingVariants(props);\n        this.isVariantNode = isVariantNode(props);\n        if (this.isVariantNode) {\n            this.variantChildren = new Set();\n        }\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't necessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n    }\n    mount(instance) {\n        this.current = instance;\n        visualElementStore.set(instance, this);\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance);\n        }\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\n        }\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n        if (!hasReducedMotionListener.current) {\n            initPrefersReducedMotion();\n        }\n        this.shouldReduceMotion =\n            this.reducedMotionConfig === \"never\"\n                ? false\n                : this.reducedMotionConfig === \"always\"\n                    ? true\n                    : prefersReducedMotion.current;\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n        }\n        if (this.parent)\n            this.parent.children.add(this);\n        this.update(this.props, this.presenceContext);\n    }\n    unmount() {\n        visualElementStore.delete(this.current);\n        this.projection && this.projection.unmount();\n        cancelFrame(this.notifyUpdate);\n        cancelFrame(this.render);\n        this.valueSubscriptions.forEach((remove) => remove());\n        this.valueSubscriptions.clear();\n        this.removeFromVariantTree && this.removeFromVariantTree();\n        this.parent && this.parent.children.delete(this);\n        for (const key in this.events) {\n            this.events[key].clear();\n        }\n        for (const key in this.features) {\n            const feature = this.features[key];\n            if (feature) {\n                feature.unmount();\n                feature.isMounted = false;\n            }\n        }\n        this.current = null;\n    }\n    bindToMotionValue(key, value) {\n        if (this.valueSubscriptions.has(key)) {\n            this.valueSubscriptions.get(key)();\n        }\n        const valueIsTransform = transformProps.has(key);\n        const removeOnChange = value.on(\"change\", (latestValue) => {\n            this.latestValues[key] = latestValue;\n            this.props.onUpdate && frame.preRender(this.notifyUpdate);\n            if (valueIsTransform && this.projection) {\n                this.projection.isTransformDirty = true;\n            }\n        });\n        const removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\n        let removeSyncCheck;\n        if (window.MotionCheckAppearSync) {\n            removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\n        }\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange();\n            removeOnRenderRequest();\n            if (removeSyncCheck)\n                removeSyncCheck();\n            if (value.owner)\n                value.stop();\n        });\n    }\n    sortNodePosition(other) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (!this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type) {\n            return 0;\n        }\n        return this.sortInstanceNodePosition(this.current, other.current);\n    }\n    updateFeatures() {\n        let key = \"animation\";\n        for (key in featureDefinitions) {\n            const featureDefinition = featureDefinitions[key];\n            if (!featureDefinition)\n                continue;\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition;\n            /**\n             * If this feature is enabled but not active, make a new instance.\n             */\n            if (!this.features[key] &&\n                FeatureConstructor &&\n                isEnabled(this.props)) {\n                this.features[key] = new FeatureConstructor(this);\n            }\n            /**\n             * If we have a feature, mount or update it.\n             */\n            if (this.features[key]) {\n                const feature = this.features[key];\n                if (feature.isMounted) {\n                    feature.update();\n                }\n                else {\n                    feature.mount();\n                    feature.isMounted = true;\n                }\n            }\n        }\n    }\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.props);\n    }\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox();\n    }\n    getStaticValue(key) {\n        return this.latestValues[key];\n    }\n    setStaticValue(key, value) {\n        this.latestValues[key] = value;\n    }\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(props, presenceContext) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender();\n        }\n        this.prevProps = this.props;\n        this.props = props;\n        this.prevPresenceContext = this.presenceContext;\n        this.presenceContext = presenceContext;\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i];\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]();\n                delete this.propEventSubscriptions[key];\n            }\n            const listenerName = (\"on\" + key);\n            const listener = props[listenerName];\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key, listener);\n            }\n        }\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue();\n        }\n        this.onUpdate && this.onUpdate(this);\n    }\n    getProps() {\n        return this.props;\n    }\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name) {\n        return this.props.variants ? this.props.variants[name] : undefined;\n    }\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition;\n    }\n    getTransformPagePoint() {\n        return this.props.transformPagePoint;\n    }\n    getClosestVariantNode() {\n        return this.isVariantNode\n            ? this\n            : this.parent\n                ? this.parent.getClosestVariantNode()\n                : undefined;\n    }\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child) {\n        const closestVariantNode = this.getClosestVariantNode();\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child);\n            return () => closestVariantNode.variantChildren.delete(child);\n        }\n    }\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key, value) {\n        // Remove existing value if it exists\n        const existingValue = this.values.get(key);\n        if (value !== existingValue) {\n            if (existingValue)\n                this.removeValue(key);\n            this.bindToMotionValue(key, value);\n            this.values.set(key, value);\n            this.latestValues[key] = value.get();\n        }\n    }\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key) {\n        this.values.delete(key);\n        const unsubscribe = this.valueSubscriptions.get(key);\n        if (unsubscribe) {\n            unsubscribe();\n            this.valueSubscriptions.delete(key);\n        }\n        delete this.latestValues[key];\n        this.removeValueFromRenderState(key, this.renderState);\n    }\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key) {\n        return this.values.has(key);\n    }\n    getValue(key, defaultValue) {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key];\n        }\n        let value = this.values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(defaultValue === null ? undefined : defaultValue, { owner: this });\n            this.addValue(key, value);\n        }\n        return value;\n    }\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key, target) {\n        var _a;\n        let value = this.latestValues[key] !== undefined || !this.current\n            ? this.latestValues[key]\n            : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);\n        if (value !== undefined && value !== null) {\n            if (typeof value === \"string\" &&\n                (isNumericalString(value) || isZeroValueString(value))) {\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n                value = parseFloat(value);\n            }\n            else if (!findValueType(value) && complex.test(target)) {\n                value = getAnimatableNone(key, target);\n            }\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\n        }\n        return isMotionValue(value) ? value.get() : value;\n    }\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key, value) {\n        this.baseTarget[key] = value;\n    }\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key) {\n        var _a;\n        const { initial } = this.props;\n        let valueFromInitial;\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\n            const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);\n            if (variant) {\n                valueFromInitial = variant[key];\n            }\n        }\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial;\n        }\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key);\n        if (target !== undefined && !isMotionValue(target))\n            return target;\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key];\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        return this.events[eventName].add(callback);\n    }\n    notify(eventName, ...args) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args);\n        }\n    }\n}\n\nexport { VisualElement };\n","import { isBrowser } from '../is-browser.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from './state.mjs';\n\nfunction initPrefersReducedMotion() {\n    hasReducedMotionListener.current = true;\n    if (!isBrowser)\n        return;\n    if (window.matchMedia) {\n        const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\n        const setReducedMotionPreferences = () => (prefersReducedMotion.current = motionMediaQuery.matches);\n        motionMediaQuery.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    }\n    else {\n        prefersReducedMotion.current = false;\n    }\n}\n\nexport { initPrefersReducedMotion };\n","import { warnOnce } from '../../utils/warn-once.mjs';\nimport { motionValue } from '../../value/index.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n    for (const key in next) {\n        const nextValue = next[key];\n        const prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */\n            element.addValue(key, nextValue);\n            /**\n             * Check the version of the incoming motion value with this version\n             * and warn against mismatches.\n             */\n            if (process.env.NODE_ENV === \"development\") {\n                warnOnce(nextValue.version === \"11.18.2\", `Attempting to mix Motion versions ${nextValue.version} with 11.18.2 may not work as expected.`);\n            }\n        }\n        else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping from a motion value to a static value,\n             * create a new motion value from that\n             */\n            element.addValue(key, motionValue(nextValue, { owner: element }));\n        }\n        else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                const existingValue = element.getValue(key);\n                if (existingValue.liveStyle === true) {\n                    existingValue.jump(nextValue);\n                }\n                else if (!existingValue.hasAnimated) {\n                    existingValue.set(nextValue);\n                }\n            }\n            else {\n                const latestValue = element.getStaticValue(key);\n                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));\n            }\n        }\n    }\n    // Handle removed values\n    for (const key in prev) {\n        if (next[key] === undefined)\n            element.removeValue(key);\n    }\n    return next;\n}\n\nexport { updateMotionValuesFromProps };\n","import { VisualElement } from '../VisualElement.mjs';\nimport { DOMKeyframesResolver } from './DOMKeyframesResolver.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\n\nclass DOMVisualElement extends VisualElement {\n    constructor() {\n        super(...arguments);\n        this.KeyframeResolver = DOMKeyframesResolver;\n    }\n    sortInstanceNodePosition(a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props.style\n            ? props.style[key]\n            : undefined;\n    }\n    removeValueFromRenderState(key, { vars, style }) {\n        delete vars[key];\n        delete style[key];\n    }\n    handleChildMotionValue() {\n        if (this.childSubscription) {\n            this.childSubscription();\n            delete this.childSubscription;\n        }\n        const { children } = this.props;\n        if (isMotionValue(children)) {\n            this.childSubscription = children.on(\"change\", (latest) => {\n                if (this.current) {\n                    this.current.textContent = `${latest}`;\n                }\n            });\n        }\n    }\n}\n\nexport { DOMVisualElement };\n","import { measureViewportBox } from '../../projection/utils/measure.mjs';\nimport { DOMVisualElement } from '../dom/DOMVisualElement.mjs';\nimport { isCSSVariableName } from '../dom/utils/is-css-variable.mjs';\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\nimport { transformProps } from './utils/keys-transform.mjs';\nimport { renderHTML } from './utils/render.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\n\nfunction getComputedStyle(element) {\n    return window.getComputedStyle(element);\n}\nclass HTMLVisualElement extends DOMVisualElement {\n    constructor() {\n        super(...arguments);\n        this.type = \"html\";\n        this.renderInstance = renderHTML;\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        else {\n            const computedStyle = getComputedStyle(instance);\n            const value = (isCSSVariableName(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0;\n            return typeof value === \"string\" ? value.trim() : value;\n        }\n    }\n    measureInstanceViewportBox(instance, { transformPagePoint }) {\n        return measureViewportBox(instance, transformPagePoint);\n    }\n    build(renderState, latestValues, props) {\n        buildHTMLStyles(renderState, latestValues, props.transformTemplate);\n    }\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\n    }\n}\n\nexport { HTMLVisualElement, getComputedStyle };\n","import { createBox } from '../../projection/geometry/models.mjs';\nimport { DOMVisualElement } from '../dom/DOMVisualElement.mjs';\nimport { camelToDash } from '../dom/utils/camel-to-dash.mjs';\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\nimport { transformProps } from '../html/utils/keys-transform.mjs';\nimport { buildSVGAttrs } from './utils/build-attrs.mjs';\nimport { camelCaseAttributes } from './utils/camel-case-attrs.mjs';\nimport { isSVGTag } from './utils/is-svg-tag.mjs';\nimport { renderSVG } from './utils/render.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\n\nclass SVGVisualElement extends DOMVisualElement {\n    constructor() {\n        super(...arguments);\n        this.type = \"svg\";\n        this.isSVGTag = false;\n        this.measureInstanceViewportBox = createBox;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props[key];\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return instance.getAttribute(key);\n    }\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\n    }\n    build(renderState, latestValues, props) {\n        buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);\n    }\n    renderInstance(instance, renderState, styleProp, projection) {\n        renderSVG(instance, renderState, styleProp, projection);\n    }\n    mount(instance) {\n        this.isSVGTag = isSVGTag(instance.tagName);\n        super.mount(instance);\n    }\n}\n\nexport { SVGVisualElement };\n","import { Fragment } from 'react';\nimport { HTMLVisualElement } from '../html/HTMLVisualElement.mjs';\nimport { SVGVisualElement } from '../svg/SVGVisualElement.mjs';\nimport { isSVGComponent } from './utils/is-svg-component.mjs';\n\nconst createDomVisualElement = (Component, options) => {\n    return isSVGComponent(Component)\n        ? new SVGVisualElement(options)\n        : new HTMLVisualElement(options, {\n            allowProjection: Component !== Fragment,\n        });\n};\n\nexport { createDomVisualElement };\n","import { createDOMMotionComponentProxy } from '../create-proxy.mjs';\nimport { createMotionComponent } from './create.mjs';\n\nconst motion = /*@__PURE__*/ createDOMMotionComponentProxy(createMotionComponent);\n\nexport { motion };\n","import { animations } from '../../../motion/features/animations.mjs';\nimport { drag } from '../../../motion/features/drag.mjs';\nimport { gestureAnimations } from '../../../motion/features/gestures.mjs';\nimport { layout } from '../../../motion/features/layout.mjs';\nimport { createMotionComponentFactory } from '../create-factory.mjs';\nimport { createDomVisualElement } from '../../dom/create-visual-element.mjs';\n\nconst createMotionComponent = /*@__PURE__*/ createMotionComponentFactory({\n    ...animations,\n    ...gestureAnimations,\n    ...drag,\n    ...layout,\n}, createDomVisualElement);\n\nexport { createMotionComponent };\n","import { analyseComplexValue } from '../../../value/types/complex/index.mjs';\nimport { getAnimatableNone } from '../../dom/value-types/animatable-none.mjs';\n\n/**\n * If we encounter keyframes like \"none\" or \"0\" and we also have keyframes like\n * \"#fff\" or \"200px 200px\" we want to find a keyframe to serve as a template for\n * the \"none\" keyframes. In this case \"#fff\" or \"200px 200px\" - then these get turned into\n * zero equivalents, i.e. \"#fff0\" or \"0px 0px\".\n */\nconst invalidTemplates = new Set([\"auto\", \"none\", \"0\"]);\nfunction makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {\n    let i = 0;\n    let animatableTemplate = undefined;\n    while (i < unresolvedKeyframes.length && !animatableTemplate) {\n        const keyframe = unresolvedKeyframes[i];\n        if (typeof keyframe === \"string\" &&\n            !invalidTemplates.has(keyframe) &&\n            analyseComplexValue(keyframe).values.length) {\n            animatableTemplate = unresolvedKeyframes[i];\n        }\n        i++;\n    }\n    if (animatableTemplate && name) {\n        for (const noneIndex of noneKeyframeIndexes) {\n            unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);\n        }\n    }\n}\n\nexport { makeNoneKeyframesAnimatable };\n","import { invariant } from 'motion-utils';\nimport { isNumericalString } from '../../../utils/is-numerical-string.mjs';\nimport { isCSSVariableToken } from './is-css-variable.mjs';\n\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nconst splitCSSVariableRegex = \n// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words\n/^var\\(--(?:([\\w-]+)|([\\w-]+), ?([a-zA-Z\\d ()%#.,-]+))\\)/u;\nfunction parseCSSVariable(current) {\n    const match = splitCSSVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    const [, token1, token2, fallback] = match;\n    return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];\n}\nconst maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n    const [token, fallback] = parseCSSVariable(current);\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        const trimmed = resolved.trim();\n        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\n    }\n    return isCSSVariableToken(fallback)\n        ? getVariableValue(fallback, element, depth + 1)\n        : fallback;\n}\n\nexport { getVariableValue, parseCSSVariable };\n","import { isNone } from '../../animation/utils/is-none.mjs';\nimport { positionalKeys } from '../html/utils/keys-position.mjs';\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\nimport { isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element || !element.current)\n            return;\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            let keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === \"string\") {\n                keyframe = keyframe.trim();\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current);\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved;\n                    }\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe;\n                    }\n                }\n            }\n        }\n        /**\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */\n        this.resolveNoneKeyframes();\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return;\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */\n        if (originType === targetType)\n            return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i];\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        }\n        else {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true;\n        }\n    }\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this;\n        const noneKeyframeIndexes = [];\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element || !element.current)\n            return;\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        // Set final key frame to measure after next render\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n        }\n    }\n    measureEndState() {\n        var _a;\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element || !element.current)\n            return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe;\n        }\n        // If we removed transform values, reapply them before the next render\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n                element\n                    .getValue(unsetTransformName)\n                    .set(unsetTransformValue);\n            });\n        }\n        this.resolveNoneKeyframes();\n    }\n}\n\nexport { DOMKeyframesResolver };\n","/**\n * Convert camelCase to dash-case properties.\n */\nconst camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, \"$1-$2\").toLowerCase();\n\nexport { camelToDash };\n","const checkStringStartsWith = (token) => (key) => typeof key === \"string\" && key.startsWith(token);\nconst isCSSVariableName = \n/*@__PURE__*/ checkStringStartsWith(\"--\");\nconst startsAsVariableToken = \n/*@__PURE__*/ checkStringStartsWith(\"var(--\");\nconst isCSSVariableToken = (value) => {\n    const startsWithToken = startsAsVariableToken(value);\n    if (!startsWithToken)\n        return false;\n    // Ensure any comments are stripped from the value as this can harm performance of the regex.\n    return singleCssVariableRegex.test(value.split(\"/*\")[0].trim());\n};\nconst singleCssVariableRegex = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu;\n\nexport { isCSSVariableName, isCSSVariableToken };\n","import { number } from '../../../value/types/numbers/index.mjs';\nimport { px } from '../../../value/types/numbers/units.mjs';\nimport { transformPropOrder } from '../../html/utils/keys-transform.mjs';\n\nconst isNumOrPxType = (v) => v === number || v === px;\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\n    if (transform === \"none\" || !transform)\n        return 0;\n    const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/u);\n    if (matrix3d) {\n        return getPosFromMatrix(matrix3d[1], pos3);\n    }\n    else {\n        const matrix = transform.match(/^matrix\\((.+)\\)$/u);\n        if (matrix) {\n            return getPosFromMatrix(matrix[1], pos2);\n        }\n        else {\n            return 0;\n        }\n    }\n};\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n    const removedTransforms = [];\n    nonTranslationalTransformKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    return removedTransforms;\n}\nconst positionalValues = {\n    // Dimensions\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n    top: (_bbox, { top }) => parseFloat(top),\n    left: (_bbox, { left }) => parseFloat(left),\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\n// Alias translate longform names\npositionalValues.translateX = positionalValues.x;\npositionalValues.translateY = positionalValues.y;\n\nexport { isNumOrPxType, positionalValues, removeNonTranslationalTransform };\n","import { complex } from '../../../value/types/complex/index.mjs';\nimport { filter } from '../../../value/types/complex/filter.mjs';\nimport { getDefaultValueType } from './defaults.mjs';\n\nfunction getAnimatableNone(key, value) {\n    let defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== filter)\n        defaultValueType = complex;\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n    return defaultValueType.getAnimatableNone\n        ? defaultValueType.getAnimatableNone(value)\n        : undefined;\n}\n\nexport { getAnimatableNone };\n","import { color } from '../../../value/types/color/index.mjs';\nimport { filter } from '../../../value/types/complex/filter.mjs';\nimport { numberValueTypes } from './number.mjs';\n\n/**\n * A map of default value types for common values\n */\nconst defaultValueTypes = {\n    ...numberValueTypes,\n    // Color props\n    color,\n    backgroundColor: color,\n    outlineColor: color,\n    fill: color,\n    stroke: color,\n    // Border props\n    borderColor: color,\n    borderTopColor: color,\n    borderRightColor: color,\n    borderBottomColor: color,\n    borderLeftColor: color,\n    filter,\n    WebkitFilter: filter,\n};\n/**\n * Gets the default ValueType for the provided value key\n */\nconst getDefaultValueType = (key) => defaultValueTypes[key];\n\nexport { defaultValueTypes, getDefaultValueType };\n","/**\n * ValueType for \"auto\"\n */\nconst auto = {\n    test: (v) => v === \"auto\",\n    parse: (v) => v,\n};\n\nexport { auto };\n","import { number } from '../../../value/types/numbers/index.mjs';\nimport { px, percent, degrees, vw, vh } from '../../../value/types/numbers/units.mjs';\nimport { testValueType } from './test.mjs';\nimport { auto } from './type-auto.mjs';\n\n/**\n * A list of value types commonly used for dimensions\n */\nconst dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nconst findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\n\nexport { dimensionValueTypes, findDimensionValueType };\n","import { px } from '../../../value/types/numbers/units.mjs';\n\nconst browserNumberValueTypes = {\n    // Border props\n    borderWidth: px,\n    borderTopWidth: px,\n    borderRightWidth: px,\n    borderBottomWidth: px,\n    borderLeftWidth: px,\n    borderRadius: px,\n    radius: px,\n    borderTopLeftRadius: px,\n    borderTopRightRadius: px,\n    borderBottomRightRadius: px,\n    borderBottomLeftRadius: px,\n    // Positioning props\n    width: px,\n    maxWidth: px,\n    height: px,\n    maxHeight: px,\n    top: px,\n    right: px,\n    bottom: px,\n    left: px,\n    // Spacing props\n    padding: px,\n    paddingTop: px,\n    paddingRight: px,\n    paddingBottom: px,\n    paddingLeft: px,\n    margin: px,\n    marginTop: px,\n    marginRight: px,\n    marginBottom: px,\n    marginLeft: px,\n    // Misc\n    backgroundPositionX: px,\n    backgroundPositionY: px,\n};\n\nexport { browserNumberValueTypes };\n","import { scale, alpha } from '../../../value/types/numbers/index.mjs';\nimport { degrees, px, progressPercentage } from '../../../value/types/numbers/units.mjs';\n\nconst transformValueTypes = {\n    rotate: degrees,\n    rotateX: degrees,\n    rotateY: degrees,\n    rotateZ: degrees,\n    scale,\n    scaleX: scale,\n    scaleY: scale,\n    scaleZ: scale,\n    skew: degrees,\n    skewX: degrees,\n    skewY: degrees,\n    distance: px,\n    translateX: px,\n    translateY: px,\n    translateZ: px,\n    x: px,\n    y: px,\n    z: px,\n    perspective: px,\n    transformPerspective: px,\n    opacity: alpha,\n    originX: progressPercentage,\n    originY: progressPercentage,\n    originZ: px,\n};\n\nexport { transformValueTypes };\n","import { number } from '../../../value/types/numbers/index.mjs';\n\nconst int = {\n    ...number,\n    transform: Math.round,\n};\n\nexport { int };\n","import { alpha } from '../../../value/types/numbers/index.mjs';\nimport { px } from '../../../value/types/numbers/units.mjs';\nimport { browserNumberValueTypes } from './number-browser.mjs';\nimport { transformValueTypes } from './transform.mjs';\nimport { int } from './type-int.mjs';\n\nconst numberValueTypes = {\n    ...browserNumberValueTypes,\n    ...transformValueTypes,\n    zIndex: int,\n    size: px,\n    // SVG\n    fillOpacity: alpha,\n    strokeOpacity: alpha,\n    numOctaves: int,\n};\n\nexport { numberValueTypes };\n","/**\n * Tests a provided value against a ValueType\n */\nconst testValueType = (v) => (type) => type.test(v);\n\nexport { testValueType };\n","import { transformPropOrder } from './keys-transform.mjs';\n\nconst positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    ...transformPropOrder,\n]);\n\nexport { positionalKeys };\n","/**\n * Generate a list of every possible transform key.\n */\nconst transformPropOrder = [\n    \"transformPerspective\",\n    \"x\",\n    \"y\",\n    \"z\",\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n];\n/**\n * A quick lookup for transform props.\n */\nconst transformProps = new Set(transformPropOrder);\n\nexport { transformPropOrder, transformProps };\n","import { removeNonTranslationalTransform } from '../dom/utils/unit-conversion.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\n\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nfunction measureAllKeyframes() {\n    if (anyNeedsMeasurement) {\n        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\n        const transformsToRestore = new Map();\n        /**\n         * Write pass\n         * If we're measuring elements we want to remove bounding box-changing transforms.\n         */\n        elementsToMeasure.forEach((element) => {\n            const removedTransforms = removeNonTranslationalTransform(element);\n            if (!removedTransforms.length)\n                return;\n            transformsToRestore.set(element, removedTransforms);\n            element.render();\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\n        // Write\n        elementsToMeasure.forEach((element) => {\n            element.render();\n            const restore = transformsToRestore.get(element);\n            if (restore) {\n                restore.forEach(([key, value]) => {\n                    var _a;\n                    (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);\n                });\n            }\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState());\n        // Write\n        resolversToMeasure.forEach((resolver) => {\n            if (resolver.suspendedScrollY !== undefined) {\n                window.scrollTo(0, resolver.suspendedScrollY);\n            }\n        });\n    }\n    anyNeedsMeasurement = false;\n    isScheduled = false;\n    toResolve.forEach((resolver) => resolver.complete());\n    toResolve.clear();\n}\nfunction readAllKeyframes() {\n    toResolve.forEach((resolver) => {\n        resolver.readKeyframes();\n        if (resolver.needsMeasurement) {\n            anyNeedsMeasurement = true;\n        }\n    });\n}\nfunction flushKeyframeResolvers() {\n    readAllKeyframes();\n    measureAllKeyframes();\n}\nclass KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\n        /**\n         * Track whether this resolver has completed. Once complete, it never\n         * needs to attempt keyframe resolution again.\n         */\n        this.isComplete = false;\n        /**\n         * Track whether this resolver is async. If it is, it'll be added to the\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\n         * to trigger read/write thrashing don't need to be async.\n         */\n        this.isAsync = false;\n        /**\n         * Track whether this resolver needs to perform a measurement\n         * to resolve its keyframes.\n         */\n        this.needsMeasurement = false;\n        /**\n         * Track whether this resolver is currently scheduled to resolve\n         * to allow it to be cancelled and resumed externally.\n         */\n        this.isScheduled = false;\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\n        this.onComplete = onComplete;\n        this.name = name;\n        this.motionValue = motionValue;\n        this.element = element;\n        this.isAsync = isAsync;\n    }\n    scheduleResolve() {\n        this.isScheduled = true;\n        if (this.isAsync) {\n            toResolve.add(this);\n            if (!isScheduled) {\n                isScheduled = true;\n                frame.read(readAllKeyframes);\n                frame.resolveKeyframes(measureAllKeyframes);\n            }\n        }\n        else {\n            this.readKeyframes();\n            this.complete();\n        }\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, name, element, motionValue } = this;\n        /**\n         * If a keyframe is null, we hydrate it either by reading it from\n         * the instance, or propagating from previous keyframes.\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (unresolvedKeyframes[i] === null) {\n                /**\n                 * If the first keyframe is null, we need to find its value by sampling the element\n                 */\n                if (i === 0) {\n                    const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\n                    const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n                    if (currentValue !== undefined) {\n                        unresolvedKeyframes[0] = currentValue;\n                    }\n                    else if (element && name) {\n                        const valueAsRead = element.readValue(name, finalKeyframe);\n                        if (valueAsRead !== undefined && valueAsRead !== null) {\n                            unresolvedKeyframes[0] = valueAsRead;\n                        }\n                    }\n                    if (unresolvedKeyframes[0] === undefined) {\n                        unresolvedKeyframes[0] = finalKeyframe;\n                    }\n                    if (motionValue && currentValue === undefined) {\n                        motionValue.set(unresolvedKeyframes[0]);\n                    }\n                }\n                else {\n                    unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\n                }\n            }\n        }\n    }\n    setFinalKeyframe() { }\n    measureInitialState() { }\n    renderEndStyles() { }\n    measureEndState() { }\n    complete() {\n        this.isComplete = true;\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\n        toResolve.delete(this);\n    }\n    cancel() {\n        if (!this.isComplete) {\n            this.isScheduled = false;\n            toResolve.delete(this);\n        }\n    }\n    resume() {\n        if (!this.isComplete)\n            this.scheduleResolve();\n    }\n}\n\nexport { KeyframeResolver, flushKeyframeResolvers };\n","import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { variantProps } from './variant-props.mjs';\n\nfunction isControllingVariants(props) {\n    return (isAnimationControls(props.animate) ||\n        variantProps.some((name) => isVariantLabel(props[name])));\n}\nfunction isVariantNode(props) {\n    return Boolean(isControllingVariants(props) || props.variants);\n}\n\nexport { isControllingVariants, isVariantNode };\n","/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n    return typeof v === \"string\" || Array.isArray(v);\n}\n\nexport { isVariantLabel };\n","import { resolveVariantFromProps } from './resolve-variants.mjs';\n\nfunction resolveVariant(visualElement, definition, custom) {\n    const props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);\n}\n\nexport { resolveVariant };\n","function getValueState(visualElement) {\n    const state = [{}, {}];\n    visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {\n        state[0][key] = value.get();\n        state[1][key] = value.getVelocity();\n    });\n    return state;\n}\nfunction resolveVariantFromProps(props, definition, custom, visualElement) {\n    /**\n     * If the variant definition is a function, resolve.\n     */\n    if (typeof definition === \"function\") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    /**\n     * If the variant definition is a variant label, or\n     * the function returned a variant label, resolve.\n     */\n    if (typeof definition === \"string\") {\n        definition = props.variants && props.variants[definition];\n    }\n    /**\n     * At this point we've resolved both functions and variant labels,\n     * but the resolved variant label might itself have been a function.\n     * If so, resolve. This can only have returned a valid target object.\n     */\n    if (typeof definition === \"function\") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    return definition;\n}\n\nexport { resolveVariantFromProps };\n","import { resolveFinalValueInKeyframes } from '../../utils/resolve-value.mjs';\nimport { motionValue } from '../../value/index.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    const resolved = resolveVariant(visualElement, definition);\n    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};\n    target = { ...target, ...transitionEnd };\n    for (const key in target) {\n        const value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\n\nexport { setTarget };\n","const variantPriorityOrder = [\n    \"animate\",\n    \"whileInView\",\n    \"whileFocus\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileDrag\",\n    \"exit\",\n];\nconst variantProps = [\"initial\", ...variantPriorityOrder];\n\nexport { variantPriorityOrder, variantProps };\n","const MotionGlobalConfig = {\n    skipAnimations: false,\n    useManualTiming: false,\n};\n\nexport { MotionGlobalConfig };\n","function addUniqueItem(arr, item) {\n    if (arr.indexOf(item) === -1)\n        arr.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    if (index > -1)\n        arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem([...arr], fromIndex, toIndex) {\n    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < arr.length) {\n        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n        const [item] = arr.splice(fromIndex, 1);\n        arr.splice(endIndex, 0, item);\n    }\n    return arr;\n}\n\nexport { addUniqueItem, moveItem, removeItem };\n","const clamp = (min, max, v) => {\n    if (v > max)\n        return max;\n    if (v < min)\n        return min;\n    return v;\n};\n\nexport { clamp };\n","const distance = (a, b) => Math.abs(a - b);\nfunction distance2D(a, b) {\n    // Multi-dimensional\n    const xDelta = distance(a.x, b.x);\n    const yDelta = distance(a.y, b.y);\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n}\n\nexport { distance, distance2D };\n","// Fixes https://github.com/motiondivision/motion/issues/2270\nconst getContextWindow = ({ current }) => {\n    return current ? current.ownerDocument.defaultView : null;\n};\n\nexport { getContextWindow };\n","import { invariant, noop, progress } from 'motion-utils';\nimport { clamp } from './clamp.mjs';\nimport { mix } from './mix/index.mjs';\nimport { pipe } from './pipe.mjs';\n\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || mix;\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revist this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n    /**\n     * If we're only provided a single input, we can just make a function\n     * that returns the output.\n     */\n    if (inputLength === 1)\n        return () => output[0];\n    if (inputLength === 2 && output[0] === output[1])\n        return () => output[1];\n    const isZeroDeltaRange = input[0] === input[1];\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [...input].reverse();\n        output = [...output].reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const numMixers = mixers.length;\n    const interpolator = (v) => {\n        if (isZeroDeltaRange && v < input[0])\n            return output[0];\n        let i = 0;\n        if (numMixers > 1) {\n            for (; i < input.length - 2; i++) {\n                if (v < input[i + 1])\n                    break;\n            }\n        }\n        const progressInRange = progress(input[i], input[i + 1], v);\n        return mixers[i](progressInRange);\n    };\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\nexport { interpolate };\n","const isBrowser = typeof window !== \"undefined\";\n\nexport { isBrowser };\n","/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nconst isNumericalString = (v) => /^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(v);\n\nexport { isNumericalString };\n","function isRefObject(ref) {\n    return (ref &&\n        typeof ref === \"object\" &&\n        Object.prototype.hasOwnProperty.call(ref, \"current\"));\n}\n\nexport { isRefObject };\n","/**\n * Check if the value is a zero value string like \"0px\" or \"0%\"\n */\nconst isZeroValueString = (v) => /^0[^.\\s]+$/u.test(v);\n\nexport { isZeroValueString };\n","// Adapted from https://gist.github.com/mjackson/5311256\nfunction hueToRgb(p, q, t) {\n    if (t < 0)\n        t += 1;\n    if (t > 1)\n        t -= 1;\n    if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n    if (t < 1 / 2)\n        return q;\n    if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    }\n    else {\n        const q = lightness < 0.5\n            ? lightness * (1 + saturation)\n            : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha,\n    };\n}\n\nexport { hslaToRgba };\n","function mixImmediate(a, b) {\n    return (p) => (p > 0 ? b : a);\n}\n\nexport { mixImmediate };\n","import { mixNumber } from './number.mjs';\nimport { warning } from 'motion-utils';\nimport { hslaToRgba } from '../hsla-to-rgba.mjs';\nimport { hex } from '../../value/types/color/hex.mjs';\nimport { rgba } from '../../value/types/color/rgba.mjs';\nimport { hsla } from '../../value/types/color/hsla.mjs';\nimport { mixImmediate } from './immediate.mjs';\n\n// Linear color space blending\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\nconst mixLinearColor = (from, to, v) => {\n    const fromExpo = from * from;\n    const expo = v * (to * to - fromExpo) + fromExpo;\n    return expo < 0 ? 0 : Math.sqrt(expo);\n};\nconst colorTypes = [hex, rgba, hsla];\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\nfunction asRGBA(color) {\n    const type = getColorType(color);\n    warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);\n    if (!Boolean(type))\n        return false;\n    let model = type.parse(color);\n    if (type === hsla) {\n        // TODO Remove this cast - needed since Motion's stricter typing\n        model = hslaToRgba(model);\n    }\n    return model;\n}\nconst mixColor = (from, to) => {\n    const fromRGBA = asRGBA(from);\n    const toRGBA = asRGBA(to);\n    if (!fromRGBA || !toRGBA) {\n        return mixImmediate(from, to);\n    }\n    const blended = { ...fromRGBA };\n    return (v) => {\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n        blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);\n        return rgba.transform(blended);\n    };\n};\n\nexport { mixColor, mixLinearColor };\n","const invisibleValues = new Set([\"none\", \"hidden\"]);\n/**\n * Returns a function that, when provided a progress value between 0 and 1,\n * will return the \"none\" or \"hidden\" string only when the progress is that of\n * the origin or target.\n */\nfunction mixVisibility(origin, target) {\n    if (invisibleValues.has(origin)) {\n        return (p) => (p <= 0 ? origin : target);\n    }\n    else {\n        return (p) => (p >= 1 ? target : origin);\n    }\n}\n\nexport { invisibleValues, mixVisibility };\n","import { mixNumber as mixNumber$1 } from './number.mjs';\nimport { mixColor } from './color.mjs';\nimport { pipe } from '../pipe.mjs';\nimport { warning } from 'motion-utils';\nimport { color } from '../../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';\nimport { isCSSVariableToken } from '../../render/dom/utils/is-css-variable.mjs';\nimport { invisibleValues, mixVisibility } from './visibility.mjs';\nimport { mixImmediate } from './immediate.mjs';\n\nfunction mixNumber(a, b) {\n    return (p) => mixNumber$1(a, b, p);\n}\nfunction getMixer(a) {\n    if (typeof a === \"number\") {\n        return mixNumber;\n    }\n    else if (typeof a === \"string\") {\n        return isCSSVariableToken(a)\n            ? mixImmediate\n            : color.test(a)\n                ? mixColor\n                : mixComplex;\n    }\n    else if (Array.isArray(a)) {\n        return mixArray;\n    }\n    else if (typeof a === \"object\") {\n        return color.test(a) ? mixColor : mixObject;\n    }\n    return mixImmediate;\n}\nfunction mixArray(a, b) {\n    const output = [...a];\n    const numValues = output.length;\n    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n    return (p) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](p);\n        }\n        return output;\n    };\n}\nfunction mixObject(a, b) {\n    const output = { ...a, ...b };\n    const blendValue = {};\n    for (const key in output) {\n        if (a[key] !== undefined && b[key] !== undefined) {\n            blendValue[key] = getMixer(a[key])(a[key], b[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n}\nfunction matchOrder(origin, target) {\n    var _a;\n    const orderedOrigin = [];\n    const pointers = { color: 0, var: 0, number: 0 };\n    for (let i = 0; i < target.values.length; i++) {\n        const type = target.types[i];\n        const originIndex = origin.indexes[type][pointers[type]];\n        const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;\n        orderedOrigin[i] = originValue;\n        pointers[type]++;\n    }\n    return orderedOrigin;\n}\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\n        originStats.indexes.number.length >= targetStats.indexes.number.length;\n    if (canInterpolate) {\n        if ((invisibleValues.has(origin) &&\n            !targetStats.values.length) ||\n            (invisibleValues.has(target) &&\n                !originStats.values.length)) {\n            return mixVisibility(origin, target);\n        }\n        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n    }\n    else {\n        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return mixImmediate(origin, target);\n    }\n};\n\nexport { getMixer, mixArray, mixComplex, mixObject };\n","import { getMixer } from './complex.mjs';\nimport { mixNumber } from './number.mjs';\n\nfunction mix(from, to, p) {\n    if (typeof from === \"number\" &&\n        typeof to === \"number\" &&\n        typeof p === \"number\") {\n        return mixNumber(from, to, p);\n    }\n    const mixer = getMixer(from);\n    return mixer(from, to);\n}\n\nexport { mix };\n","/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (usually a number from 0 to 1)\n\n  So progress = 0.5 would change\n\n  from -------- to\n\n  to\n\n  from ---- to\n\n  E.g. from = 10, to = 20, progress = 0.5 => 15\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nconst mixNumber = (from, to, progress) => {\n    return from + (to - from) * progress;\n};\n\nexport { mixNumber };\n","import { fillOffset } from './fill.mjs';\n\nfunction defaultOffset(arr) {\n    const offset = [0];\n    fillOffset(offset, arr.length - 1);\n    return offset;\n}\n\nexport { defaultOffset };\n","import { progress } from 'motion-utils';\nimport { mixNumber } from '../mix/number.mjs';\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mixNumber(min, 1, offsetProgress));\n    }\n}\n\nexport { fillOffset };\n","function convertOffsetToTimes(offset, duration) {\n    return offset.map((o) => o * duration);\n}\n\nexport { convertOffsetToTimes };\n","/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\nconst combineFunctions = (a, b) => (v) => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\nexport { pipe };\n","import { isKeyframesTarget } from '../animation/utils/is-keyframes-target.mjs';\n\nconst isCustomValue = (v) => {\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nconst resolveFinalValueInKeyframes = (v) => {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\nexport { isCustomValue, resolveFinalValueInKeyframes };\n","import { addUniqueItem, removeItem } from './array.mjs';\n\nclass SubscriptionManager {\n    constructor() {\n        this.subscriptions = [];\n    }\n    add(handler) {\n        addUniqueItem(this.subscriptions, handler);\n        return () => removeItem(this.subscriptions, handler);\n    }\n    notify(a, b, c) {\n        const numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (let i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                const handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    }\n    getSize() {\n        return this.subscriptions.length;\n    }\n    clear() {\n        this.subscriptions.length = 0;\n    }\n}\n\nexport { SubscriptionManager };\n","import { useRef } from 'react';\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n    const ref = useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\nexport { useConstant };\n","const instantAnimationState = {\n    current: false,\n};\n\nexport { instantAnimationState };\n","import { useLayoutEffect, useEffect } from 'react';\nimport { isBrowser } from './is-browser.mjs';\n\nconst useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;\n\nexport { useIsomorphicLayoutEffect };\n","/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nexport { velocityPerSecond };\n"],"names":["Feature","constructor","node","this","isMounted","update","convertBoundingBoxToBox","top","left","right","bottom","x","min","max","y","convertBoxToBoundingBox","transformBoxPoints","point","transformPoint","topLeft","bottomRight","scalePoint","scale","originPoint","applyPointDelta","translate","boxScale","undefined","applyAxisDelta","axis","applyBoxDelta","box","TREE_SCALE_SNAP_MIN","TREE_SCALE_SNAP_MAX","applyTreeDeltas","treeScale","treePath","isSharedTransition","treeLength","length","delta","i","projectionDelta","visualElement","options","props","style","display","layoutScroll","scroll","root","transformBox","offset","latestValues","translateAxis","distance","transformAxis","axisTranslate","axisScale","axisOrigin","transform","scaleX","originX","scaleY","originY","SCALE_MIN","SCALE_MAX","TRANSLATE_MIN","TRANSLATE_MAX","calcLength","isNear","value","target","maxDistance","Math","abs","calcAxisDelta","source","origin","isNaN","calcBoxDelta","calcRelativeAxis","relative","parent","calcRelativeBox","calcRelativeAxisPosition","layout","calcRelativePosition","createDelta","createBox","eachAxis","callback","isIdentityScale","hasScale","hasTransform","values","has2DTranslate","z","rotate","rotateX","rotateY","skewX","skewY","is2DTranslate","measureViewportBox","instance","getBoundingClientRect","measurePageBox","element","rootProjectionNode","transformPagePoint","viewportBox","createDOMMotionComponentProxy","componentFactory","Proxy","componentCache","Map","args","get","_target","key","has","set","shallowCompare","next","prev","Array","isArray","prevLength","numVariantProps","getVariantContext","isControllingVariants","context","initial","name","prop","reversePriorityOrder","reverse","numAnimationTypes","createAnimationState","animate","animations","Promise","all","map","animation","animateList","state","createState","isInitialRender","buildResolvedTypeValues","type","acc","definition","_a","resolved","presenceContext","custom","transition","transitionEnd","animateChanges","changedActiveType","removedKeys","Set","encounteredKeys","removedVariantIndex","Infinity","typeState","propIsVariant","activeDelta","isActive","isInherited","manuallyAnimateOnMount","protectedKeys","prevProp","variantDidChange","checkVariantsDidChange","shouldAnimateType","handledRemovedValues","definitionList","resolvedValues","reduce","prevResolvedValues","allKeys","markToAnimate","delete","needsAnimating","motionValue","getValue","liveStyle","hasOwnProperty","valueHasChanged","add","blockInitialAnimation","push","size","fallbackAnimation","forEach","fallbackTarget","getBaseTarget","shouldAnimate","Boolean","resolve","setActive","variantChildren","child","animationState","setAnimateFunction","makeAnimator","getState","reset","createTypeState","whileInView","whileHover","whileTap","whileDrag","whileFocus","exit","AnimationFeature","super","updateAnimationControlsSubscription","getProps","unmountControls","subscribe","mount","prevAnimate","prevProps","unmount","call","id","ExitAnimationFeature","arguments","isPresent","onExitComplete","prevIsPresent","prevPresenceContext","exitAnimation","then","register","globalProjectionState","hasAnimatedSinceResize","hasEverUpdated","pixelsToPercent","pixels","correctBorderRadius","correct","latest","px","test","parseFloat","correctBoxShadow","original","shadow","complex","parse","template","createTransformer","xScale","yScale","averageScale","scaleCorrectors","MeasureLayoutWithContext","Component","componentDidMount","layoutGroup","switchLayoutGroup","layoutId","projection","correctors","defaultScaleCorrectors","Object","assign","group","didUpdate","addEventListener","safeToRemove","setOptions","getSnapshotBeforeUpdate","layoutDependency","drag","willUpdate","promote","relegate","postRender","stack","getStack","members","componentDidUpdate","microtask","currentAnimation","isLead","componentWillUnmount","promoteContext","scheduleCheckAfterUnmount","remove","deregister","render","MeasureLayout","useContext","LayoutGroupContext","L","jsx","SwitchLayoutGroupContext","borderRadius","applyTo","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","boxShadow","compareByDepth","a","b","depth","FlatTree","children","isDirty","sort","delay","timeout","start","now","checkElapsed","timestamp","elapsed","read","borders","numBorders","asNumber","isPx","getRadius","radiusName","easeCrossfadeIn","compress","circ","easeCrossfadeOut","noop","easing","p","progress","copyAxisInto","originAxis","copyBoxInto","originBox","copyAxisDeltaInto","originDelta","removePointDelta","removeAxisTransforms","transforms","scaleKey","originKey","sourceAxis","removeAxisDelta","xKeys","yKeys","removeBoxTransforms","sourceBox","isAxisDeltaZero","isDeltaZero","axisEquals","axisEqualsRounded","round","boxEqualsRounded","aspectRatio","axisDeltaEquals","NodeStack","scheduleRender","prevLead","lead","indexOfNode","findIndex","member","preserveFollowOpacity","show","resumeFrom","preserveOpacity","snapshot","animationValues","isUpdating","isLayoutDirty","crossfade","hide","exitAnimationComplete","resumingFrom","removeLeadSnapshot","metrics","totalNodes","resolvedTargetDeltas","recalculatedProjection","isDebug","window","MotionDebug","transformAxes","hiddenVisibility","visibility","resetDistortingTransform","sharedAnimationValues","setStaticValue","cancelTreeOptimisedTransformAnimations","projectionNode","hasCheckedOptimisedAppear","appearId","MotionHasOptimisedAnimation","MotionCancelOptimisedAnimation","createProjectionNode","attachResizeListener","defaultParent","measureScroll","checkIsScrollRoot","resetTransform","animationId","isTreeAnimating","isAnimationBlocked","isProjectionDirty","isSharedProjectionDirty","isTransformDirty","updateManuallyBlocked","updateBlockedByResize","isSVG","needsReset","shouldResetTransform","eventHandlers","hasTreeAnimated","updateScheduled","scheduleUpdate","projectionUpdateScheduled","checkUpdateFailed","clearAllSnapshots","updateProjection","nodes","propagateDirtyNodes","resolveTargetDelta","calcProjection","cleanDirtyNodes","record","resolvedRelativeTargetAt","hasProjected","isVisible","animationProgress","sharedNodes","path","handler","notifyListeners","subscriptionManager","notify","hasListeners","SVGElement","tagName","current","cancelDelay","resizeUnblockUpdate","finishAnimation","registerSharedNode","hasLayoutChanged","hasRelativeTargetChanged","newLayout","isTreeAnimationBlocked","relativeTarget","layoutTransition","getDefaultTransition","defaultLayoutTransition","onLayoutAnimationStart","onLayoutAnimationComplete","targetChanged","targetLayout","hasOnlyRelativeTargetChanged","layoutRoot","setAnimationOrigin","animationOptions","onPlay","onComplete","shouldReduceMotion","startAnimation","blockUpdate","unblockUpdate","isUpdateBlocked","startUpdate","resetSkewAndRotation","getTransformTemplate","transformTemplate","shouldNotifyListeners","updateScroll","prevTransformTemplateValue","updateSnapshot","clearMeasurements","clearIsLayoutDirty","resetTransformStyle","updateLayout","notifyLayoutUpdate","clamp","isProcessing","process","preRender","clearSnapshot","removeLeadSnapshots","scheduleUpdateProjection","measure","alwaysMeasureLayout","prevLayout","layoutCorrected","layoutBox","phase","needsMeasurement","isRoot","wasRoot","isResetRequested","hasProjection","transformTemplateValue","transformTemplateHasChanged","removeTransform","pageBox","removeElementScroll","roundAxis","measuredBox","some","checkNodeWasScrollRoot","boxWithoutScroll","applyTransform","transformOnly","withTransforms","boxWithoutTransform","setTargetDelta","targetDelta","forceRelativeParentToResolveTarget","relativeParent","forceRecalculation","getLead","isShared","attemptToResolveRelativeTarget","getClosestProjectingParent","relativeTargetOrigin","targetWithTransforms","isProjecting","canSkip","pendingAnimation","prevTreeScaleX","prevTreeScaleY","prevProjectionDelta","createProjectionDeltas","notifyAll","projectionDeltaWithTransform","snapshotLatestValues","mixedValues","relativeLayout","isSharedLayoutAnimation","isOnlyMember","shouldCrossfadeOpacity","hasOpacityCrossfade","prevRelativeTarget","mixTargetDelta","output","from","to","mixAxisDelta","mixAxis","follow","opacity","opacityExit","borderLabel","followRadius","leadRadius","mixValues","stop","onUpdate","completeAnimation","applyTransformsToTarget","shouldAnimatePositionOnly","animationType","xLength","yLength","config","initialPromotionConfig","shouldPreserveFollowOpacity","getPrevLead","hasDistortingTransform","rotateZ","resetValues","getProjectionStyles","styleProp","_b","styles","pointerEvents","emptyStyles","valuesToRender","latestTransform","xTranslate","yTranslate","zTranslate","transformPerspective","elementScaleX","elementScaleY","buildProjectionTransform","transformOrigin","corrected","num","resetTree","clear","measuredLayout","axisSnapshot","layoutDelta","visualDelta","parentSnapshot","parentLayout","relativeSnapshot","onBeforeLayoutMeasure","duration","ease","userAgentContains","string","navigator","userAgent","toLowerCase","includes","roundPoint","DocumentProjectionNode","ref","document","documentElement","scrollLeft","body","scrollTop","HTMLProjectionNode","documentNode","getComputedStyle","position","pan","ProjectionNode","observerCallbacks","WeakMap","observers","fireObserverCallback","entry","fireAllObserverCallbacks","entries","observeIntersection","rootInteresectionObserver","lookupRoot","rootObservers","JSON","stringify","IntersectionObserver","initIntersectionObserver","observe","unobserve","thresholdNames","InViewFeature","hasEnteredView","isInView","startObserver","viewport","margin","rootMargin","amount","once","threshold","isIntersecting","onViewportEnter","onViewportLeave","prevViewport","hasViewportOptionChanged","gestureAnimations","inView","tap","focus","hover","featureProps","featureDefinitions","isEnabled","motionComponentSymbol","Symbol","for","useMotionRef","visualState","externalRef","useCallback","onMount","useVisualElement","createVisualElement","ProjectionNodeConstructor","MotionContext","lazyContext","LazyContext","PresenceContext","reducedMotionConfig","MotionConfigContext","reducedMotion","visualElementRef","useRef","renderer","initialLayoutGroupConfig","dragConstraints","getClosestProjectingNode","useInsertionEffect","optimisedAppearId","wantsHandoff","MotionHandoffIsComplete","MotionIsMounted","updateFeatures","useEffect","queueMicrotask","MotionHandoffMarkAsComplete","allowProjection","createRendererMotionComponent","preloadedFeatures","useRender","useVisualState","MotionComponent","configAndProps","useLayoutId","isStatic","strict","useStrictMode","layoutProjection","combined","getProjectionFunctionality","jsxs","Provider","features","loadFeatures","displayName","ForwardRefMotionComponent","forwardRef","layoutGroupId","lowercaseSVGElements","isSVGComponent","indexOf","makeUseVisualState","make","scrapeMotionValuesFromProps","createRenderState","makeLatestValues","renderState","makeState","scrapeMotionValues","motionValues","isControllingVariants$1","isVariantNode$1","inherit","isInitialAnimationBlocked","variantToSet","list","valueTarget","getValueAsType","translateAlias","numTransforms","buildHTMLStyles","vars","hasTransformOrigin","valueAsType","startsWith","transformString","transformIsDefault","valueIsDefault","trim","buildTransform","originZ","dashKeys","array","camelKeys","calcOrigin","buildSVGAttrs","attrX","attrY","attrScale","pathLength","pathSpacing","pathOffset","isSVGTag","viewBox","attrs","dimensions","width","height","calcSVGTransformOrigin","spacing","useDashCase","keys","buildSVGPath","createHtmlRenderState","createSvgRenderState","tag","renderHTML","setProperty","camelCaseAttributes","renderSVG","_styleProp","setAttribute","isForcedMotionValue","newValues","charAt","toUpperCase","substring","layoutProps","svgMotionConfig","needsMeasure","getBBox","e","updateSVGDimensions","htmlMotionConfig","copyRawValuesOnly","useStyle","useMemo","useInitialMotionValues","useHTMLProps","htmlProps","dragListener","draggable","userSelect","WebkitUserSelect","WebkitTouchCallout","touchAction","tabIndex","onTap","onTapStart","validMotionProps","isValidMotionProp","shouldForward","isValidProp","require","default","useSVGProps","_isStatic","visualProps","rawStyles","createUseRender","forwardMotionProps","filteredProps","isDom","filterProps","elementProps","Fragment","renderedChildren","createElement","createMotionComponentFactory","prefersReducedMotion","hasReducedMotionListener","valueTypes","color","visualElementStore","propEventHandlers","VisualElement","_props","_prevProps","_visualElement","isVariantNode","KeyframeResolver","valueSubscriptions","prevMotionValues","events","propEventSubscriptions","notifyUpdate","triggerBuild","renderInstance","renderScheduledAt","baseTarget","initialValues","willChange","initialMotionValues","removeFromVariantTree","addVariantChild","bindToMotionValue","matchMedia","motionMediaQuery","setReducedMotionPreferences","matches","addListener","initPrefersReducedMotion","feature","valueIsTransform","removeOnChange","on","latestValue","removeOnRenderRequest","removeSyncCheck","MotionCheckAppearSync","owner","sortNodePosition","other","sortInstanceNodePosition","featureDefinition","FeatureConstructor","build","measureInstanceViewportBox","getStaticValue","listener","nextValue","prevValue","addValue","hasValue","existingValue","jump","hasAnimated","removeValue","updateMotionValuesFromProps","handleChildMotionValue","getVariant","variants","getTransformPagePoint","getClosestVariantNode","closestVariantNode","unsubscribe","removeValueFromRenderState","defaultValue","readValue","getBaseTargetFromProps","readValueFromInstance","v","find","setBaseTarget","valueFromInitial","variant","eventName","DOMVisualElement","DOMKeyframesResolver","compareDocumentPosition","childSubscription","textContent","HTMLVisualElement","defaultType","computedStyle","getPropertyValue","m","SVGVisualElement","getAttribute","motion","invalidTemplates","splitCSSVariableRegex","getVariableValue","token","fallback","match","exec","token1","token2","parseCSSVariable","trimmed","unresolvedKeyframes","readKeyframes","keyframe","finalKeyframe","resolveNoneKeyframes","originType","targetType","noneKeyframeIndexes","animatableTemplate","noneIndex","makeNoneKeyframesAnimatable","measureInitialState","suspendedScrollY","pageYOffset","measuredOrigin","measureKeyframe","measureEndState","finalKeyframeIndex","removedTransforms","unsetTransformName","unsetTransformValue","camelToDash","str","replace","checkStringStartsWith","isCSSVariableName","startsAsVariableToken","isCSSVariableToken","singleCssVariableRegex","split","isNumOrPxType","getPosFromMatrix","matrix","pos","getTranslateFromMatrix","pos2","pos3","_bbox","matrix3d","transformKeys","nonTranslationalTransformKeys","filter","removeNonTranslationalTransform","positionalValues","paddingLeft","paddingRight","paddingTop","paddingBottom","translateX","translateY","getAnimatableNone","defaultValueType","defaultValueTypes","backgroundColor","outlineColor","fill","stroke","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","WebkitFilter","getDefaultValueType","dimensionValueTypes","vw","vh","findDimensionValueType","browserNumberValueTypes","borderWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","radius","maxWidth","maxHeight","padding","marginTop","marginRight","marginBottom","marginLeft","backgroundPositionX","backgroundPositionY","transformValueTypes","scaleZ","skew","translateZ","perspective","numberValueTypes","zIndex","fillOpacity","strokeOpacity","numOctaves","testValueType","positionalKeys","transformPropOrder","transformProps","toResolve","isScheduled","anyNeedsMeasurement","measureAllKeyframes","resolversToMeasure","resolver","elementsToMeasure","transformsToRestore","restore","scrollTo","complete","readAllKeyframes","flushKeyframeResolvers","isAsync","isComplete","scheduleResolve","resolveKeyframes","currentValue","valueAsRead","setFinalKeyframe","renderEndStyles","cancel","resume","isVariantLabel","resolveVariant","getValueState","getVelocity","resolveVariantFromProps","velocity","setMotionValue","setTarget","variantPriorityOrder","variantProps","MotionGlobalConfig","skipAnimations","useManualTiming","addUniqueItem","arr","item","removeItem","index","splice","distance2D","xDelta","yDelta","sqrt","getContextWindow","ownerDocument","defaultView","interpolate","input","isClamp","mixer","inputLength","isZeroDeltaRange","mixers","customMixer","mixerFactory","numMixers","easingFunction","createMixers","interpolator","progressInRange","isBrowser","isNumericalString","isRefObject","prototype","isZeroValueString","hueToRgb","q","t","mixImmediate","mixLinearColor","fromExpo","expo","colorTypes","hex","rgba","hsla","asRGBA","model","hue","saturation","lightness","alpha","red","green","blue","hslaToRgba","mixColor","fromRGBA","toRGBA","blended","invisibleValues","mixNumber","getMixer","mixComplex","mixArray","mixObject","numValues","blendValue","originStats","targetStats","indexes","var","number","mixVisibility","pipe","orderedOrigin","pointers","types","originIndex","originValue","matchOrder","mix","defaultOffset","remaining","offsetProgress","fillOffset","convertOffsetToTimes","o","combineFunctions","transformers","isCustomValue","toValue","resolveFinalValueInKeyframes","SubscriptionManager","subscriptions","c","numSubscriptions","getSize","useConstant","init","instantAnimationState","useIsomorphicLayoutEffect","useLayoutEffect","velocityPerSecond","frameDuration"],"sourceRoot":""}