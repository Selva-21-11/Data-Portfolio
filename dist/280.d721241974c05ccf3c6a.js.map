{"version":3,"file":"280.d721241974c05ccf3c6a.js","mappings":"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","sources":["webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/geometry/models.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/delay.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/geometry/copy.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/geometry/utils.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/shared/stack.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/utils/is-svg-element.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/styles/transform.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/node/state.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/projection/utils/measure.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/components/create-proxy.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/utils/path.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/utils/render.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/utils/render.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/config-motion.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/config-motion.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/use-props.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/use-props.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/use-render.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/components/create-factory.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/store.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/VisualElement.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/motion-values.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/components/motion/create.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/utils/make-none-animatable.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/number-browser.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/transform.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/utils/keys-position.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/html/utils/keys-transform.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/KeyframesResolver.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/shallow-compare.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/get-variant-context.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/animation-state.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/setters.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/render/utils/variant-props.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/GlobalConfig.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/array.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/clamp.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/distance.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/get-context-window.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/interpolate.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/is-browser.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/is-ref-object.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/hsla-to-rgba.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/mix/immediate.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/mix/color.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/mix/visibility.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/mix/complex.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/mix/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/mix/number.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/offsets/default.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/offsets/fill.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/offsets/time.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/pipe.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/resolve-value.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/subscription-manager.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/use-constant.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs"],"sourcesContent":["/**\r\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\r\n * it's easier to consider each axis individually. This function returns a bounding box\r\n * as a map of single-axis min/max values.\r\n */\r\nfunction convertBoundingBoxToBox({ top, left, right, bottom, }) {\r\n    return {\r\n        x: { min: left, max: right },\r\n        y: { min: top, max: bottom },\r\n    };\r\n}\r\nfunction convertBoxToBoundingBox({ x, y }) {\r\n    return { top: y.min, right: x.max, bottom: y.max, left: x.min };\r\n}\r\n/**\r\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\r\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\r\n * when measuring DOM elements and DOM event points.\r\n */\r\nfunction transformBoxPoints(point, transformPoint) {\r\n    if (!transformPoint)\r\n        return point;\r\n    const topLeft = transformPoint({ x: point.left, y: point.top });\r\n    const bottomRight = transformPoint({ x: point.right, y: point.bottom });\r\n    return {\r\n        top: topLeft.y,\r\n        left: topLeft.x,\r\n        bottom: bottomRight.y,\r\n        right: bottomRight.x,\r\n    };\r\n}\r\n\r\nexport { convertBoundingBoxToBox, convertBoxToBoundingBox, transformBoxPoints };\r\n","import { mixNumber } from '../../utils/mix/number.mjs';\r\nimport { hasTransform } from '../utils/has-transform.mjs';\r\n\r\n/**\r\n * Scales a point based on a factor and an originPoint\r\n */\r\nfunction scalePoint(point, scale, originPoint) {\r\n    const distanceFromOrigin = point - originPoint;\r\n    const scaled = scale * distanceFromOrigin;\r\n    return originPoint + scaled;\r\n}\r\n/**\r\n * Applies a translate/scale delta to a point\r\n */\r\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\r\n    if (boxScale !== undefined) {\r\n        point = scalePoint(point, boxScale, originPoint);\r\n    }\r\n    return scalePoint(point, scale, originPoint) + translate;\r\n}\r\n/**\r\n * Applies a translate/scale delta to an axis\r\n */\r\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\r\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\r\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\r\n}\r\n/**\r\n * Applies a translate/scale delta to a box\r\n */\r\nfunction applyBoxDelta(box, { x, y }) {\r\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\r\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\r\n}\r\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\r\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\r\n/**\r\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\r\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\r\n *\r\n * This is the final nested loop within updateLayoutDelta for future refactoring\r\n */\r\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\r\n    const treeLength = treePath.length;\r\n    if (!treeLength)\r\n        return;\r\n    // Reset the treeScale\r\n    treeScale.x = treeScale.y = 1;\r\n    let node;\r\n    let delta;\r\n    for (let i = 0; i < treeLength; i++) {\r\n        node = treePath[i];\r\n        delta = node.projectionDelta;\r\n        /**\r\n         * TODO: Prefer to remove this, but currently we have motion components with\r\n         * display: contents in Framer.\r\n         */\r\n        const { visualElement } = node.options;\r\n        if (visualElement &&\r\n            visualElement.props.style &&\r\n            visualElement.props.style.display === \"contents\") {\r\n            continue;\r\n        }\r\n        if (isSharedTransition &&\r\n            node.options.layoutScroll &&\r\n            node.scroll &&\r\n            node !== node.root) {\r\n            transformBox(box, {\r\n                x: -node.scroll.offset.x,\r\n                y: -node.scroll.offset.y,\r\n            });\r\n        }\r\n        if (delta) {\r\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\r\n            treeScale.x *= delta.x.scale;\r\n            treeScale.y *= delta.y.scale;\r\n            // Apply each ancestor's calculated delta into this component's recorded layout box\r\n            applyBoxDelta(box, delta);\r\n        }\r\n        if (isSharedTransition && hasTransform(node.latestValues)) {\r\n            transformBox(box, node.latestValues);\r\n        }\r\n    }\r\n    /**\r\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\r\n     * This will help reduce useless scales getting rendered.\r\n     */\r\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\r\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\r\n        treeScale.x = 1.0;\r\n    }\r\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\r\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\r\n        treeScale.y = 1.0;\r\n    }\r\n}\r\nfunction translateAxis(axis, distance) {\r\n    axis.min = axis.min + distance;\r\n    axis.max = axis.max + distance;\r\n}\r\n/**\r\n * Apply a transform to an axis from the latest resolved motion values.\r\n * This function basically acts as a bridge between a flat motion value map\r\n * and applyAxisDelta\r\n */\r\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\r\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\r\n    // Apply the axis delta to the final axis\r\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\r\n}\r\n/**\r\n * Apply a transform to a box from the latest resolved motion values.\r\n */\r\nfunction transformBox(box, transform) {\r\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\r\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\r\n}\r\n\r\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\r\n","import { mixNumber } from '../../utils/mix/number.mjs';\r\n\r\nconst SCALE_PRECISION = 0.0001;\r\nconst SCALE_MIN = 1 - SCALE_PRECISION;\r\nconst SCALE_MAX = 1 + SCALE_PRECISION;\r\nconst TRANSLATE_PRECISION = 0.01;\r\nconst TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;\r\nconst TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;\r\nfunction calcLength(axis) {\r\n    return axis.max - axis.min;\r\n}\r\nfunction isNear(value, target, maxDistance) {\r\n    return Math.abs(value - target) <= maxDistance;\r\n}\r\nfunction calcAxisDelta(delta, source, target, origin = 0.5) {\r\n    delta.origin = origin;\r\n    delta.originPoint = mixNumber(source.min, source.max, delta.origin);\r\n    delta.scale = calcLength(target) / calcLength(source);\r\n    delta.translate =\r\n        mixNumber(target.min, target.max, delta.origin) - delta.originPoint;\r\n    if ((delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX) ||\r\n        isNaN(delta.scale)) {\r\n        delta.scale = 1.0;\r\n    }\r\n    if ((delta.translate >= TRANSLATE_MIN &&\r\n        delta.translate <= TRANSLATE_MAX) ||\r\n        isNaN(delta.translate)) {\r\n        delta.translate = 0.0;\r\n    }\r\n}\r\nfunction calcBoxDelta(delta, source, target, origin) {\r\n    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);\r\n    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);\r\n}\r\nfunction calcRelativeAxis(target, relative, parent) {\r\n    target.min = parent.min + relative.min;\r\n    target.max = target.min + calcLength(relative);\r\n}\r\nfunction calcRelativeBox(target, relative, parent) {\r\n    calcRelativeAxis(target.x, relative.x, parent.x);\r\n    calcRelativeAxis(target.y, relative.y, parent.y);\r\n}\r\nfunction calcRelativeAxisPosition(target, layout, parent) {\r\n    target.min = layout.min - parent.min;\r\n    target.max = target.min + calcLength(layout);\r\n}\r\nfunction calcRelativePosition(target, layout, parent) {\r\n    calcRelativeAxisPosition(target.x, layout.x, parent.x);\r\n    calcRelativeAxisPosition(target.y, layout.y, parent.y);\r\n}\r\n\r\nexport { calcAxisDelta, calcBoxDelta, calcLength, calcRelativeAxis, calcRelativeAxisPosition, calcRelativeBox, calcRelativePosition, isNear };\r\n","const createAxisDelta = () => ({\r\n    translate: 0,\r\n    scale: 1,\r\n    origin: 0,\r\n    originPoint: 0,\r\n});\r\nconst createDelta = () => ({\r\n    x: createAxisDelta(),\r\n    y: createAxisDelta(),\r\n});\r\nconst createAxis = () => ({ min: 0, max: 0 });\r\nconst createBox = () => ({\r\n    x: createAxis(),\r\n    y: createAxis(),\r\n});\r\n\r\nexport { createAxis, createAxisDelta, createBox, createDelta };\r\n","const compareByDepth = (a, b) => a.depth - b.depth;\r\n\r\nexport { compareByDepth };\r\n","import { addUniqueItem, removeItem } from '../../utils/array.mjs';\r\nimport { compareByDepth } from './compare-by-depth.mjs';\r\n\r\nclass FlatTree {\r\n    constructor() {\r\n        this.children = [];\r\n        this.isDirty = false;\r\n    }\r\n    add(child) {\r\n        addUniqueItem(this.children, child);\r\n        this.isDirty = true;\r\n    }\r\n    remove(child) {\r\n        removeItem(this.children, child);\r\n        this.isDirty = true;\r\n    }\r\n    forEach(callback) {\r\n        this.isDirty && this.children.sort(compareByDepth);\r\n        this.isDirty = false;\r\n        this.children.forEach(callback);\r\n    }\r\n}\r\n\r\nexport { FlatTree };\r\n","import { secondsToMilliseconds } from 'motion-utils';\r\nimport { time } from '../frameloop/sync-time.mjs';\r\nimport { frame, cancelFrame } from '../frameloop/frame.mjs';\r\n\r\n/**\r\n * Timeout defined in ms\r\n */\r\nfunction delay(callback, timeout) {\r\n    const start = time.now();\r\n    const checkElapsed = ({ timestamp }) => {\r\n        const elapsed = timestamp - start;\r\n        if (elapsed >= timeout) {\r\n            cancelFrame(checkElapsed);\r\n            callback(elapsed - timeout);\r\n        }\r\n    };\r\n    frame.read(checkElapsed, true);\r\n    return () => cancelFrame(checkElapsed);\r\n}\r\nfunction delayInSeconds(callback, timeout) {\r\n    return delay(callback, secondsToMilliseconds(timeout));\r\n}\r\n\r\nexport { delay, delayInSeconds };\r\n","import { progress, noop } from 'motion-utils';\r\nimport { circOut } from '../../easing/circ.mjs';\r\nimport { mixNumber } from '../../utils/mix/number.mjs';\r\nimport { percent, px } from '../../value/types/numbers/units.mjs';\r\n\r\nconst borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\r\nconst numBorders = borders.length;\r\nconst asNumber = (value) => typeof value === \"string\" ? parseFloat(value) : value;\r\nconst isPx = (value) => typeof value === \"number\" || px.test(value);\r\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\r\n    if (shouldCrossfadeOpacity) {\r\n        target.opacity = mixNumber(0, \r\n        // TODO Reinstate this if only child\r\n        lead.opacity !== undefined ? lead.opacity : 1, easeCrossfadeIn(progress));\r\n        target.opacityExit = mixNumber(follow.opacity !== undefined ? follow.opacity : 1, 0, easeCrossfadeOut(progress));\r\n    }\r\n    else if (isOnlyMember) {\r\n        target.opacity = mixNumber(follow.opacity !== undefined ? follow.opacity : 1, lead.opacity !== undefined ? lead.opacity : 1, progress);\r\n    }\r\n    /**\r\n     * Mix border radius\r\n     */\r\n    for (let i = 0; i < numBorders; i++) {\r\n        const borderLabel = `border${borders[i]}Radius`;\r\n        let followRadius = getRadius(follow, borderLabel);\r\n        let leadRadius = getRadius(lead, borderLabel);\r\n        if (followRadius === undefined && leadRadius === undefined)\r\n            continue;\r\n        followRadius || (followRadius = 0);\r\n        leadRadius || (leadRadius = 0);\r\n        const canMix = followRadius === 0 ||\r\n            leadRadius === 0 ||\r\n            isPx(followRadius) === isPx(leadRadius);\r\n        if (canMix) {\r\n            target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), 0);\r\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\r\n                target[borderLabel] += \"%\";\r\n            }\r\n        }\r\n        else {\r\n            target[borderLabel] = leadRadius;\r\n        }\r\n    }\r\n    /**\r\n     * Mix rotation\r\n     */\r\n    if (follow.rotate || lead.rotate) {\r\n        target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress);\r\n    }\r\n}\r\nfunction getRadius(values, radiusName) {\r\n    return values[radiusName] !== undefined\r\n        ? values[radiusName]\r\n        : values.borderRadius;\r\n}\r\n// /**\r\n//  * We only want to mix the background color if there's a follow element\r\n//  * that we're not crossfading opacity between. For instance with switch\r\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\r\n//  * element being animated but also cuts down on the number of paints triggered\r\n//  * for elements where opacity is doing that work for us.\r\n//  */\r\n// if (\r\n//     !hasFollowElement &&\r\n//     latestLeadValues.backgroundColor &&\r\n//     latestFollowValues.backgroundColor\r\n// ) {\r\n//     /**\r\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\r\n//      * We could probably create a mixer that runs at the start of the animation but\r\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\r\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\r\n//      */\r\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\r\n//         latestFollowValues.backgroundColor as string,\r\n//         latestLeadValues.backgroundColor as string\r\n//     )(p)\r\n// }\r\nconst easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);\r\nconst easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop);\r\nfunction compress(min, max, easing) {\r\n    return (p) => {\r\n        // Could replace ifs with clamp\r\n        if (p < min)\r\n            return 0;\r\n        if (p > max)\r\n            return 1;\r\n        return easing(progress(min, max, p));\r\n    };\r\n}\r\n\r\nexport { mixValues };\r\n","/**\r\n * Reset an axis to the provided origin box.\r\n *\r\n * This is a mutative operation.\r\n */\r\nfunction copyAxisInto(axis, originAxis) {\r\n    axis.min = originAxis.min;\r\n    axis.max = originAxis.max;\r\n}\r\n/**\r\n * Reset a box to the provided origin box.\r\n *\r\n * This is a mutative operation.\r\n */\r\nfunction copyBoxInto(box, originBox) {\r\n    copyAxisInto(box.x, originBox.x);\r\n    copyAxisInto(box.y, originBox.y);\r\n}\r\n/**\r\n * Reset a delta to the provided origin box.\r\n *\r\n * This is a mutative operation.\r\n */\r\nfunction copyAxisDeltaInto(delta, originDelta) {\r\n    delta.translate = originDelta.translate;\r\n    delta.scale = originDelta.scale;\r\n    delta.originPoint = originDelta.originPoint;\r\n    delta.origin = originDelta.origin;\r\n}\r\n\r\nexport { copyAxisDeltaInto, copyAxisInto, copyBoxInto };\r\n","import { mixNumber } from '../../utils/mix/number.mjs';\r\nimport { percent } from '../../value/types/numbers/units.mjs';\r\nimport { scalePoint } from './delta-apply.mjs';\r\n\r\n/**\r\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\r\n */\r\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\r\n    point -= translate;\r\n    point = scalePoint(point, 1 / scale, originPoint);\r\n    if (boxScale !== undefined) {\r\n        point = scalePoint(point, 1 / boxScale, originPoint);\r\n    }\r\n    return point;\r\n}\r\n/**\r\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\r\n */\r\nfunction removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {\r\n    if (percent.test(translate)) {\r\n        translate = parseFloat(translate);\r\n        const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);\r\n        translate = relativeProgress - sourceAxis.min;\r\n    }\r\n    if (typeof translate !== \"number\")\r\n        return;\r\n    let originPoint = mixNumber(originAxis.min, originAxis.max, origin);\r\n    if (axis === originAxis)\r\n        originPoint -= translate;\r\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\r\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\r\n}\r\n/**\r\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\r\n * and acts as a bridge between motion values and removeAxisDelta\r\n */\r\nfunction removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {\r\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\r\n}\r\n/**\r\n * The names of the motion values we want to apply as translation, scale and origin.\r\n */\r\nconst xKeys = [\"x\", \"scaleX\", \"originX\"];\r\nconst yKeys = [\"y\", \"scaleY\", \"originY\"];\r\n/**\r\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\r\n * and acts as a bridge between motion values and removeAxisDelta\r\n */\r\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\r\n    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);\r\n    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);\r\n}\r\n\r\nexport { removeAxisDelta, removeAxisTransforms, removeBoxTransforms, removePointDelta };\r\n","import { calcLength } from './delta-calc.mjs';\r\n\r\nfunction isAxisDeltaZero(delta) {\r\n    return delta.translate === 0 && delta.scale === 1;\r\n}\r\nfunction isDeltaZero(delta) {\r\n    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\r\n}\r\nfunction axisEquals(a, b) {\r\n    return a.min === b.min && a.max === b.max;\r\n}\r\nfunction boxEquals(a, b) {\r\n    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);\r\n}\r\nfunction axisEqualsRounded(a, b) {\r\n    return (Math.round(a.min) === Math.round(b.min) &&\r\n        Math.round(a.max) === Math.round(b.max));\r\n}\r\nfunction boxEqualsRounded(a, b) {\r\n    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);\r\n}\r\nfunction aspectRatio(box) {\r\n    return calcLength(box.x) / calcLength(box.y);\r\n}\r\nfunction axisDeltaEquals(a, b) {\r\n    return (a.translate === b.translate &&\r\n        a.scale === b.scale &&\r\n        a.originPoint === b.originPoint);\r\n}\r\n\r\nexport { aspectRatio, axisDeltaEquals, axisEquals, axisEqualsRounded, boxEquals, boxEqualsRounded, isDeltaZero };\r\n","import { addUniqueItem, removeItem } from '../../utils/array.mjs';\r\n\r\nclass NodeStack {\r\n    constructor() {\r\n        this.members = [];\r\n    }\r\n    add(node) {\r\n        addUniqueItem(this.members, node);\r\n        node.scheduleRender();\r\n    }\r\n    remove(node) {\r\n        removeItem(this.members, node);\r\n        if (node === this.prevLead) {\r\n            this.prevLead = undefined;\r\n        }\r\n        if (node === this.lead) {\r\n            const prevLead = this.members[this.members.length - 1];\r\n            if (prevLead) {\r\n                this.promote(prevLead);\r\n            }\r\n        }\r\n    }\r\n    relegate(node) {\r\n        const indexOfNode = this.members.findIndex((member) => node === member);\r\n        if (indexOfNode === 0)\r\n            return false;\r\n        /**\r\n         * Find the next projection node that is present\r\n         */\r\n        let prevLead;\r\n        for (let i = indexOfNode; i >= 0; i--) {\r\n            const member = this.members[i];\r\n            if (member.isPresent !== false) {\r\n                prevLead = member;\r\n                break;\r\n            }\r\n        }\r\n        if (prevLead) {\r\n            this.promote(prevLead);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    promote(node, preserveFollowOpacity) {\r\n        const prevLead = this.lead;\r\n        if (node === prevLead)\r\n            return;\r\n        this.prevLead = prevLead;\r\n        this.lead = node;\r\n        node.show();\r\n        if (prevLead) {\r\n            prevLead.instance && prevLead.scheduleRender();\r\n            node.scheduleRender();\r\n            node.resumeFrom = prevLead;\r\n            if (preserveFollowOpacity) {\r\n                node.resumeFrom.preserveOpacity = true;\r\n            }\r\n            if (prevLead.snapshot) {\r\n                node.snapshot = prevLead.snapshot;\r\n                node.snapshot.latestValues =\r\n                    prevLead.animationValues || prevLead.latestValues;\r\n            }\r\n            if (node.root && node.root.isUpdating) {\r\n                node.isLayoutDirty = true;\r\n            }\r\n            const { crossfade } = node.options;\r\n            if (crossfade === false) {\r\n                prevLead.hide();\r\n            }\r\n            /**\r\n             * TODO:\r\n             *   - Test border radius when previous node was deleted\r\n             *   - boxShadow mixing\r\n             *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)\r\n             *   - Shared between element A in transformed container and element B (transform stays the same or changes)\r\n             *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)\r\n             * ---\r\n             *   - Crossfade opacity of root nodes\r\n             *   - layoutId changes after animation\r\n             *   - layoutId changes mid animation\r\n             */\r\n        }\r\n    }\r\n    exitAnimationComplete() {\r\n        this.members.forEach((node) => {\r\n            const { options, resumingFrom } = node;\r\n            options.onExitComplete && options.onExitComplete();\r\n            if (resumingFrom) {\r\n                resumingFrom.options.onExitComplete &&\r\n                    resumingFrom.options.onExitComplete();\r\n            }\r\n        });\r\n    }\r\n    scheduleRender() {\r\n        this.members.forEach((node) => {\r\n            node.instance && node.scheduleRender(false);\r\n        });\r\n    }\r\n    /**\r\n     * Clear any leads that have been removed this render to prevent them from being\r\n     * used in future animations and to prevent memory leaks\r\n     */\r\n    removeLeadSnapshot() {\r\n        if (this.lead && this.lead.snapshot) {\r\n            this.lead.snapshot = undefined;\r\n        }\r\n    }\r\n}\r\n\r\nexport { NodeStack };\r\n","import { getValueTransition } from 'motion-dom';\r\nimport { noop } from 'motion-utils';\r\nimport { animateSingleValue } from '../../animation/animate/single-value.mjs';\r\nimport { getOptimisedAppearId } from '../../animation/optimized-appear/get-appear-id.mjs';\r\nimport { cancelFrame, frameData, frameSteps, frame } from '../../frameloop/frame.mjs';\r\nimport { microtask } from '../../frameloop/microtask.mjs';\r\nimport { time } from '../../frameloop/sync-time.mjs';\r\nimport { isSVGElement } from '../../render/dom/utils/is-svg-element.mjs';\r\nimport { FlatTree } from '../../render/utils/flat-tree.mjs';\r\nimport { clamp } from '../../utils/clamp.mjs';\r\nimport { delay } from '../../utils/delay.mjs';\r\nimport { mixNumber } from '../../utils/mix/number.mjs';\r\nimport { SubscriptionManager } from '../../utils/subscription-manager.mjs';\r\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\r\nimport { mixValues } from '../animation/mix-values.mjs';\r\nimport { copyBoxInto, copyAxisDeltaInto } from '../geometry/copy.mjs';\r\nimport { translateAxis, transformBox, applyBoxDelta, applyTreeDeltas } from '../geometry/delta-apply.mjs';\r\nimport { calcRelativePosition, calcRelativeBox, calcBoxDelta, calcLength, isNear } from '../geometry/delta-calc.mjs';\r\nimport { removeBoxTransforms } from '../geometry/delta-remove.mjs';\r\nimport { createBox, createDelta } from '../geometry/models.mjs';\r\nimport { boxEqualsRounded, isDeltaZero, axisDeltaEquals, aspectRatio, boxEquals } from '../geometry/utils.mjs';\r\nimport { NodeStack } from '../shared/stack.mjs';\r\nimport { scaleCorrectors } from '../styles/scale-correction.mjs';\r\nimport { buildProjectionTransform } from '../styles/transform.mjs';\r\nimport { eachAxis } from '../utils/each-axis.mjs';\r\nimport { hasTransform, hasScale, has2DTranslate } from '../utils/has-transform.mjs';\r\nimport { globalProjectionState } from './state.mjs';\r\n\r\nconst metrics = {\r\n    type: \"projectionFrame\",\r\n    totalNodes: 0,\r\n    resolvedTargetDeltas: 0,\r\n    recalculatedProjection: 0,\r\n};\r\nconst isDebug = typeof window !== \"undefined\" && window.MotionDebug !== undefined;\r\nconst transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\r\nconst hiddenVisibility = { visibility: \"hidden\" };\r\n/**\r\n * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1\r\n * which has a noticeable difference in spring animations\r\n */\r\nconst animationTarget = 1000;\r\nlet id = 0;\r\nfunction resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {\r\n    const { latestValues } = visualElement;\r\n    // Record the distorting transform and then temporarily set it to 0\r\n    if (latestValues[key]) {\r\n        values[key] = latestValues[key];\r\n        visualElement.setStaticValue(key, 0);\r\n        if (sharedAnimationValues) {\r\n            sharedAnimationValues[key] = 0;\r\n        }\r\n    }\r\n}\r\nfunction cancelTreeOptimisedTransformAnimations(projectionNode) {\r\n    projectionNode.hasCheckedOptimisedAppear = true;\r\n    if (projectionNode.root === projectionNode)\r\n        return;\r\n    const { visualElement } = projectionNode.options;\r\n    if (!visualElement)\r\n        return;\r\n    const appearId = getOptimisedAppearId(visualElement);\r\n    if (window.MotionHasOptimisedAnimation(appearId, \"transform\")) {\r\n        const { layout, layoutId } = projectionNode.options;\r\n        window.MotionCancelOptimisedAnimation(appearId, \"transform\", frame, !(layout || layoutId));\r\n    }\r\n    const { parent } = projectionNode;\r\n    if (parent && !parent.hasCheckedOptimisedAppear) {\r\n        cancelTreeOptimisedTransformAnimations(parent);\r\n    }\r\n}\r\nfunction createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform, }) {\r\n    return class ProjectionNode {\r\n        constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {\r\n            /**\r\n             * A unique ID generated for every projection node.\r\n             */\r\n            this.id = id++;\r\n            /**\r\n             * An id that represents a unique session instigated by startUpdate.\r\n             */\r\n            this.animationId = 0;\r\n            /**\r\n             * A Set containing all this component's children. This is used to iterate\r\n             * through the children.\r\n             *\r\n             * TODO: This could be faster to iterate as a flat array stored on the root node.\r\n             */\r\n            this.children = new Set();\r\n            /**\r\n             * Options for the node. We use this to configure what kind of layout animations\r\n             * we should perform (if any).\r\n             */\r\n            this.options = {};\r\n            /**\r\n             * We use this to detect when its safe to shut down part of a projection tree.\r\n             * We have to keep projecting children for scale correction and relative projection\r\n             * until all their parents stop performing layout animations.\r\n             */\r\n            this.isTreeAnimating = false;\r\n            this.isAnimationBlocked = false;\r\n            /**\r\n             * Flag to true if we think this layout has been changed. We can't always know this,\r\n             * currently we set it to true every time a component renders, or if it has a layoutDependency\r\n             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup\r\n             * and if one node is dirtied, they all are.\r\n             */\r\n            this.isLayoutDirty = false;\r\n            /**\r\n             * Flag to true if we think the projection calculations for this node needs\r\n             * recalculating as a result of an updated transform or layout animation.\r\n             */\r\n            this.isProjectionDirty = false;\r\n            /**\r\n             * Flag to true if the layout *or* transform has changed. This then gets propagated\r\n             * throughout the projection tree, forcing any element below to recalculate on the next frame.\r\n             */\r\n            this.isSharedProjectionDirty = false;\r\n            /**\r\n             * Flag transform dirty. This gets propagated throughout the whole tree but is only\r\n             * respected by shared nodes.\r\n             */\r\n            this.isTransformDirty = false;\r\n            /**\r\n             * Block layout updates for instant layout transitions throughout the tree.\r\n             */\r\n            this.updateManuallyBlocked = false;\r\n            this.updateBlockedByResize = false;\r\n            /**\r\n             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`\r\n             * call.\r\n             */\r\n            this.isUpdating = false;\r\n            /**\r\n             * If this is an SVG element we currently disable projection transforms\r\n             */\r\n            this.isSVG = false;\r\n            /**\r\n             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset\r\n             * its projection styles.\r\n             */\r\n            this.needsReset = false;\r\n            /**\r\n             * Flags whether this node should have its transform reset prior to measuring.\r\n             */\r\n            this.shouldResetTransform = false;\r\n            /**\r\n             * Store whether this node has been checked for optimised appear animations. As\r\n             * effects fire bottom-up, and we want to look up the tree for appear animations,\r\n             * this makes sure we only check each path once, stopping at nodes that\r\n             * have already been checked.\r\n             */\r\n            this.hasCheckedOptimisedAppear = false;\r\n            /**\r\n             * An object representing the calculated contextual/accumulated/tree scale.\r\n             * This will be used to scale calculcated projection transforms, as these are\r\n             * calculated in screen-space but need to be scaled for elements to layoutly\r\n             * make it to their calculated destinations.\r\n             *\r\n             * TODO: Lazy-init\r\n             */\r\n            this.treeScale = { x: 1, y: 1 };\r\n            /**\r\n             *\r\n             */\r\n            this.eventHandlers = new Map();\r\n            this.hasTreeAnimated = false;\r\n            // Note: Currently only running on root node\r\n            this.updateScheduled = false;\r\n            this.scheduleUpdate = () => this.update();\r\n            this.projectionUpdateScheduled = false;\r\n            this.checkUpdateFailed = () => {\r\n                if (this.isUpdating) {\r\n                    this.isUpdating = false;\r\n                    this.clearAllSnapshots();\r\n                }\r\n            };\r\n            /**\r\n             * This is a multi-step process as shared nodes might be of different depths. Nodes\r\n             * are sorted by depth order, so we need to resolve the entire tree before moving to\r\n             * the next step.\r\n             */\r\n            this.updateProjection = () => {\r\n                this.projectionUpdateScheduled = false;\r\n                /**\r\n                 * Reset debug counts. Manually resetting rather than creating a new\r\n                 * object each frame.\r\n                 */\r\n                if (isDebug) {\r\n                    metrics.totalNodes =\r\n                        metrics.resolvedTargetDeltas =\r\n                            metrics.recalculatedProjection =\r\n                                0;\r\n                }\r\n                this.nodes.forEach(propagateDirtyNodes);\r\n                this.nodes.forEach(resolveTargetDelta);\r\n                this.nodes.forEach(calcProjection);\r\n                this.nodes.forEach(cleanDirtyNodes);\r\n                if (isDebug) {\r\n                    window.MotionDebug.record(metrics);\r\n                }\r\n            };\r\n            /**\r\n             * Frame calculations\r\n             */\r\n            this.resolvedRelativeTargetAt = 0.0;\r\n            this.hasProjected = false;\r\n            this.isVisible = true;\r\n            this.animationProgress = 0;\r\n            /**\r\n             * Shared layout\r\n             */\r\n            // TODO Only running on root node\r\n            this.sharedNodes = new Map();\r\n            this.latestValues = latestValues;\r\n            this.root = parent ? parent.root || parent : this;\r\n            this.path = parent ? [...parent.path, parent] : [];\r\n            this.parent = parent;\r\n            this.depth = parent ? parent.depth + 1 : 0;\r\n            for (let i = 0; i < this.path.length; i++) {\r\n                this.path[i].shouldResetTransform = true;\r\n            }\r\n            if (this.root === this)\r\n                this.nodes = new FlatTree();\r\n        }\r\n        addEventListener(name, handler) {\r\n            if (!this.eventHandlers.has(name)) {\r\n                this.eventHandlers.set(name, new SubscriptionManager());\r\n            }\r\n            return this.eventHandlers.get(name).add(handler);\r\n        }\r\n        notifyListeners(name, ...args) {\r\n            const subscriptionManager = this.eventHandlers.get(name);\r\n            subscriptionManager && subscriptionManager.notify(...args);\r\n        }\r\n        hasListeners(name) {\r\n            return this.eventHandlers.has(name);\r\n        }\r\n        /**\r\n         * Lifecycles\r\n         */\r\n        mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {\r\n            if (this.instance)\r\n                return;\r\n            this.isSVG = isSVGElement(instance);\r\n            this.instance = instance;\r\n            const { layoutId, layout, visualElement } = this.options;\r\n            if (visualElement && !visualElement.current) {\r\n                visualElement.mount(instance);\r\n            }\r\n            this.root.nodes.add(this);\r\n            this.parent && this.parent.children.add(this);\r\n            if (isLayoutDirty && (layout || layoutId)) {\r\n                this.isLayoutDirty = true;\r\n            }\r\n            if (attachResizeListener) {\r\n                let cancelDelay;\r\n                const resizeUnblockUpdate = () => (this.root.updateBlockedByResize = false);\r\n                attachResizeListener(instance, () => {\r\n                    this.root.updateBlockedByResize = true;\r\n                    cancelDelay && cancelDelay();\r\n                    cancelDelay = delay(resizeUnblockUpdate, 250);\r\n                    if (globalProjectionState.hasAnimatedSinceResize) {\r\n                        globalProjectionState.hasAnimatedSinceResize = false;\r\n                        this.nodes.forEach(finishAnimation);\r\n                    }\r\n                });\r\n            }\r\n            if (layoutId) {\r\n                this.root.registerSharedNode(layoutId, this);\r\n            }\r\n            // Only register the handler if it requires layout animation\r\n            if (this.options.animate !== false &&\r\n                visualElement &&\r\n                (layoutId || layout)) {\r\n                this.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout, }) => {\r\n                    if (this.isTreeAnimationBlocked()) {\r\n                        this.target = undefined;\r\n                        this.relativeTarget = undefined;\r\n                        return;\r\n                    }\r\n                    // TODO: Check here if an animation exists\r\n                    const layoutTransition = this.options.transition ||\r\n                        visualElement.getDefaultTransition() ||\r\n                        defaultLayoutTransition;\r\n                    const { onLayoutAnimationStart, onLayoutAnimationComplete, } = visualElement.getProps();\r\n                    /**\r\n                     * The target layout of the element might stay the same,\r\n                     * but its position relative to its parent has changed.\r\n                     */\r\n                    const targetChanged = !this.targetLayout ||\r\n                        !boxEqualsRounded(this.targetLayout, newLayout) ||\r\n                        hasRelativeTargetChanged;\r\n                    /**\r\n                     * If the layout hasn't seemed to have changed, it might be that the\r\n                     * element is visually in the same place in the document but its position\r\n                     * relative to its parent has indeed changed. So here we check for that.\r\n                     */\r\n                    const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;\r\n                    if (this.options.layoutRoot ||\r\n                        (this.resumeFrom && this.resumeFrom.instance) ||\r\n                        hasOnlyRelativeTargetChanged ||\r\n                        (hasLayoutChanged &&\r\n                            (targetChanged || !this.currentAnimation))) {\r\n                        if (this.resumeFrom) {\r\n                            this.resumingFrom = this.resumeFrom;\r\n                            this.resumingFrom.resumingFrom = undefined;\r\n                        }\r\n                        this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\r\n                        const animationOptions = {\r\n                            ...getValueTransition(layoutTransition, \"layout\"),\r\n                            onPlay: onLayoutAnimationStart,\r\n                            onComplete: onLayoutAnimationComplete,\r\n                        };\r\n                        if (visualElement.shouldReduceMotion ||\r\n                            this.options.layoutRoot) {\r\n                            animationOptions.delay = 0;\r\n                            animationOptions.type = false;\r\n                        }\r\n                        this.startAnimation(animationOptions);\r\n                    }\r\n                    else {\r\n                        /**\r\n                         * If the layout hasn't changed and we have an animation that hasn't started yet,\r\n                         * finish it immediately. Otherwise it will be animating from a location\r\n                         * that was probably never commited to screen and look like a jumpy box.\r\n                         */\r\n                        if (!hasLayoutChanged) {\r\n                            finishAnimation(this);\r\n                        }\r\n                        if (this.isLead() && this.options.onExitComplete) {\r\n                            this.options.onExitComplete();\r\n                        }\r\n                    }\r\n                    this.targetLayout = newLayout;\r\n                });\r\n            }\r\n        }\r\n        unmount() {\r\n            this.options.layoutId && this.willUpdate();\r\n            this.root.nodes.remove(this);\r\n            const stack = this.getStack();\r\n            stack && stack.remove(this);\r\n            this.parent && this.parent.children.delete(this);\r\n            this.instance = undefined;\r\n            cancelFrame(this.updateProjection);\r\n        }\r\n        // only on the root\r\n        blockUpdate() {\r\n            this.updateManuallyBlocked = true;\r\n        }\r\n        unblockUpdate() {\r\n            this.updateManuallyBlocked = false;\r\n        }\r\n        isUpdateBlocked() {\r\n            return this.updateManuallyBlocked || this.updateBlockedByResize;\r\n        }\r\n        isTreeAnimationBlocked() {\r\n            return (this.isAnimationBlocked ||\r\n                (this.parent && this.parent.isTreeAnimationBlocked()) ||\r\n                false);\r\n        }\r\n        // Note: currently only running on root node\r\n        startUpdate() {\r\n            if (this.isUpdateBlocked())\r\n                return;\r\n            this.isUpdating = true;\r\n            this.nodes && this.nodes.forEach(resetSkewAndRotation);\r\n            this.animationId++;\r\n        }\r\n        getTransformTemplate() {\r\n            const { visualElement } = this.options;\r\n            return visualElement && visualElement.getProps().transformTemplate;\r\n        }\r\n        willUpdate(shouldNotifyListeners = true) {\r\n            this.root.hasTreeAnimated = true;\r\n            if (this.root.isUpdateBlocked()) {\r\n                this.options.onExitComplete && this.options.onExitComplete();\r\n                return;\r\n            }\r\n            /**\r\n             * If we're running optimised appear animations then these must be\r\n             * cancelled before measuring the DOM. This is so we can measure\r\n             * the true layout of the element rather than the WAAPI animation\r\n             * which will be unaffected by the resetSkewAndRotate step.\r\n             *\r\n             * Note: This is a DOM write. Worst case scenario is this is sandwiched\r\n             * between other snapshot reads which will cause unnecessary style recalculations.\r\n             * This has to happen here though, as we don't yet know which nodes will need\r\n             * snapshots in startUpdate(), but we only want to cancel optimised animations\r\n             * if a layout animation measurement is actually going to be affected by them.\r\n             */\r\n            if (window.MotionCancelOptimisedAnimation &&\r\n                !this.hasCheckedOptimisedAppear) {\r\n                cancelTreeOptimisedTransformAnimations(this);\r\n            }\r\n            !this.root.isUpdating && this.root.startUpdate();\r\n            if (this.isLayoutDirty)\r\n                return;\r\n            this.isLayoutDirty = true;\r\n            for (let i = 0; i < this.path.length; i++) {\r\n                const node = this.path[i];\r\n                node.shouldResetTransform = true;\r\n                node.updateScroll(\"snapshot\");\r\n                if (node.options.layoutRoot) {\r\n                    node.willUpdate(false);\r\n                }\r\n            }\r\n            const { layoutId, layout } = this.options;\r\n            if (layoutId === undefined && !layout)\r\n                return;\r\n            const transformTemplate = this.getTransformTemplate();\r\n            this.prevTransformTemplateValue = transformTemplate\r\n                ? transformTemplate(this.latestValues, \"\")\r\n                : undefined;\r\n            this.updateSnapshot();\r\n            shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\r\n        }\r\n        update() {\r\n            this.updateScheduled = false;\r\n            const updateWasBlocked = this.isUpdateBlocked();\r\n            // When doing an instant transition, we skip the layout update,\r\n            // but should still clean up the measurements so that the next\r\n            // snapshot could be taken correctly.\r\n            if (updateWasBlocked) {\r\n                this.unblockUpdate();\r\n                this.clearAllSnapshots();\r\n                this.nodes.forEach(clearMeasurements);\r\n                return;\r\n            }\r\n            if (!this.isUpdating) {\r\n                this.nodes.forEach(clearIsLayoutDirty);\r\n            }\r\n            this.isUpdating = false;\r\n            /**\r\n             * Write\r\n             */\r\n            this.nodes.forEach(resetTransformStyle);\r\n            /**\r\n             * Read ==================\r\n             */\r\n            // Update layout measurements of updated children\r\n            this.nodes.forEach(updateLayout);\r\n            /**\r\n             * Write\r\n             */\r\n            // Notify listeners that the layout is updated\r\n            this.nodes.forEach(notifyLayoutUpdate);\r\n            this.clearAllSnapshots();\r\n            /**\r\n             * Manually flush any pending updates. Ideally\r\n             * we could leave this to the following requestAnimationFrame but this seems\r\n             * to leave a flash of incorrectly styled content.\r\n             */\r\n            const now = time.now();\r\n            frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);\r\n            frameData.timestamp = now;\r\n            frameData.isProcessing = true;\r\n            frameSteps.update.process(frameData);\r\n            frameSteps.preRender.process(frameData);\r\n            frameSteps.render.process(frameData);\r\n            frameData.isProcessing = false;\r\n        }\r\n        didUpdate() {\r\n            if (!this.updateScheduled) {\r\n                this.updateScheduled = true;\r\n                microtask.read(this.scheduleUpdate);\r\n            }\r\n        }\r\n        clearAllSnapshots() {\r\n            this.nodes.forEach(clearSnapshot);\r\n            this.sharedNodes.forEach(removeLeadSnapshots);\r\n        }\r\n        scheduleUpdateProjection() {\r\n            if (!this.projectionUpdateScheduled) {\r\n                this.projectionUpdateScheduled = true;\r\n                frame.preRender(this.updateProjection, false, true);\r\n            }\r\n        }\r\n        scheduleCheckAfterUnmount() {\r\n            /**\r\n             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,\r\n             * we manually call didUpdate to give a chance to the siblings to animate.\r\n             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.\r\n             */\r\n            frame.postRender(() => {\r\n                if (this.isLayoutDirty) {\r\n                    this.root.didUpdate();\r\n                }\r\n                else {\r\n                    this.root.checkUpdateFailed();\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Update measurements\r\n         */\r\n        updateSnapshot() {\r\n            if (this.snapshot || !this.instance)\r\n                return;\r\n            this.snapshot = this.measure();\r\n        }\r\n        updateLayout() {\r\n            if (!this.instance)\r\n                return;\r\n            // TODO: Incorporate into a forwarded scroll offset\r\n            this.updateScroll();\r\n            if (!(this.options.alwaysMeasureLayout && this.isLead()) &&\r\n                !this.isLayoutDirty) {\r\n                return;\r\n            }\r\n            /**\r\n             * When a node is mounted, it simply resumes from the prevLead's\r\n             * snapshot instead of taking a new one, but the ancestors scroll\r\n             * might have updated while the prevLead is unmounted. We need to\r\n             * update the scroll again to make sure the layout we measure is\r\n             * up to date.\r\n             */\r\n            if (this.resumeFrom && !this.resumeFrom.instance) {\r\n                for (let i = 0; i < this.path.length; i++) {\r\n                    const node = this.path[i];\r\n                    node.updateScroll();\r\n                }\r\n            }\r\n            const prevLayout = this.layout;\r\n            this.layout = this.measure(false);\r\n            this.layoutCorrected = createBox();\r\n            this.isLayoutDirty = false;\r\n            this.projectionDelta = undefined;\r\n            this.notifyListeners(\"measure\", this.layout.layoutBox);\r\n            const { visualElement } = this.options;\r\n            visualElement &&\r\n                visualElement.notify(\"LayoutMeasure\", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);\r\n        }\r\n        updateScroll(phase = \"measure\") {\r\n            let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);\r\n            if (this.scroll &&\r\n                this.scroll.animationId === this.root.animationId &&\r\n                this.scroll.phase === phase) {\r\n                needsMeasurement = false;\r\n            }\r\n            if (needsMeasurement) {\r\n                const isRoot = checkIsScrollRoot(this.instance);\r\n                this.scroll = {\r\n                    animationId: this.root.animationId,\r\n                    phase,\r\n                    isRoot,\r\n                    offset: measureScroll(this.instance),\r\n                    wasRoot: this.scroll ? this.scroll.isRoot : isRoot,\r\n                };\r\n            }\r\n        }\r\n        resetTransform() {\r\n            if (!resetTransform)\r\n                return;\r\n            const isResetRequested = this.isLayoutDirty ||\r\n                this.shouldResetTransform ||\r\n                this.options.alwaysMeasureLayout;\r\n            const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\r\n            const transformTemplate = this.getTransformTemplate();\r\n            const transformTemplateValue = transformTemplate\r\n                ? transformTemplate(this.latestValues, \"\")\r\n                : undefined;\r\n            const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\r\n            if (isResetRequested &&\r\n                (hasProjection ||\r\n                    hasTransform(this.latestValues) ||\r\n                    transformTemplateHasChanged)) {\r\n                resetTransform(this.instance, transformTemplateValue);\r\n                this.shouldResetTransform = false;\r\n                this.scheduleRender();\r\n            }\r\n        }\r\n        measure(removeTransform = true) {\r\n            const pageBox = this.measurePageBox();\r\n            let layoutBox = this.removeElementScroll(pageBox);\r\n            /**\r\n             * Measurements taken during the pre-render stage\r\n             * still have transforms applied so we remove them\r\n             * via calculation.\r\n             */\r\n            if (removeTransform) {\r\n                layoutBox = this.removeTransform(layoutBox);\r\n            }\r\n            roundBox(layoutBox);\r\n            return {\r\n                animationId: this.root.animationId,\r\n                measuredBox: pageBox,\r\n                layoutBox,\r\n                latestValues: {},\r\n                source: this.id,\r\n            };\r\n        }\r\n        measurePageBox() {\r\n            var _a;\r\n            const { visualElement } = this.options;\r\n            if (!visualElement)\r\n                return createBox();\r\n            const box = visualElement.measureViewportBox();\r\n            const wasInScrollRoot = ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);\r\n            if (!wasInScrollRoot) {\r\n                // Remove viewport scroll to give page-relative coordinates\r\n                const { scroll } = this.root;\r\n                if (scroll) {\r\n                    translateAxis(box.x, scroll.offset.x);\r\n                    translateAxis(box.y, scroll.offset.y);\r\n                }\r\n            }\r\n            return box;\r\n        }\r\n        removeElementScroll(box) {\r\n            var _a;\r\n            const boxWithoutScroll = createBox();\r\n            copyBoxInto(boxWithoutScroll, box);\r\n            if ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) {\r\n                return boxWithoutScroll;\r\n            }\r\n            /**\r\n             * Performance TODO: Keep a cumulative scroll offset down the tree\r\n             * rather than loop back up the path.\r\n             */\r\n            for (let i = 0; i < this.path.length; i++) {\r\n                const node = this.path[i];\r\n                const { scroll, options } = node;\r\n                if (node !== this.root && scroll && options.layoutScroll) {\r\n                    /**\r\n                     * If this is a new scroll root, we want to remove all previous scrolls\r\n                     * from the viewport box.\r\n                     */\r\n                    if (scroll.wasRoot) {\r\n                        copyBoxInto(boxWithoutScroll, box);\r\n                    }\r\n                    translateAxis(boxWithoutScroll.x, scroll.offset.x);\r\n                    translateAxis(boxWithoutScroll.y, scroll.offset.y);\r\n                }\r\n            }\r\n            return boxWithoutScroll;\r\n        }\r\n        applyTransform(box, transformOnly = false) {\r\n            const withTransforms = createBox();\r\n            copyBoxInto(withTransforms, box);\r\n            for (let i = 0; i < this.path.length; i++) {\r\n                const node = this.path[i];\r\n                if (!transformOnly &&\r\n                    node.options.layoutScroll &&\r\n                    node.scroll &&\r\n                    node !== node.root) {\r\n                    transformBox(withTransforms, {\r\n                        x: -node.scroll.offset.x,\r\n                        y: -node.scroll.offset.y,\r\n                    });\r\n                }\r\n                if (!hasTransform(node.latestValues))\r\n                    continue;\r\n                transformBox(withTransforms, node.latestValues);\r\n            }\r\n            if (hasTransform(this.latestValues)) {\r\n                transformBox(withTransforms, this.latestValues);\r\n            }\r\n            return withTransforms;\r\n        }\r\n        removeTransform(box) {\r\n            const boxWithoutTransform = createBox();\r\n            copyBoxInto(boxWithoutTransform, box);\r\n            for (let i = 0; i < this.path.length; i++) {\r\n                const node = this.path[i];\r\n                if (!node.instance)\r\n                    continue;\r\n                if (!hasTransform(node.latestValues))\r\n                    continue;\r\n                hasScale(node.latestValues) && node.updateSnapshot();\r\n                const sourceBox = createBox();\r\n                const nodeBox = node.measurePageBox();\r\n                copyBoxInto(sourceBox, nodeBox);\r\n                removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : undefined, sourceBox);\r\n            }\r\n            if (hasTransform(this.latestValues)) {\r\n                removeBoxTransforms(boxWithoutTransform, this.latestValues);\r\n            }\r\n            return boxWithoutTransform;\r\n        }\r\n        setTargetDelta(delta) {\r\n            this.targetDelta = delta;\r\n            this.root.scheduleUpdateProjection();\r\n            this.isProjectionDirty = true;\r\n        }\r\n        setOptions(options) {\r\n            this.options = {\r\n                ...this.options,\r\n                ...options,\r\n                crossfade: options.crossfade !== undefined ? options.crossfade : true,\r\n            };\r\n        }\r\n        clearMeasurements() {\r\n            this.scroll = undefined;\r\n            this.layout = undefined;\r\n            this.snapshot = undefined;\r\n            this.prevTransformTemplateValue = undefined;\r\n            this.targetDelta = undefined;\r\n            this.target = undefined;\r\n            this.isLayoutDirty = false;\r\n        }\r\n        forceRelativeParentToResolveTarget() {\r\n            if (!this.relativeParent)\r\n                return;\r\n            /**\r\n             * If the parent target isn't up-to-date, force it to update.\r\n             * This is an unfortunate de-optimisation as it means any updating relative\r\n             * projection will cause all the relative parents to recalculate back\r\n             * up the tree.\r\n             */\r\n            if (this.relativeParent.resolvedRelativeTargetAt !==\r\n                frameData.timestamp) {\r\n                this.relativeParent.resolveTargetDelta(true);\r\n            }\r\n        }\r\n        resolveTargetDelta(forceRecalculation = false) {\r\n            var _a;\r\n            /**\r\n             * Once the dirty status of nodes has been spread through the tree, we also\r\n             * need to check if we have a shared node of a different depth that has itself\r\n             * been dirtied.\r\n             */\r\n            const lead = this.getLead();\r\n            this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);\r\n            this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);\r\n            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);\r\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\r\n            /**\r\n             * We don't use transform for this step of processing so we don't\r\n             * need to check whether any nodes have changed transform.\r\n             */\r\n            const canSkip = !(forceRecalculation ||\r\n                (isShared && this.isSharedProjectionDirty) ||\r\n                this.isProjectionDirty ||\r\n                ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) ||\r\n                this.attemptToResolveRelativeTarget ||\r\n                this.root.updateBlockedByResize);\r\n            if (canSkip)\r\n                return;\r\n            const { layout, layoutId } = this.options;\r\n            /**\r\n             * If we have no layout, we can't perform projection, so early return\r\n             */\r\n            if (!this.layout || !(layout || layoutId))\r\n                return;\r\n            this.resolvedRelativeTargetAt = frameData.timestamp;\r\n            /**\r\n             * If we don't have a targetDelta but do have a layout, we can attempt to resolve\r\n             * a relativeParent. This will allow a component to perform scale correction\r\n             * even if no animation has started.\r\n             */\r\n            if (!this.targetDelta && !this.relativeTarget) {\r\n                const relativeParent = this.getClosestProjectingParent();\r\n                if (relativeParent &&\r\n                    relativeParent.layout &&\r\n                    this.animationProgress !== 1) {\r\n                    this.relativeParent = relativeParent;\r\n                    this.forceRelativeParentToResolveTarget();\r\n                    this.relativeTarget = createBox();\r\n                    this.relativeTargetOrigin = createBox();\r\n                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);\r\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\r\n                }\r\n                else {\r\n                    this.relativeParent = this.relativeTarget = undefined;\r\n                }\r\n            }\r\n            /**\r\n             * If we have no relative target or no target delta our target isn't valid\r\n             * for this frame.\r\n             */\r\n            if (!this.relativeTarget && !this.targetDelta)\r\n                return;\r\n            /**\r\n             * Lazy-init target data structure\r\n             */\r\n            if (!this.target) {\r\n                this.target = createBox();\r\n                this.targetWithTransforms = createBox();\r\n            }\r\n            /**\r\n             * If we've got a relative box for this component, resolve it into a target relative to the parent.\r\n             */\r\n            if (this.relativeTarget &&\r\n                this.relativeTargetOrigin &&\r\n                this.relativeParent &&\r\n                this.relativeParent.target) {\r\n                this.forceRelativeParentToResolveTarget();\r\n                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\r\n                /**\r\n                 * If we've only got a targetDelta, resolve it into a target\r\n                 */\r\n            }\r\n            else if (this.targetDelta) {\r\n                if (Boolean(this.resumingFrom)) {\r\n                    // TODO: This is creating a new object every frame\r\n                    this.target = this.applyTransform(this.layout.layoutBox);\r\n                }\r\n                else {\r\n                    copyBoxInto(this.target, this.layout.layoutBox);\r\n                }\r\n                applyBoxDelta(this.target, this.targetDelta);\r\n            }\r\n            else {\r\n                /**\r\n                 * If no target, use own layout as target\r\n                 */\r\n                copyBoxInto(this.target, this.layout.layoutBox);\r\n            }\r\n            /**\r\n             * If we've been told to attempt to resolve a relative target, do so.\r\n             */\r\n            if (this.attemptToResolveRelativeTarget) {\r\n                this.attemptToResolveRelativeTarget = false;\r\n                const relativeParent = this.getClosestProjectingParent();\r\n                if (relativeParent &&\r\n                    Boolean(relativeParent.resumingFrom) ===\r\n                        Boolean(this.resumingFrom) &&\r\n                    !relativeParent.options.layoutScroll &&\r\n                    relativeParent.target &&\r\n                    this.animationProgress !== 1) {\r\n                    this.relativeParent = relativeParent;\r\n                    this.forceRelativeParentToResolveTarget();\r\n                    this.relativeTarget = createBox();\r\n                    this.relativeTargetOrigin = createBox();\r\n                    calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);\r\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\r\n                }\r\n                else {\r\n                    this.relativeParent = this.relativeTarget = undefined;\r\n                }\r\n            }\r\n            /**\r\n             * Increase debug counter for resolved target deltas\r\n             */\r\n            if (isDebug) {\r\n                metrics.resolvedTargetDeltas++;\r\n            }\r\n        }\r\n        getClosestProjectingParent() {\r\n            if (!this.parent ||\r\n                hasScale(this.parent.latestValues) ||\r\n                has2DTranslate(this.parent.latestValues)) {\r\n                return undefined;\r\n            }\r\n            if (this.parent.isProjecting()) {\r\n                return this.parent;\r\n            }\r\n            else {\r\n                return this.parent.getClosestProjectingParent();\r\n            }\r\n        }\r\n        isProjecting() {\r\n            return Boolean((this.relativeTarget ||\r\n                this.targetDelta ||\r\n                this.options.layoutRoot) &&\r\n                this.layout);\r\n        }\r\n        calcProjection() {\r\n            var _a;\r\n            const lead = this.getLead();\r\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\r\n            let canSkip = true;\r\n            /**\r\n             * If this is a normal layout animation and neither this node nor its nearest projecting\r\n             * is dirty then we can't skip.\r\n             */\r\n            if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {\r\n                canSkip = false;\r\n            }\r\n            /**\r\n             * If this is a shared layout animation and this node's shared projection is dirty then\r\n             * we can't skip.\r\n             */\r\n            if (isShared &&\r\n                (this.isSharedProjectionDirty || this.isTransformDirty)) {\r\n                canSkip = false;\r\n            }\r\n            /**\r\n             * If we have resolved the target this frame we must recalculate the\r\n             * projection to ensure it visually represents the internal calculations.\r\n             */\r\n            if (this.resolvedRelativeTargetAt === frameData.timestamp) {\r\n                canSkip = false;\r\n            }\r\n            if (canSkip)\r\n                return;\r\n            const { layout, layoutId } = this.options;\r\n            /**\r\n             * If this section of the tree isn't animating we can\r\n             * delete our target sources for the following frame.\r\n             */\r\n            this.isTreeAnimating = Boolean((this.parent && this.parent.isTreeAnimating) ||\r\n                this.currentAnimation ||\r\n                this.pendingAnimation);\r\n            if (!this.isTreeAnimating) {\r\n                this.targetDelta = this.relativeTarget = undefined;\r\n            }\r\n            if (!this.layout || !(layout || layoutId))\r\n                return;\r\n            /**\r\n             * Reset the corrected box with the latest values from box, as we're then going\r\n             * to perform mutative operations on it.\r\n             */\r\n            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);\r\n            /**\r\n             * Record previous tree scales before updating.\r\n             */\r\n            const prevTreeScaleX = this.treeScale.x;\r\n            const prevTreeScaleY = this.treeScale.y;\r\n            /**\r\n             * Apply all the parent deltas to this box to produce the corrected box. This\r\n             * is the layout box, as it will appear on screen as a result of the transforms of its parents.\r\n             */\r\n            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);\r\n            /**\r\n             * If this layer needs to perform scale correction but doesn't have a target,\r\n             * use the layout as the target.\r\n             */\r\n            if (lead.layout &&\r\n                !lead.target &&\r\n                (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {\r\n                lead.target = lead.layout.layoutBox;\r\n                lead.targetWithTransforms = createBox();\r\n            }\r\n            const { target } = lead;\r\n            if (!target) {\r\n                /**\r\n                 * If we don't have a target to project into, but we were previously\r\n                 * projecting, we want to remove the stored transform and schedule\r\n                 * a render to ensure the elements reflect the removed transform.\r\n                 */\r\n                if (this.prevProjectionDelta) {\r\n                    this.createProjectionDeltas();\r\n                    this.scheduleRender();\r\n                }\r\n                return;\r\n            }\r\n            if (!this.projectionDelta || !this.prevProjectionDelta) {\r\n                this.createProjectionDeltas();\r\n            }\r\n            else {\r\n                copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);\r\n                copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);\r\n            }\r\n            /**\r\n             * Update the delta between the corrected box and the target box before user-set transforms were applied.\r\n             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\r\n             * for our layout reprojection, but still allow them to be scaled correctly by the user.\r\n             * It might be that to simplify this we may want to accept that user-set scale is also corrected\r\n             * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\r\n             * to allow people to choose whether these styles are corrected based on just the\r\n             * layout reprojection or the final bounding box.\r\n             */\r\n            calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\r\n            if (this.treeScale.x !== prevTreeScaleX ||\r\n                this.treeScale.y !== prevTreeScaleY ||\r\n                !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) ||\r\n                !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {\r\n                this.hasProjected = true;\r\n                this.scheduleRender();\r\n                this.notifyListeners(\"projectionUpdate\", target);\r\n            }\r\n            /**\r\n             * Increase debug counter for recalculated projections\r\n             */\r\n            if (isDebug) {\r\n                metrics.recalculatedProjection++;\r\n            }\r\n        }\r\n        hide() {\r\n            this.isVisible = false;\r\n            // TODO: Schedule render\r\n        }\r\n        show() {\r\n            this.isVisible = true;\r\n            // TODO: Schedule render\r\n        }\r\n        scheduleRender(notifyAll = true) {\r\n            var _a;\r\n            (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.scheduleRender();\r\n            if (notifyAll) {\r\n                const stack = this.getStack();\r\n                stack && stack.scheduleRender();\r\n            }\r\n            if (this.resumingFrom && !this.resumingFrom.instance) {\r\n                this.resumingFrom = undefined;\r\n            }\r\n        }\r\n        createProjectionDeltas() {\r\n            this.prevProjectionDelta = createDelta();\r\n            this.projectionDelta = createDelta();\r\n            this.projectionDeltaWithTransform = createDelta();\r\n        }\r\n        setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {\r\n            const snapshot = this.snapshot;\r\n            const snapshotLatestValues = snapshot\r\n                ? snapshot.latestValues\r\n                : {};\r\n            const mixedValues = { ...this.latestValues };\r\n            const targetDelta = createDelta();\r\n            if (!this.relativeParent ||\r\n                !this.relativeParent.options.layoutRoot) {\r\n                this.relativeTarget = this.relativeTargetOrigin = undefined;\r\n            }\r\n            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\r\n            const relativeLayout = createBox();\r\n            const snapshotSource = snapshot ? snapshot.source : undefined;\r\n            const layoutSource = this.layout ? this.layout.source : undefined;\r\n            const isSharedLayoutAnimation = snapshotSource !== layoutSource;\r\n            const stack = this.getStack();\r\n            const isOnlyMember = !stack || stack.members.length <= 1;\r\n            const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &&\r\n                !isOnlyMember &&\r\n                this.options.crossfade === true &&\r\n                !this.path.some(hasOpacityCrossfade));\r\n            this.animationProgress = 0;\r\n            let prevRelativeTarget;\r\n            this.mixTargetDelta = (latest) => {\r\n                const progress = latest / 1000;\r\n                mixAxisDelta(targetDelta.x, delta.x, progress);\r\n                mixAxisDelta(targetDelta.y, delta.y, progress);\r\n                this.setTargetDelta(targetDelta);\r\n                if (this.relativeTarget &&\r\n                    this.relativeTargetOrigin &&\r\n                    this.layout &&\r\n                    this.relativeParent &&\r\n                    this.relativeParent.layout) {\r\n                    calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);\r\n                    mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);\r\n                    /**\r\n                     * If this is an unchanged relative target we can consider the\r\n                     * projection not dirty.\r\n                     */\r\n                    if (prevRelativeTarget &&\r\n                        boxEquals(this.relativeTarget, prevRelativeTarget)) {\r\n                        this.isProjectionDirty = false;\r\n                    }\r\n                    if (!prevRelativeTarget)\r\n                        prevRelativeTarget = createBox();\r\n                    copyBoxInto(prevRelativeTarget, this.relativeTarget);\r\n                }\r\n                if (isSharedLayoutAnimation) {\r\n                    this.animationValues = mixedValues;\r\n                    mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);\r\n                }\r\n                this.root.scheduleUpdateProjection();\r\n                this.scheduleRender();\r\n                this.animationProgress = progress;\r\n            };\r\n            this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);\r\n        }\r\n        startAnimation(options) {\r\n            this.notifyListeners(\"animationStart\");\r\n            this.currentAnimation && this.currentAnimation.stop();\r\n            if (this.resumingFrom && this.resumingFrom.currentAnimation) {\r\n                this.resumingFrom.currentAnimation.stop();\r\n            }\r\n            if (this.pendingAnimation) {\r\n                cancelFrame(this.pendingAnimation);\r\n                this.pendingAnimation = undefined;\r\n            }\r\n            /**\r\n             * Start the animation in the next frame to have a frame with progress 0,\r\n             * where the target is the same as when the animation started, so we can\r\n             * calculate the relative positions correctly for instant transitions.\r\n             */\r\n            this.pendingAnimation = frame.update(() => {\r\n                globalProjectionState.hasAnimatedSinceResize = true;\r\n                this.currentAnimation = animateSingleValue(0, animationTarget, {\r\n                    ...options,\r\n                    onUpdate: (latest) => {\r\n                        this.mixTargetDelta(latest);\r\n                        options.onUpdate && options.onUpdate(latest);\r\n                    },\r\n                    onComplete: () => {\r\n                        options.onComplete && options.onComplete();\r\n                        this.completeAnimation();\r\n                    },\r\n                });\r\n                if (this.resumingFrom) {\r\n                    this.resumingFrom.currentAnimation = this.currentAnimation;\r\n                }\r\n                this.pendingAnimation = undefined;\r\n            });\r\n        }\r\n        completeAnimation() {\r\n            if (this.resumingFrom) {\r\n                this.resumingFrom.currentAnimation = undefined;\r\n                this.resumingFrom.preserveOpacity = undefined;\r\n            }\r\n            const stack = this.getStack();\r\n            stack && stack.exitAnimationComplete();\r\n            this.resumingFrom =\r\n                this.currentAnimation =\r\n                    this.animationValues =\r\n                        undefined;\r\n            this.notifyListeners(\"animationComplete\");\r\n        }\r\n        finishAnimation() {\r\n            if (this.currentAnimation) {\r\n                this.mixTargetDelta && this.mixTargetDelta(animationTarget);\r\n                this.currentAnimation.stop();\r\n            }\r\n            this.completeAnimation();\r\n        }\r\n        applyTransformsToTarget() {\r\n            const lead = this.getLead();\r\n            let { targetWithTransforms, target, layout, latestValues } = lead;\r\n            if (!targetWithTransforms || !target || !layout)\r\n                return;\r\n            /**\r\n             * If we're only animating position, and this element isn't the lead element,\r\n             * then instead of projecting into the lead box we instead want to calculate\r\n             * a new target that aligns the two boxes but maintains the layout shape.\r\n             */\r\n            if (this !== lead &&\r\n                this.layout &&\r\n                layout &&\r\n                shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {\r\n                target = this.target || createBox();\r\n                const xLength = calcLength(this.layout.layoutBox.x);\r\n                target.x.min = lead.target.x.min;\r\n                target.x.max = target.x.min + xLength;\r\n                const yLength = calcLength(this.layout.layoutBox.y);\r\n                target.y.min = lead.target.y.min;\r\n                target.y.max = target.y.min + yLength;\r\n            }\r\n            copyBoxInto(targetWithTransforms, target);\r\n            /**\r\n             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\r\n             * This is the final box that we will then project into by calculating a transform delta and\r\n             * applying it to the corrected box.\r\n             */\r\n            transformBox(targetWithTransforms, latestValues);\r\n            /**\r\n             * Update the delta between the corrected box and the final target box, after\r\n             * user-set transforms are applied to it. This will be used by the renderer to\r\n             * create a transform style that will reproject the element from its layout layout\r\n             * into the desired bounding box.\r\n             */\r\n            calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\r\n        }\r\n        registerSharedNode(layoutId, node) {\r\n            if (!this.sharedNodes.has(layoutId)) {\r\n                this.sharedNodes.set(layoutId, new NodeStack());\r\n            }\r\n            const stack = this.sharedNodes.get(layoutId);\r\n            stack.add(node);\r\n            const config = node.options.initialPromotionConfig;\r\n            node.promote({\r\n                transition: config ? config.transition : undefined,\r\n                preserveFollowOpacity: config && config.shouldPreserveFollowOpacity\r\n                    ? config.shouldPreserveFollowOpacity(node)\r\n                    : undefined,\r\n            });\r\n        }\r\n        isLead() {\r\n            const stack = this.getStack();\r\n            return stack ? stack.lead === this : true;\r\n        }\r\n        getLead() {\r\n            var _a;\r\n            const { layoutId } = this.options;\r\n            return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\r\n        }\r\n        getPrevLead() {\r\n            var _a;\r\n            const { layoutId } = this.options;\r\n            return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;\r\n        }\r\n        getStack() {\r\n            const { layoutId } = this.options;\r\n            if (layoutId)\r\n                return this.root.sharedNodes.get(layoutId);\r\n        }\r\n        promote({ needsReset, transition, preserveFollowOpacity, } = {}) {\r\n            const stack = this.getStack();\r\n            if (stack)\r\n                stack.promote(this, preserveFollowOpacity);\r\n            if (needsReset) {\r\n                this.projectionDelta = undefined;\r\n                this.needsReset = true;\r\n            }\r\n            if (transition)\r\n                this.setOptions({ transition });\r\n        }\r\n        relegate() {\r\n            const stack = this.getStack();\r\n            if (stack) {\r\n                return stack.relegate(this);\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        resetSkewAndRotation() {\r\n            const { visualElement } = this.options;\r\n            if (!visualElement)\r\n                return;\r\n            // If there's no detected skew or rotation values, we can early return without a forced render.\r\n            let hasDistortingTransform = false;\r\n            /**\r\n             * An unrolled check for rotation values. Most elements don't have any rotation and\r\n             * skipping the nested loop and new object creation is 50% faster.\r\n             */\r\n            const { latestValues } = visualElement;\r\n            if (latestValues.z ||\r\n                latestValues.rotate ||\r\n                latestValues.rotateX ||\r\n                latestValues.rotateY ||\r\n                latestValues.rotateZ ||\r\n                latestValues.skewX ||\r\n                latestValues.skewY) {\r\n                hasDistortingTransform = true;\r\n            }\r\n            // If there's no distorting values, we don't need to do any more.\r\n            if (!hasDistortingTransform)\r\n                return;\r\n            const resetValues = {};\r\n            if (latestValues.z) {\r\n                resetDistortingTransform(\"z\", visualElement, resetValues, this.animationValues);\r\n            }\r\n            // Check the skew and rotate value of all axes and reset to 0\r\n            for (let i = 0; i < transformAxes.length; i++) {\r\n                resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\r\n                resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\r\n            }\r\n            // Force a render of this element to apply the transform with all skews and rotations\r\n            // set to 0.\r\n            visualElement.render();\r\n            // Put back all the values we reset\r\n            for (const key in resetValues) {\r\n                visualElement.setStaticValue(key, resetValues[key]);\r\n                if (this.animationValues) {\r\n                    this.animationValues[key] = resetValues[key];\r\n                }\r\n            }\r\n            // Schedule a render for the next frame. This ensures we won't visually\r\n            // see the element with the reset rotate value applied.\r\n            visualElement.scheduleRender();\r\n        }\r\n        getProjectionStyles(styleProp) {\r\n            var _a, _b;\r\n            if (!this.instance || this.isSVG)\r\n                return undefined;\r\n            if (!this.isVisible) {\r\n                return hiddenVisibility;\r\n            }\r\n            const styles = {\r\n                visibility: \"\",\r\n            };\r\n            const transformTemplate = this.getTransformTemplate();\r\n            if (this.needsReset) {\r\n                this.needsReset = false;\r\n                styles.opacity = \"\";\r\n                styles.pointerEvents =\r\n                    resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\";\r\n                styles.transform = transformTemplate\r\n                    ? transformTemplate(this.latestValues, \"\")\r\n                    : \"none\";\r\n                return styles;\r\n            }\r\n            const lead = this.getLead();\r\n            if (!this.projectionDelta || !this.layout || !lead.target) {\r\n                const emptyStyles = {};\r\n                if (this.options.layoutId) {\r\n                    emptyStyles.opacity =\r\n                        this.latestValues.opacity !== undefined\r\n                            ? this.latestValues.opacity\r\n                            : 1;\r\n                    emptyStyles.pointerEvents =\r\n                        resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\";\r\n                }\r\n                if (this.hasProjected && !hasTransform(this.latestValues)) {\r\n                    emptyStyles.transform = transformTemplate\r\n                        ? transformTemplate({}, \"\")\r\n                        : \"none\";\r\n                    this.hasProjected = false;\r\n                }\r\n                return emptyStyles;\r\n            }\r\n            const valuesToRender = lead.animationValues || lead.latestValues;\r\n            this.applyTransformsToTarget();\r\n            styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\r\n            if (transformTemplate) {\r\n                styles.transform = transformTemplate(valuesToRender, styles.transform);\r\n            }\r\n            const { x, y } = this.projectionDelta;\r\n            styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;\r\n            if (lead.animationValues) {\r\n                /**\r\n                 * If the lead component is animating, assign this either the entering/leaving\r\n                 * opacity\r\n                 */\r\n                styles.opacity =\r\n                    lead === this\r\n                        ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1\r\n                        : this.preserveOpacity\r\n                            ? this.latestValues.opacity\r\n                            : valuesToRender.opacityExit;\r\n            }\r\n            else {\r\n                /**\r\n                 * Or we're not animating at all, set the lead component to its layout\r\n                 * opacity and other components to hidden.\r\n                 */\r\n                styles.opacity =\r\n                    lead === this\r\n                        ? valuesToRender.opacity !== undefined\r\n                            ? valuesToRender.opacity\r\n                            : \"\"\r\n                        : valuesToRender.opacityExit !== undefined\r\n                            ? valuesToRender.opacityExit\r\n                            : 0;\r\n            }\r\n            /**\r\n             * Apply scale correction\r\n             */\r\n            for (const key in scaleCorrectors) {\r\n                if (valuesToRender[key] === undefined)\r\n                    continue;\r\n                const { correct, applyTo } = scaleCorrectors[key];\r\n                /**\r\n                 * Only apply scale correction to the value if we have an\r\n                 * active projection transform. Otherwise these values become\r\n                 * vulnerable to distortion if the element changes size without\r\n                 * a corresponding layout animation.\r\n                 */\r\n                const corrected = styles.transform === \"none\"\r\n                    ? valuesToRender[key]\r\n                    : correct(valuesToRender[key], lead);\r\n                if (applyTo) {\r\n                    const num = applyTo.length;\r\n                    for (let i = 0; i < num; i++) {\r\n                        styles[applyTo[i]] = corrected;\r\n                    }\r\n                }\r\n                else {\r\n                    styles[key] = corrected;\r\n                }\r\n            }\r\n            /**\r\n             * Disable pointer events on follow components. This is to ensure\r\n             * that if a follow component covers a lead component it doesn't block\r\n             * pointer events on the lead.\r\n             */\r\n            if (this.options.layoutId) {\r\n                styles.pointerEvents =\r\n                    lead === this\r\n                        ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\"\r\n                        : \"none\";\r\n            }\r\n            return styles;\r\n        }\r\n        clearSnapshot() {\r\n            this.resumeFrom = this.snapshot = undefined;\r\n        }\r\n        // Only run on root\r\n        resetTree() {\r\n            this.root.nodes.forEach((node) => { var _a; return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop(); });\r\n            this.root.nodes.forEach(clearMeasurements);\r\n            this.root.sharedNodes.clear();\r\n        }\r\n    };\r\n}\r\nfunction updateLayout(node) {\r\n    node.updateLayout();\r\n}\r\nfunction notifyLayoutUpdate(node) {\r\n    var _a;\r\n    const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;\r\n    if (node.isLead() &&\r\n        node.layout &&\r\n        snapshot &&\r\n        node.hasListeners(\"didUpdate\")) {\r\n        const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;\r\n        const { animationType } = node.options;\r\n        const isShared = snapshot.source !== node.layout.source;\r\n        // TODO Maybe we want to also resize the layout snapshot so we don't trigger\r\n        // animations for instance if layout=\"size\" and an element has only changed position\r\n        if (animationType === \"size\") {\r\n            eachAxis((axis) => {\r\n                const axisSnapshot = isShared\r\n                    ? snapshot.measuredBox[axis]\r\n                    : snapshot.layoutBox[axis];\r\n                const length = calcLength(axisSnapshot);\r\n                axisSnapshot.min = layout[axis].min;\r\n                axisSnapshot.max = axisSnapshot.min + length;\r\n            });\r\n        }\r\n        else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {\r\n            eachAxis((axis) => {\r\n                const axisSnapshot = isShared\r\n                    ? snapshot.measuredBox[axis]\r\n                    : snapshot.layoutBox[axis];\r\n                const length = calcLength(layout[axis]);\r\n                axisSnapshot.max = axisSnapshot.min + length;\r\n                /**\r\n                 * Ensure relative target gets resized and rerendererd\r\n                 */\r\n                if (node.relativeTarget && !node.currentAnimation) {\r\n                    node.isProjectionDirty = true;\r\n                    node.relativeTarget[axis].max =\r\n                        node.relativeTarget[axis].min + length;\r\n                }\r\n            });\r\n        }\r\n        const layoutDelta = createDelta();\r\n        calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);\r\n        const visualDelta = createDelta();\r\n        if (isShared) {\r\n            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);\r\n        }\r\n        else {\r\n            calcBoxDelta(visualDelta, layout, snapshot.layoutBox);\r\n        }\r\n        const hasLayoutChanged = !isDeltaZero(layoutDelta);\r\n        let hasRelativeTargetChanged = false;\r\n        if (!node.resumeFrom) {\r\n            const relativeParent = node.getClosestProjectingParent();\r\n            /**\r\n             * If the relativeParent is itself resuming from a different element then\r\n             * the relative snapshot is not relavent\r\n             */\r\n            if (relativeParent && !relativeParent.resumeFrom) {\r\n                const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;\r\n                if (parentSnapshot && parentLayout) {\r\n                    const relativeSnapshot = createBox();\r\n                    calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);\r\n                    const relativeLayout = createBox();\r\n                    calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);\r\n                    if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {\r\n                        hasRelativeTargetChanged = true;\r\n                    }\r\n                    if (relativeParent.options.layoutRoot) {\r\n                        node.relativeTarget = relativeLayout;\r\n                        node.relativeTargetOrigin = relativeSnapshot;\r\n                        node.relativeParent = relativeParent;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        node.notifyListeners(\"didUpdate\", {\r\n            layout,\r\n            snapshot,\r\n            delta: visualDelta,\r\n            layoutDelta,\r\n            hasLayoutChanged,\r\n            hasRelativeTargetChanged,\r\n        });\r\n    }\r\n    else if (node.isLead()) {\r\n        const { onExitComplete } = node.options;\r\n        onExitComplete && onExitComplete();\r\n    }\r\n    /**\r\n     * Clearing transition\r\n     * TODO: Investigate why this transition is being passed in as {type: false } from Framer\r\n     * and why we need it at all\r\n     */\r\n    node.options.transition = undefined;\r\n}\r\nfunction propagateDirtyNodes(node) {\r\n    /**\r\n     * Increase debug counter for nodes encountered this frame\r\n     */\r\n    if (isDebug) {\r\n        metrics.totalNodes++;\r\n    }\r\n    if (!node.parent)\r\n        return;\r\n    /**\r\n     * If this node isn't projecting, propagate isProjectionDirty. It will have\r\n     * no performance impact but it will allow the next child that *is* projecting\r\n     * but *isn't* dirty to just check its parent to see if *any* ancestor needs\r\n     * correcting.\r\n     */\r\n    if (!node.isProjecting()) {\r\n        node.isProjectionDirty = node.parent.isProjectionDirty;\r\n    }\r\n    /**\r\n     * Propagate isSharedProjectionDirty and isTransformDirty\r\n     * throughout the whole tree. A future revision can take another look at\r\n     * this but for safety we still recalcualte shared nodes.\r\n     */\r\n    node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty ||\r\n        node.parent.isProjectionDirty ||\r\n        node.parent.isSharedProjectionDirty));\r\n    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);\r\n}\r\nfunction cleanDirtyNodes(node) {\r\n    node.isProjectionDirty =\r\n        node.isSharedProjectionDirty =\r\n            node.isTransformDirty =\r\n                false;\r\n}\r\nfunction clearSnapshot(node) {\r\n    node.clearSnapshot();\r\n}\r\nfunction clearMeasurements(node) {\r\n    node.clearMeasurements();\r\n}\r\nfunction clearIsLayoutDirty(node) {\r\n    node.isLayoutDirty = false;\r\n}\r\nfunction resetTransformStyle(node) {\r\n    const { visualElement } = node.options;\r\n    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {\r\n        visualElement.notify(\"BeforeLayoutMeasure\");\r\n    }\r\n    node.resetTransform();\r\n}\r\nfunction finishAnimation(node) {\r\n    node.finishAnimation();\r\n    node.targetDelta = node.relativeTarget = node.target = undefined;\r\n    node.isProjectionDirty = true;\r\n}\r\nfunction resolveTargetDelta(node) {\r\n    node.resolveTargetDelta();\r\n}\r\nfunction calcProjection(node) {\r\n    node.calcProjection();\r\n}\r\nfunction resetSkewAndRotation(node) {\r\n    node.resetSkewAndRotation();\r\n}\r\nfunction removeLeadSnapshots(stack) {\r\n    stack.removeLeadSnapshot();\r\n}\r\nfunction mixAxisDelta(output, delta, p) {\r\n    output.translate = mixNumber(delta.translate, 0, p);\r\n    output.scale = mixNumber(delta.scale, 1, p);\r\n    output.origin = delta.origin;\r\n    output.originPoint = delta.originPoint;\r\n}\r\nfunction mixAxis(output, from, to, p) {\r\n    output.min = mixNumber(from.min, to.min, p);\r\n    output.max = mixNumber(from.max, to.max, p);\r\n}\r\nfunction mixBox(output, from, to, p) {\r\n    mixAxis(output.x, from.x, to.x, p);\r\n    mixAxis(output.y, from.y, to.y, p);\r\n}\r\nfunction hasOpacityCrossfade(node) {\r\n    return (node.animationValues && node.animationValues.opacityExit !== undefined);\r\n}\r\nconst defaultLayoutTransition = {\r\n    duration: 0.45,\r\n    ease: [0.4, 0, 0.1, 1],\r\n};\r\nconst userAgentContains = (string) => typeof navigator !== \"undefined\" &&\r\n    navigator.userAgent &&\r\n    navigator.userAgent.toLowerCase().includes(string);\r\n/**\r\n * Measured bounding boxes must be rounded in Safari and\r\n * left untouched in Chrome, otherwise non-integer layouts within scaled-up elements\r\n * can appear to jump.\r\n */\r\nconst roundPoint = userAgentContains(\"applewebkit/\") && !userAgentContains(\"chrome/\")\r\n    ? Math.round\r\n    : noop;\r\nfunction roundAxis(axis) {\r\n    // Round to the nearest .5 pixels to support subpixel layouts\r\n    axis.min = roundPoint(axis.min);\r\n    axis.max = roundPoint(axis.max);\r\n}\r\nfunction roundBox(box) {\r\n    roundAxis(box.x);\r\n    roundAxis(box.y);\r\n}\r\nfunction shouldAnimatePositionOnly(animationType, snapshot, layout) {\r\n    return (animationType === \"position\" ||\r\n        (animationType === \"preserve-aspect\" &&\r\n            !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2)));\r\n}\r\nfunction checkNodeWasScrollRoot(node) {\r\n    var _a;\r\n    return node !== node.root && ((_a = node.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot);\r\n}\r\n\r\nexport { cleanDirtyNodes, createProjectionNode, mixAxis, mixAxisDelta, mixBox, propagateDirtyNodes };\r\n","function isSVGElement(element) {\r\n    return element instanceof SVGElement && element.tagName !== \"svg\";\r\n}\r\n\r\nexport { isSVGElement };\r\n","function buildProjectionTransform(delta, treeScale, latestTransform) {\r\n    let transform = \"\";\r\n    /**\r\n     * The translations we use to calculate are always relative to the viewport coordinate space.\r\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\r\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\r\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\r\n     */\r\n    const xTranslate = delta.x.translate / treeScale.x;\r\n    const yTranslate = delta.y.translate / treeScale.y;\r\n    const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;\r\n    if (xTranslate || yTranslate || zTranslate) {\r\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\r\n    }\r\n    /**\r\n     * Apply scale correction for the tree transform.\r\n     * This will apply scale to the screen-orientated axes.\r\n     */\r\n    if (treeScale.x !== 1 || treeScale.y !== 1) {\r\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\r\n    }\r\n    if (latestTransform) {\r\n        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;\r\n        if (transformPerspective)\r\n            transform = `perspective(${transformPerspective}px) ${transform}`;\r\n        if (rotate)\r\n            transform += `rotate(${rotate}deg) `;\r\n        if (rotateX)\r\n            transform += `rotateX(${rotateX}deg) `;\r\n        if (rotateY)\r\n            transform += `rotateY(${rotateY}deg) `;\r\n        if (skewX)\r\n            transform += `skewX(${skewX}deg) `;\r\n        if (skewY)\r\n            transform += `skewY(${skewY}deg) `;\r\n    }\r\n    /**\r\n     * Apply scale to match the size of the element to the size we want it.\r\n     * This will apply scale to the element-orientated axes.\r\n     */\r\n    const elementScaleX = delta.x.scale * treeScale.x;\r\n    const elementScaleY = delta.y.scale * treeScale.y;\r\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\r\n        transform += `scale(${elementScaleX}, ${elementScaleY})`;\r\n    }\r\n    return transform || \"none\";\r\n}\r\n\r\nexport { buildProjectionTransform };\r\n","import { createProjectionNode } from './create-projection-node.mjs';\r\nimport { addDomEvent } from '../../events/add-dom-event.mjs';\r\n\r\nconst DocumentProjectionNode = createProjectionNode({\r\n    attachResizeListener: (ref, notify) => addDomEvent(ref, \"resize\", notify),\r\n    measureScroll: () => ({\r\n        x: document.documentElement.scrollLeft || document.body.scrollLeft,\r\n        y: document.documentElement.scrollTop || document.body.scrollTop,\r\n    }),\r\n    checkIsScrollRoot: () => true,\r\n});\r\n\r\nexport { DocumentProjectionNode };\r\n","import { createProjectionNode } from './create-projection-node.mjs';\r\nimport { DocumentProjectionNode } from './DocumentProjectionNode.mjs';\r\n\r\nconst rootProjectionNode = {\r\n    current: undefined,\r\n};\r\nconst HTMLProjectionNode = createProjectionNode({\r\n    measureScroll: (instance) => ({\r\n        x: instance.scrollLeft,\r\n        y: instance.scrollTop,\r\n    }),\r\n    defaultParent: () => {\r\n        if (!rootProjectionNode.current) {\r\n            const documentNode = new DocumentProjectionNode({});\r\n            documentNode.mount(window);\r\n            documentNode.setOptions({ layoutScroll: true });\r\n            rootProjectionNode.current = documentNode;\r\n        }\r\n        return rootProjectionNode.current;\r\n    },\r\n    resetTransform: (instance, value) => {\r\n        instance.style.transform = value !== undefined ? value : \"none\";\r\n    },\r\n    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === \"fixed\"),\r\n});\r\n\r\nexport { HTMLProjectionNode, rootProjectionNode };\r\n","/**\r\n * This should only ever be modified on the client otherwise it'll\r\n * persist through server requests. If we need instanced states we\r\n * could lazy-init via root.\r\n */\r\nconst globalProjectionState = {\r\n    /**\r\n     * Global flag as to whether the tree has animated since the last time\r\n     * we resized the window\r\n     */\r\n    hasAnimatedSinceResize: true,\r\n    /**\r\n     * We set this to true once, on the first update. Any nodes added to the tree beyond that\r\n     * update will be given a `data-projection-id` attribute.\r\n     */\r\n    hasEverUpdated: false,\r\n};\r\n\r\nexport { globalProjectionState };\r\n","import { px } from '../../value/types/numbers/units.mjs';\r\n\r\nfunction pixelsToPercent(pixels, axis) {\r\n    if (axis.max === axis.min)\r\n        return 0;\r\n    return (pixels / (axis.max - axis.min)) * 100;\r\n}\r\n/**\r\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\r\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\r\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\r\n * borderRadius in both states. If we animate between the two in pixels that will trigger\r\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\r\n */\r\nconst correctBorderRadius = {\r\n    correct: (latest, node) => {\r\n        if (!node.target)\r\n            return latest;\r\n        /**\r\n         * If latest is a string, if it's a percentage we can return immediately as it's\r\n         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\r\n         */\r\n        if (typeof latest === \"string\") {\r\n            if (px.test(latest)) {\r\n                latest = parseFloat(latest);\r\n            }\r\n            else {\r\n                return latest;\r\n            }\r\n        }\r\n        /**\r\n         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\r\n         * pixel value as a percentage of each axis\r\n         */\r\n        const x = pixelsToPercent(latest, node.target.x);\r\n        const y = pixelsToPercent(latest, node.target.y);\r\n        return `${x}% ${y}%`;\r\n    },\r\n};\r\n\r\nexport { correctBorderRadius, pixelsToPercent };\r\n","import { mixNumber } from '../../utils/mix/number.mjs';\r\nimport { complex } from '../../value/types/complex/index.mjs';\r\n\r\nconst correctBoxShadow = {\r\n    correct: (latest, { treeScale, projectionDelta }) => {\r\n        const original = latest;\r\n        const shadow = complex.parse(latest);\r\n        // TODO: Doesn't support multiple shadows\r\n        if (shadow.length > 5)\r\n            return original;\r\n        const template = complex.createTransformer(latest);\r\n        const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\r\n        // Calculate the overall context scale\r\n        const xScale = projectionDelta.x.scale * treeScale.x;\r\n        const yScale = projectionDelta.y.scale * treeScale.y;\r\n        shadow[0 + offset] /= xScale;\r\n        shadow[1 + offset] /= yScale;\r\n        /**\r\n         * Ideally we'd correct x and y scales individually, but because blur and\r\n         * spread apply to both we have to take a scale average and apply that instead.\r\n         * We could potentially improve the outcome of this by incorporating the ratio between\r\n         * the two scales.\r\n         */\r\n        const averageScale = mixNumber(xScale, yScale, 0.5);\r\n        // Blur\r\n        if (typeof shadow[2 + offset] === \"number\")\r\n            shadow[2 + offset] /= averageScale;\r\n        // Spread\r\n        if (typeof shadow[3 + offset] === \"number\")\r\n            shadow[3 + offset] /= averageScale;\r\n        return template(shadow);\r\n    },\r\n};\r\n\r\nexport { correctBoxShadow };\r\n","const scaleCorrectors = {};\r\nfunction addScaleCorrector(correctors) {\r\n    Object.assign(scaleCorrectors, correctors);\r\n}\r\n\r\nexport { addScaleCorrector, scaleCorrectors };\r\n","function eachAxis(callback) {\r\n    return [callback(\"x\"), callback(\"y\")];\r\n}\r\n\r\nexport { eachAxis };\r\n","function isIdentityScale(scale) {\r\n    return scale === undefined || scale === 1;\r\n}\r\nfunction hasScale({ scale, scaleX, scaleY }) {\r\n    return (!isIdentityScale(scale) ||\r\n        !isIdentityScale(scaleX) ||\r\n        !isIdentityScale(scaleY));\r\n}\r\nfunction hasTransform(values) {\r\n    return (hasScale(values) ||\r\n        has2DTranslate(values) ||\r\n        values.z ||\r\n        values.rotate ||\r\n        values.rotateX ||\r\n        values.rotateY ||\r\n        values.skewX ||\r\n        values.skewY);\r\n}\r\nfunction has2DTranslate(values) {\r\n    return is2DTranslate(values.x) || is2DTranslate(values.y);\r\n}\r\nfunction is2DTranslate(value) {\r\n    return value && value !== \"0%\";\r\n}\r\n\r\nexport { has2DTranslate, hasScale, hasTransform };\r\n","import { convertBoundingBoxToBox, transformBoxPoints } from '../geometry/conversion.mjs';\r\nimport { translateAxis } from '../geometry/delta-apply.mjs';\r\n\r\nfunction measureViewportBox(instance, transformPoint) {\r\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\r\n}\r\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\r\n    const viewportBox = measureViewportBox(element, transformPagePoint);\r\n    const { scroll } = rootProjectionNode;\r\n    if (scroll) {\r\n        translateAxis(viewportBox.x, scroll.offset.x);\r\n        translateAxis(viewportBox.y, scroll.offset.y);\r\n    }\r\n    return viewportBox;\r\n}\r\n\r\nexport { measurePageBox, measureViewportBox };\r\n","import { warnOnce } from '../../utils/warn-once.mjs';\r\n\r\nfunction createDOMMotionComponentProxy(componentFactory) {\r\n    if (typeof Proxy === \"undefined\") {\r\n        return componentFactory;\r\n    }\r\n    /**\r\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\r\n     * Rather than generating them anew every render.\r\n     */\r\n    const componentCache = new Map();\r\n    const deprecatedFactoryFunction = (...args) => {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            warnOnce(false, \"motion() is deprecated. Use motion.create() instead.\");\r\n        }\r\n        return componentFactory(...args);\r\n    };\r\n    return new Proxy(deprecatedFactoryFunction, {\r\n        /**\r\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\r\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\r\n         * DOM component with that name.\r\n         */\r\n        get: (_target, key) => {\r\n            if (key === \"create\")\r\n                return componentFactory;\r\n            /**\r\n             * If this element doesn't exist in the component cache, create it and cache.\r\n             */\r\n            if (!componentCache.has(key)) {\r\n                componentCache.set(key, componentFactory(key));\r\n            }\r\n            return componentCache.get(key);\r\n        },\r\n    });\r\n}\r\n\r\nexport { createDOMMotionComponentProxy };\r\n","/**\r\n * We keep these listed separately as we use the lowercase tag names as part\r\n * of the runtime bundle to detect SVG components\r\n */\r\nconst lowercaseSVGElements = [\r\n    \"animate\",\r\n    \"circle\",\r\n    \"defs\",\r\n    \"desc\",\r\n    \"ellipse\",\r\n    \"g\",\r\n    \"image\",\r\n    \"line\",\r\n    \"filter\",\r\n    \"marker\",\r\n    \"mask\",\r\n    \"metadata\",\r\n    \"path\",\r\n    \"pattern\",\r\n    \"polygon\",\r\n    \"polyline\",\r\n    \"rect\",\r\n    \"stop\",\r\n    \"switch\",\r\n    \"symbol\",\r\n    \"svg\",\r\n    \"text\",\r\n    \"tspan\",\r\n    \"use\",\r\n    \"view\",\r\n];\r\n\r\nexport { lowercaseSVGElements };\r\n","import { lowercaseSVGElements } from '../../svg/lowercase-elements.mjs';\r\n\r\nfunction isSVGComponent(Component) {\r\n    if (\r\n    /**\r\n     * If it's not a string, it's a custom React component. Currently we only support\r\n     * HTML custom React components.\r\n     */\r\n    typeof Component !== \"string\" ||\r\n        /**\r\n         * If it contains a dash, the element is a custom HTML webcomponent.\r\n         */\r\n        Component.includes(\"-\")) {\r\n        return false;\r\n    }\r\n    else if (\r\n    /**\r\n     * If it's in our list of lowercase SVG tags, it's an SVG component\r\n     */\r\n    lowercaseSVGElements.indexOf(Component) > -1 ||\r\n        /**\r\n         * If it contains a capital letter, it's an SVG component\r\n         */\r\n        /[A-Z]/u.test(Component)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport { isSVGComponent };\r\n","/**\r\n * Provided a value and a ValueType, returns the value as that value type.\r\n */\r\nconst getValueAsType = (value, type) => {\r\n    return type && typeof value === \"number\"\r\n        ? type.transform(value)\r\n        : value;\r\n};\r\n\r\nexport { getValueAsType };\r\n","import { getValueAsType } from '../../dom/value-types/get-as-type.mjs';\r\nimport { numberValueTypes } from '../../dom/value-types/number.mjs';\r\nimport { transformPropOrder } from './keys-transform.mjs';\r\n\r\nconst translateAlias = {\r\n    x: \"translateX\",\r\n    y: \"translateY\",\r\n    z: \"translateZ\",\r\n    transformPerspective: \"perspective\",\r\n};\r\nconst numTransforms = transformPropOrder.length;\r\n/**\r\n * Build a CSS transform style from individual x/y/scale etc properties.\r\n *\r\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\r\n * providing a transformTemplate function.\r\n */\r\nfunction buildTransform(latestValues, transform, transformTemplate) {\r\n    // The transform string we're going to build into.\r\n    let transformString = \"\";\r\n    let transformIsDefault = true;\r\n    /**\r\n     * Loop over all possible transforms in order, adding the ones that\r\n     * are present to the transform string.\r\n     */\r\n    for (let i = 0; i < numTransforms; i++) {\r\n        const key = transformPropOrder[i];\r\n        const value = latestValues[key];\r\n        if (value === undefined)\r\n            continue;\r\n        let valueIsDefault = true;\r\n        if (typeof value === \"number\") {\r\n            valueIsDefault = value === (key.startsWith(\"scale\") ? 1 : 0);\r\n        }\r\n        else {\r\n            valueIsDefault = parseFloat(value) === 0;\r\n        }\r\n        if (!valueIsDefault || transformTemplate) {\r\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\r\n            if (!valueIsDefault) {\r\n                transformIsDefault = false;\r\n                const transformName = translateAlias[key] || key;\r\n                transformString += `${transformName}(${valueAsType}) `;\r\n            }\r\n            if (transformTemplate) {\r\n                transform[key] = valueAsType;\r\n            }\r\n        }\r\n    }\r\n    transformString = transformString.trim();\r\n    // If we have a custom `transform` template, pass our transform values and\r\n    // generated transformString to that before returning\r\n    if (transformTemplate) {\r\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\r\n    }\r\n    else if (transformIsDefault) {\r\n        transformString = \"none\";\r\n    }\r\n    return transformString;\r\n}\r\n\r\nexport { buildTransform };\r\n","import { isCSSVariableName } from '../../dom/utils/is-css-variable.mjs';\r\nimport { getValueAsType } from '../../dom/value-types/get-as-type.mjs';\r\nimport { numberValueTypes } from '../../dom/value-types/number.mjs';\r\nimport { buildTransform } from './build-transform.mjs';\r\nimport { transformProps } from './keys-transform.mjs';\r\n\r\nfunction buildHTMLStyles(state, latestValues, transformTemplate) {\r\n    const { style, vars, transformOrigin } = state;\r\n    // Track whether we encounter any transform or transformOrigin values.\r\n    let hasTransform = false;\r\n    let hasTransformOrigin = false;\r\n    /**\r\n     * Loop over all our latest animated values and decide whether to handle them\r\n     * as a style or CSS variable.\r\n     *\r\n     * Transforms and transform origins are kept separately for further processing.\r\n     */\r\n    for (const key in latestValues) {\r\n        const value = latestValues[key];\r\n        if (transformProps.has(key)) {\r\n            // If this is a transform, flag to enable further transform processing\r\n            hasTransform = true;\r\n            continue;\r\n        }\r\n        else if (isCSSVariableName(key)) {\r\n            vars[key] = value;\r\n            continue;\r\n        }\r\n        else {\r\n            // Convert the value to its default value type, ie 0 -> \"0px\"\r\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\r\n            if (key.startsWith(\"origin\")) {\r\n                // If this is a transform origin, flag and enable further transform-origin processing\r\n                hasTransformOrigin = true;\r\n                transformOrigin[key] =\r\n                    valueAsType;\r\n            }\r\n            else {\r\n                style[key] = valueAsType;\r\n            }\r\n        }\r\n    }\r\n    if (!latestValues.transform) {\r\n        if (hasTransform || transformTemplate) {\r\n            style.transform = buildTransform(latestValues, state.transform, transformTemplate);\r\n        }\r\n        else if (style.transform) {\r\n            /**\r\n             * If we have previously created a transform but currently don't have any,\r\n             * reset transform style to none.\r\n             */\r\n            style.transform = \"none\";\r\n        }\r\n    }\r\n    /**\r\n     * Build a transformOrigin style. Uses the same defaults as the browser for\r\n     * undefined origins.\r\n     */\r\n    if (hasTransformOrigin) {\r\n        const { originX = \"50%\", originY = \"50%\", originZ = 0, } = transformOrigin;\r\n        style.transformOrigin = `${originX} ${originY} ${originZ}`;\r\n    }\r\n}\r\n\r\nexport { buildHTMLStyles };\r\n","import { px } from '../../../value/types/numbers/units.mjs';\r\n\r\nconst dashKeys = {\r\n    offset: \"stroke-dashoffset\",\r\n    array: \"stroke-dasharray\",\r\n};\r\nconst camelKeys = {\r\n    offset: \"strokeDashoffset\",\r\n    array: \"strokeDasharray\",\r\n};\r\n/**\r\n * Build SVG path properties. Uses the path's measured length to convert\r\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\r\n * and stroke-dasharray attributes.\r\n *\r\n * This function is mutative to reduce per-frame GC.\r\n */\r\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\r\n    // Normalise path length by setting SVG attribute pathLength to 1\r\n    attrs.pathLength = 1;\r\n    // We use dash case when setting attributes directly to the DOM node and camel case\r\n    // when defining props on a React component.\r\n    const keys = useDashCase ? dashKeys : camelKeys;\r\n    // Build the dash offset\r\n    attrs[keys.offset] = px.transform(-offset);\r\n    // Build the dash array\r\n    const pathLength = px.transform(length);\r\n    const pathSpacing = px.transform(spacing);\r\n    attrs[keys.array] = `${pathLength} ${pathSpacing}`;\r\n}\r\n\r\nexport { buildSVGPath };\r\n","import { px } from '../../../value/types/numbers/units.mjs';\r\n\r\nfunction calcOrigin(origin, offset, size) {\r\n    return typeof origin === \"string\"\r\n        ? origin\r\n        : px.transform(offset + size * origin);\r\n}\r\n/**\r\n * The SVG transform origin defaults are different to CSS and is less intuitive,\r\n * so we use the measured dimensions of the SVG to reconcile these.\r\n */\r\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\r\n    const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\r\n    const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\r\n    return `${pxOriginX} ${pxOriginY}`;\r\n}\r\n\r\nexport { calcSVGTransformOrigin };\r\n","import { buildHTMLStyles } from '../../html/utils/build-styles.mjs';\r\nimport { buildSVGPath } from './path.mjs';\r\nimport { calcSVGTransformOrigin } from './transform-origin.mjs';\r\n\r\n/**\r\n * Build SVG visual attrbutes, like cx and style.transform\r\n */\r\nfunction buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, \r\n// This is object creation, which we try to avoid per-frame.\r\n...latest }, isSVGTag, transformTemplate) {\r\n    buildHTMLStyles(state, latest, transformTemplate);\r\n    /**\r\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\r\n     * as normal HTML tags.\r\n     */\r\n    if (isSVGTag) {\r\n        if (state.style.viewBox) {\r\n            state.attrs.viewBox = state.style.viewBox;\r\n        }\r\n        return;\r\n    }\r\n    state.attrs = state.style;\r\n    state.style = {};\r\n    const { attrs, style, dimensions } = state;\r\n    /**\r\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\r\n     * and copy it into style.\r\n     */\r\n    if (attrs.transform) {\r\n        if (dimensions)\r\n            style.transform = attrs.transform;\r\n        delete attrs.transform;\r\n    }\r\n    // Parse transformOrigin\r\n    if (dimensions &&\r\n        (originX !== undefined || originY !== undefined || style.transform)) {\r\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\r\n    }\r\n    // Render attrX/attrY/attrScale as attributes\r\n    if (attrX !== undefined)\r\n        attrs.x = attrX;\r\n    if (attrY !== undefined)\r\n        attrs.y = attrY;\r\n    if (attrScale !== undefined)\r\n        attrs.scale = attrScale;\r\n    // Build SVG path if one has been defined\r\n    if (pathLength !== undefined) {\r\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\r\n    }\r\n}\r\n\r\nexport { buildSVGAttrs };\r\n","const createHtmlRenderState = () => ({\r\n    style: {},\r\n    transform: {},\r\n    transformOrigin: {},\r\n    vars: {},\r\n});\r\n\r\nexport { createHtmlRenderState };\r\n","import { createHtmlRenderState } from '../../html/utils/create-render-state.mjs';\r\n\r\nconst createSvgRenderState = () => ({\r\n    ...createHtmlRenderState(),\r\n    attrs: {},\r\n});\r\n\r\nexport { createSvgRenderState };\r\n","const isSVGTag = (tag) => typeof tag === \"string\" && tag.toLowerCase() === \"svg\";\r\n\r\nexport { isSVGTag };\r\n","function renderHTML(element, { style, vars }, styleProp, projection) {\r\n    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\r\n    // Loop over any CSS variables and assign those.\r\n    for (const key in vars) {\r\n        element.style.setProperty(key, vars[key]);\r\n    }\r\n}\r\n\r\nexport { renderHTML };\r\n","/**\r\n * A set of attribute names that are always read/written as camel case.\r\n */\r\nconst camelCaseAttributes = new Set([\r\n    \"baseFrequency\",\r\n    \"diffuseConstant\",\r\n    \"kernelMatrix\",\r\n    \"kernelUnitLength\",\r\n    \"keySplines\",\r\n    \"keyTimes\",\r\n    \"limitingConeAngle\",\r\n    \"markerHeight\",\r\n    \"markerWidth\",\r\n    \"numOctaves\",\r\n    \"targetX\",\r\n    \"targetY\",\r\n    \"surfaceScale\",\r\n    \"specularConstant\",\r\n    \"specularExponent\",\r\n    \"stdDeviation\",\r\n    \"tableValues\",\r\n    \"viewBox\",\r\n    \"gradientTransform\",\r\n    \"pathLength\",\r\n    \"startOffset\",\r\n    \"textLength\",\r\n    \"lengthAdjust\",\r\n]);\r\n\r\nexport { camelCaseAttributes };\r\n","import { camelToDash } from '../../dom/utils/camel-to-dash.mjs';\r\nimport { renderHTML } from '../../html/utils/render.mjs';\r\nimport { camelCaseAttributes } from './camel-case-attrs.mjs';\r\n\r\nfunction renderSVG(element, renderState, _styleProp, projection) {\r\n    renderHTML(element, renderState, undefined, projection);\r\n    for (const key in renderState.attrs) {\r\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\r\n    }\r\n}\r\n\r\nexport { renderSVG };\r\n","import { isForcedMotionValue } from '../../../motion/utils/is-forced-motion-value.mjs';\r\nimport { isMotionValue } from '../../../value/utils/is-motion-value.mjs';\r\n\r\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\r\n    var _a;\r\n    const { style } = props;\r\n    const newValues = {};\r\n    for (const key in style) {\r\n        if (isMotionValue(style[key]) ||\r\n            (prevProps.style &&\r\n                isMotionValue(prevProps.style[key])) ||\r\n            isForcedMotionValue(key, props) ||\r\n            ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== undefined) {\r\n            newValues[key] = style[key];\r\n        }\r\n    }\r\n    return newValues;\r\n}\r\n\r\nexport { scrapeMotionValuesFromProps };\r\n","import { isMotionValue } from '../../../value/utils/is-motion-value.mjs';\r\nimport { transformPropOrder } from '../../html/utils/keys-transform.mjs';\r\nimport { scrapeMotionValuesFromProps as scrapeMotionValuesFromProps$1 } from '../../html/utils/scrape-motion-values.mjs';\r\n\r\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\r\n    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);\r\n    for (const key in props) {\r\n        if (isMotionValue(props[key]) ||\r\n            isMotionValue(prevProps[key])) {\r\n            const targetKey = transformPropOrder.indexOf(key) !== -1\r\n                ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1)\r\n                : key;\r\n            newValues[targetKey] = props[key];\r\n        }\r\n    }\r\n    return newValues;\r\n}\r\n\r\nexport { scrapeMotionValuesFromProps };\r\n","import { frame } from '../../frameloop/frame.mjs';\r\nimport { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';\r\nimport { transformProps } from '../html/utils/keys-transform.mjs';\r\nimport { buildSVGAttrs } from './utils/build-attrs.mjs';\r\nimport { createSvgRenderState } from './utils/create-render-state.mjs';\r\nimport { isSVGTag } from './utils/is-svg-tag.mjs';\r\nimport { renderSVG } from './utils/render.mjs';\r\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\r\n\r\nfunction updateSVGDimensions(instance, renderState) {\r\n    try {\r\n        renderState.dimensions =\r\n            typeof instance.getBBox === \"function\"\r\n                ? instance.getBBox()\r\n                : instance.getBoundingClientRect();\r\n    }\r\n    catch (e) {\r\n        // Most likely trying to measure an unrendered element under Firefox\r\n        renderState.dimensions = {\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0,\r\n        };\r\n    }\r\n}\r\nconst layoutProps = [\"x\", \"y\", \"width\", \"height\", \"cx\", \"cy\", \"r\"];\r\nconst svgMotionConfig = {\r\n    useVisualState: makeUseVisualState({\r\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\r\n        createRenderState: createSvgRenderState,\r\n        onUpdate: ({ props, prevProps, current, renderState, latestValues, }) => {\r\n            if (!current)\r\n                return;\r\n            let hasTransform = !!props.drag;\r\n            if (!hasTransform) {\r\n                for (const key in latestValues) {\r\n                    if (transformProps.has(key)) {\r\n                        hasTransform = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!hasTransform)\r\n                return;\r\n            let needsMeasure = !prevProps;\r\n            if (prevProps) {\r\n                /**\r\n                 * Check the layout props for changes, if any are found we need to\r\n                 * measure the element again.\r\n                 */\r\n                for (let i = 0; i < layoutProps.length; i++) {\r\n                    const key = layoutProps[i];\r\n                    if (props[key] !==\r\n                        prevProps[key]) {\r\n                        needsMeasure = true;\r\n                    }\r\n                }\r\n            }\r\n            if (!needsMeasure)\r\n                return;\r\n            frame.read(() => {\r\n                updateSVGDimensions(current, renderState);\r\n                frame.render(() => {\r\n                    buildSVGAttrs(renderState, latestValues, isSVGTag(current.tagName), props.transformTemplate);\r\n                    renderSVG(current, renderState);\r\n                });\r\n            });\r\n        },\r\n    }),\r\n};\r\n\r\nexport { svgMotionConfig };\r\n","import { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';\r\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\r\nimport { createHtmlRenderState } from './utils/create-render-state.mjs';\r\n\r\nconst htmlMotionConfig = {\r\n    useVisualState: makeUseVisualState({\r\n        scrapeMotionValuesFromProps,\r\n        createRenderState: createHtmlRenderState,\r\n    }),\r\n};\r\n\r\nexport { htmlMotionConfig };\r\n","import { useMemo } from 'react';\r\nimport { isForcedMotionValue } from '../../motion/utils/is-forced-motion-value.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\r\nimport { createHtmlRenderState } from './utils/create-render-state.mjs';\r\n\r\nfunction copyRawValuesOnly(target, source, props) {\r\n    for (const key in source) {\r\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\r\n            target[key] = source[key];\r\n        }\r\n    }\r\n}\r\nfunction useInitialMotionValues({ transformTemplate }, visualState) {\r\n    return useMemo(() => {\r\n        const state = createHtmlRenderState();\r\n        buildHTMLStyles(state, visualState, transformTemplate);\r\n        return Object.assign({}, state.vars, state.style);\r\n    }, [visualState]);\r\n}\r\nfunction useStyle(props, visualState) {\r\n    const styleProp = props.style || {};\r\n    const style = {};\r\n    /**\r\n     * Copy non-Motion Values straight into style\r\n     */\r\n    copyRawValuesOnly(style, styleProp, props);\r\n    Object.assign(style, useInitialMotionValues(props, visualState));\r\n    return style;\r\n}\r\nfunction useHTMLProps(props, visualState) {\r\n    // The `any` isn't ideal but it is the type of createElement props argument\r\n    const htmlProps = {};\r\n    const style = useStyle(props, visualState);\r\n    if (props.drag && props.dragListener !== false) {\r\n        // Disable the ghost element when a user drags\r\n        htmlProps.draggable = false;\r\n        // Disable text selection\r\n        style.userSelect =\r\n            style.WebkitUserSelect =\r\n                style.WebkitTouchCallout =\r\n                    \"none\";\r\n        // Disable scrolling on the draggable direction\r\n        style.touchAction =\r\n            props.drag === true\r\n                ? \"none\"\r\n                : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`;\r\n    }\r\n    if (props.tabIndex === undefined &&\r\n        (props.onTap || props.onTapStart || props.whileTap)) {\r\n        htmlProps.tabIndex = 0;\r\n    }\r\n    htmlProps.style = style;\r\n    return htmlProps;\r\n}\r\n\r\nexport { copyRawValuesOnly, useHTMLProps };\r\n","import { isValidMotionProp } from '../../../motion/utils/valid-prop.mjs';\r\n\r\nlet shouldForward = (key) => !isValidMotionProp(key);\r\nfunction loadExternalIsValidProp(isValidProp) {\r\n    if (!isValidProp)\r\n        return;\r\n    // Explicitly filter our events\r\n    shouldForward = (key) => key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\r\n}\r\n/**\r\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\r\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\r\n * of these should be passed to the underlying DOM node.\r\n *\r\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\r\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\r\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\r\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\r\n *\r\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\r\n * actually required.\r\n */\r\ntry {\r\n    /**\r\n     * We attempt to import this package but require won't be defined in esm environments, in that case\r\n     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed\r\n     * in favour of explicit injection.\r\n     */\r\n    loadExternalIsValidProp(require(\"@emotion/is-prop-valid\").default);\r\n}\r\ncatch (_a) {\r\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\r\n}\r\nfunction filterProps(props, isDom, forwardMotionProps) {\r\n    const filteredProps = {};\r\n    for (const key in props) {\r\n        /**\r\n         * values is considered a valid prop by Emotion, so if it's present\r\n         * this will be rendered out to the DOM unless explicitly filtered.\r\n         *\r\n         * We check the type as it could be used with the `feColorMatrix`\r\n         * element, which we support.\r\n         */\r\n        if (key === \"values\" && typeof props.values === \"object\")\r\n            continue;\r\n        if (shouldForward(key) ||\r\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\r\n            (!isDom && !isValidMotionProp(key)) ||\r\n            // If trying to use native HTML drag events, forward drag listeners\r\n            (props[\"draggable\"] &&\r\n                key.startsWith(\"onDrag\"))) {\r\n            filteredProps[key] =\r\n                props[key];\r\n        }\r\n    }\r\n    return filteredProps;\r\n}\r\n\r\nexport { filterProps, loadExternalIsValidProp };\r\n","import { useMemo } from 'react';\r\nimport { copyRawValuesOnly } from '../html/use-props.mjs';\r\nimport { buildSVGAttrs } from './utils/build-attrs.mjs';\r\nimport { createSvgRenderState } from './utils/create-render-state.mjs';\r\nimport { isSVGTag } from './utils/is-svg-tag.mjs';\r\n\r\nfunction useSVGProps(props, visualState, _isStatic, Component) {\r\n    const visualProps = useMemo(() => {\r\n        const state = createSvgRenderState();\r\n        buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);\r\n        return {\r\n            ...state.attrs,\r\n            style: { ...state.style },\r\n        };\r\n    }, [visualState]);\r\n    if (props.style) {\r\n        const rawStyles = {};\r\n        copyRawValuesOnly(rawStyles, props.style, props);\r\n        visualProps.style = { ...rawStyles, ...visualProps.style };\r\n    }\r\n    return visualProps;\r\n}\r\n\r\nexport { useSVGProps };\r\n","import { Fragment, useMemo, createElement } from 'react';\r\nimport { useHTMLProps } from '../html/use-props.mjs';\r\nimport { filterProps } from './utils/filter-props.mjs';\r\nimport { isSVGComponent } from './utils/is-svg-component.mjs';\r\nimport { useSVGProps } from '../svg/use-props.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\n\r\nfunction createUseRender(forwardMotionProps = false) {\r\n    const useRender = (Component, props, ref, { latestValues }, isStatic) => {\r\n        const useVisualProps = isSVGComponent(Component)\r\n            ? useSVGProps\r\n            : useHTMLProps;\r\n        const visualProps = useVisualProps(props, latestValues, isStatic, Component);\r\n        const filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\r\n        const elementProps = Component !== Fragment\r\n            ? { ...filteredProps, ...visualProps, ref }\r\n            : {};\r\n        /**\r\n         * If component has been handed a motion value as its child,\r\n         * memoise its initial value and render that. Subsequent updates\r\n         * will be handled by the onChange handler\r\n         */\r\n        const { children } = props;\r\n        const renderedChildren = useMemo(() => (isMotionValue(children) ? children.get() : children), [children]);\r\n        return createElement(Component, {\r\n            ...elementProps,\r\n            children: renderedChildren,\r\n        });\r\n    };\r\n    return useRender;\r\n}\r\n\r\nexport { createUseRender };\r\n","import { createRendererMotionComponent } from '../../motion/index.mjs';\r\nimport { isSVGComponent } from '../dom/utils/is-svg-component.mjs';\r\nimport { svgMotionConfig } from '../svg/config-motion.mjs';\r\nimport { htmlMotionConfig } from '../html/config-motion.mjs';\r\nimport { createUseRender } from '../dom/use-render.mjs';\r\n\r\nfunction createMotionComponentFactory(preloadedFeatures, createVisualElement) {\r\n    return function createMotionComponent(Component, { forwardMotionProps } = { forwardMotionProps: false }) {\r\n        const baseConfig = isSVGComponent(Component)\r\n            ? svgMotionConfig\r\n            : htmlMotionConfig;\r\n        const config = {\r\n            ...baseConfig,\r\n            preloadedFeatures,\r\n            useRender: createUseRender(forwardMotionProps),\r\n            createVisualElement,\r\n            Component,\r\n        };\r\n        return createRendererMotionComponent(config);\r\n    };\r\n}\r\n\r\nexport { createMotionComponentFactory };\r\n","// Does this device prefer reduced motion? Returns `null` server-side.\r\nconst prefersReducedMotion = { current: null };\r\nconst hasReducedMotionListener = { current: false };\r\n\r\nexport { hasReducedMotionListener, prefersReducedMotion };\r\n","import { color } from '../../../value/types/color/index.mjs';\r\nimport { complex } from '../../../value/types/complex/index.mjs';\r\nimport { dimensionValueTypes } from './dimensions.mjs';\r\nimport { testValueType } from './test.mjs';\r\n\r\n/**\r\n * A list of all ValueTypes\r\n */\r\nconst valueTypes = [...dimensionValueTypes, color, complex];\r\n/**\r\n * Tests a value against the list of ValueTypes\r\n */\r\nconst findValueType = (v) => valueTypes.find(testValueType(v));\r\n\r\nexport { findValueType };\r\n","const visualElementStore = new WeakMap();\r\n\r\nexport { visualElementStore };\r\n","import { time } from '../frameloop/sync-time.mjs';\r\nimport { featureDefinitions } from '../motion/features/definitions.mjs';\r\nimport { createBox } from '../projection/geometry/models.mjs';\r\nimport { isNumericalString } from '../utils/is-numerical-string.mjs';\r\nimport { isZeroValueString } from '../utils/is-zero-value-string.mjs';\r\nimport { initPrefersReducedMotion } from '../utils/reduced-motion/index.mjs';\r\nimport { hasReducedMotionListener, prefersReducedMotion } from '../utils/reduced-motion/state.mjs';\r\nimport { SubscriptionManager } from '../utils/subscription-manager.mjs';\r\nimport { warnOnce } from '../utils/warn-once.mjs';\r\nimport { motionValue } from '../value/index.mjs';\r\nimport { complex } from '../value/types/complex/index.mjs';\r\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\r\nimport { getAnimatableNone } from './dom/value-types/animatable-none.mjs';\r\nimport { findValueType } from './dom/value-types/find.mjs';\r\nimport { transformProps } from './html/utils/keys-transform.mjs';\r\nimport { visualElementStore } from './store.mjs';\r\nimport { isControllingVariants, isVariantNode } from './utils/is-controlling-variants.mjs';\r\nimport { KeyframeResolver } from './utils/KeyframesResolver.mjs';\r\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\r\nimport { resolveVariantFromProps } from './utils/resolve-variants.mjs';\r\nimport { frame, cancelFrame } from '../frameloop/frame.mjs';\r\n\r\nconst propEventHandlers = [\r\n    \"AnimationStart\",\r\n    \"AnimationComplete\",\r\n    \"Update\",\r\n    \"BeforeLayoutMeasure\",\r\n    \"LayoutMeasure\",\r\n    \"LayoutAnimationStart\",\r\n    \"LayoutAnimationComplete\",\r\n];\r\n/**\r\n * A VisualElement is an imperative abstraction around UI elements such as\r\n * HTMLElement, SVGElement, Three.Object3D etc.\r\n */\r\nclass VisualElement {\r\n    /**\r\n     * This method takes React props and returns found MotionValues. For example, HTML\r\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\r\n     *\r\n     * This isn't an abstract method as it needs calling in the constructor, but it is\r\n     * intended to be one.\r\n     */\r\n    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\r\n        return {};\r\n    }\r\n    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {\r\n        /**\r\n         * A reference to the current underlying Instance, e.g. a HTMLElement\r\n         * or Three.Mesh etc.\r\n         */\r\n        this.current = null;\r\n        /**\r\n         * A set containing references to this VisualElement's children.\r\n         */\r\n        this.children = new Set();\r\n        /**\r\n         * Determine what role this visual element should take in the variant tree.\r\n         */\r\n        this.isVariantNode = false;\r\n        this.isControllingVariants = false;\r\n        /**\r\n         * Decides whether this VisualElement should animate in reduced motion\r\n         * mode.\r\n         *\r\n         * TODO: This is currently set on every individual VisualElement but feels\r\n         * like it could be set globally.\r\n         */\r\n        this.shouldReduceMotion = null;\r\n        /**\r\n         * A map of all motion values attached to this visual element. Motion\r\n         * values are source of truth for any given animated value. A motion\r\n         * value might be provided externally by the component via props.\r\n         */\r\n        this.values = new Map();\r\n        this.KeyframeResolver = KeyframeResolver;\r\n        /**\r\n         * Cleanup functions for active features (hover/tap/exit etc)\r\n         */\r\n        this.features = {};\r\n        /**\r\n         * A map of every subscription that binds the provided or generated\r\n         * motion values onChange listeners to this visual element.\r\n         */\r\n        this.valueSubscriptions = new Map();\r\n        /**\r\n         * A reference to the previously-provided motion values as returned\r\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\r\n         * if any motion values need to be removed after props are updated.\r\n         */\r\n        this.prevMotionValues = {};\r\n        /**\r\n         * An object containing a SubscriptionManager for each active event.\r\n         */\r\n        this.events = {};\r\n        /**\r\n         * An object containing an unsubscribe function for each prop event subscription.\r\n         * For example, every \"Update\" event can have multiple subscribers via\r\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\r\n         */\r\n        this.propEventSubscriptions = {};\r\n        this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\r\n        this.render = () => {\r\n            if (!this.current)\r\n                return;\r\n            this.triggerBuild();\r\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\r\n        };\r\n        this.renderScheduledAt = 0.0;\r\n        this.scheduleRender = () => {\r\n            const now = time.now();\r\n            if (this.renderScheduledAt < now) {\r\n                this.renderScheduledAt = now;\r\n                frame.render(this.render, false, true);\r\n            }\r\n        };\r\n        const { latestValues, renderState, onUpdate } = visualState;\r\n        this.onUpdate = onUpdate;\r\n        this.latestValues = latestValues;\r\n        this.baseTarget = { ...latestValues };\r\n        this.initialValues = props.initial ? { ...latestValues } : {};\r\n        this.renderState = renderState;\r\n        this.parent = parent;\r\n        this.props = props;\r\n        this.presenceContext = presenceContext;\r\n        this.depth = parent ? parent.depth + 1 : 0;\r\n        this.reducedMotionConfig = reducedMotionConfig;\r\n        this.options = options;\r\n        this.blockInitialAnimation = Boolean(blockInitialAnimation);\r\n        this.isControllingVariants = isControllingVariants(props);\r\n        this.isVariantNode = isVariantNode(props);\r\n        if (this.isVariantNode) {\r\n            this.variantChildren = new Set();\r\n        }\r\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\r\n        /**\r\n         * Any motion values that are provided to the element when created\r\n         * aren't yet bound to the element, as this would technically be impure.\r\n         * However, we iterate through the motion values and set them to the\r\n         * initial values for this component.\r\n         *\r\n         * TODO: This is impure and we should look at changing this to run on mount.\r\n         * Doing so will break some tests but this isn't necessarily a breaking change,\r\n         * more a reflection of the test.\r\n         */\r\n        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);\r\n        for (const key in initialMotionValues) {\r\n            const value = initialMotionValues[key];\r\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\r\n                value.set(latestValues[key], false);\r\n            }\r\n        }\r\n    }\r\n    mount(instance) {\r\n        this.current = instance;\r\n        visualElementStore.set(instance, this);\r\n        if (this.projection && !this.projection.instance) {\r\n            this.projection.mount(instance);\r\n        }\r\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\r\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\r\n        }\r\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value));\r\n        if (!hasReducedMotionListener.current) {\r\n            initPrefersReducedMotion();\r\n        }\r\n        this.shouldReduceMotion =\r\n            this.reducedMotionConfig === \"never\"\r\n                ? false\r\n                : this.reducedMotionConfig === \"always\"\r\n                    ? true\r\n                    : prefersReducedMotion.current;\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\r\n        }\r\n        if (this.parent)\r\n            this.parent.children.add(this);\r\n        this.update(this.props, this.presenceContext);\r\n    }\r\n    unmount() {\r\n        visualElementStore.delete(this.current);\r\n        this.projection && this.projection.unmount();\r\n        cancelFrame(this.notifyUpdate);\r\n        cancelFrame(this.render);\r\n        this.valueSubscriptions.forEach((remove) => remove());\r\n        this.valueSubscriptions.clear();\r\n        this.removeFromVariantTree && this.removeFromVariantTree();\r\n        this.parent && this.parent.children.delete(this);\r\n        for (const key in this.events) {\r\n            this.events[key].clear();\r\n        }\r\n        for (const key in this.features) {\r\n            const feature = this.features[key];\r\n            if (feature) {\r\n                feature.unmount();\r\n                feature.isMounted = false;\r\n            }\r\n        }\r\n        this.current = null;\r\n    }\r\n    bindToMotionValue(key, value) {\r\n        if (this.valueSubscriptions.has(key)) {\r\n            this.valueSubscriptions.get(key)();\r\n        }\r\n        const valueIsTransform = transformProps.has(key);\r\n        const removeOnChange = value.on(\"change\", (latestValue) => {\r\n            this.latestValues[key] = latestValue;\r\n            this.props.onUpdate && frame.preRender(this.notifyUpdate);\r\n            if (valueIsTransform && this.projection) {\r\n                this.projection.isTransformDirty = true;\r\n            }\r\n        });\r\n        const removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\r\n        let removeSyncCheck;\r\n        if (window.MotionCheckAppearSync) {\r\n            removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\r\n        }\r\n        this.valueSubscriptions.set(key, () => {\r\n            removeOnChange();\r\n            removeOnRenderRequest();\r\n            if (removeSyncCheck)\r\n                removeSyncCheck();\r\n            if (value.owner)\r\n                value.stop();\r\n        });\r\n    }\r\n    sortNodePosition(other) {\r\n        /**\r\n         * If these nodes aren't even of the same type we can't compare their depth.\r\n         */\r\n        if (!this.current ||\r\n            !this.sortInstanceNodePosition ||\r\n            this.type !== other.type) {\r\n            return 0;\r\n        }\r\n        return this.sortInstanceNodePosition(this.current, other.current);\r\n    }\r\n    updateFeatures() {\r\n        let key = \"animation\";\r\n        for (key in featureDefinitions) {\r\n            const featureDefinition = featureDefinitions[key];\r\n            if (!featureDefinition)\r\n                continue;\r\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition;\r\n            /**\r\n             * If this feature is enabled but not active, make a new instance.\r\n             */\r\n            if (!this.features[key] &&\r\n                FeatureConstructor &&\r\n                isEnabled(this.props)) {\r\n                this.features[key] = new FeatureConstructor(this);\r\n            }\r\n            /**\r\n             * If we have a feature, mount or update it.\r\n             */\r\n            if (this.features[key]) {\r\n                const feature = this.features[key];\r\n                if (feature.isMounted) {\r\n                    feature.update();\r\n                }\r\n                else {\r\n                    feature.mount();\r\n                    feature.isMounted = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    triggerBuild() {\r\n        this.build(this.renderState, this.latestValues, this.props);\r\n    }\r\n    /**\r\n     * Measure the current viewport box with or without transforms.\r\n     * Only measures axis-aligned boxes, rotate and skew must be manually\r\n     * removed with a re-render to work.\r\n     */\r\n    measureViewportBox() {\r\n        return this.current\r\n            ? this.measureInstanceViewportBox(this.current, this.props)\r\n            : createBox();\r\n    }\r\n    getStaticValue(key) {\r\n        return this.latestValues[key];\r\n    }\r\n    setStaticValue(key, value) {\r\n        this.latestValues[key] = value;\r\n    }\r\n    /**\r\n     * Update the provided props. Ensure any newly-added motion values are\r\n     * added to our map, old ones removed, and listeners updated.\r\n     */\r\n    update(props, presenceContext) {\r\n        if (props.transformTemplate || this.props.transformTemplate) {\r\n            this.scheduleRender();\r\n        }\r\n        this.prevProps = this.props;\r\n        this.props = props;\r\n        this.prevPresenceContext = this.presenceContext;\r\n        this.presenceContext = presenceContext;\r\n        /**\r\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\r\n         */\r\n        for (let i = 0; i < propEventHandlers.length; i++) {\r\n            const key = propEventHandlers[i];\r\n            if (this.propEventSubscriptions[key]) {\r\n                this.propEventSubscriptions[key]();\r\n                delete this.propEventSubscriptions[key];\r\n            }\r\n            const listenerName = (\"on\" + key);\r\n            const listener = props[listenerName];\r\n            if (listener) {\r\n                this.propEventSubscriptions[key] = this.on(key, listener);\r\n            }\r\n        }\r\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);\r\n        if (this.handleChildMotionValue) {\r\n            this.handleChildMotionValue();\r\n        }\r\n        this.onUpdate && this.onUpdate(this);\r\n    }\r\n    getProps() {\r\n        return this.props;\r\n    }\r\n    /**\r\n     * Returns the variant definition with a given name.\r\n     */\r\n    getVariant(name) {\r\n        return this.props.variants ? this.props.variants[name] : undefined;\r\n    }\r\n    /**\r\n     * Returns the defined default transition on this component.\r\n     */\r\n    getDefaultTransition() {\r\n        return this.props.transition;\r\n    }\r\n    getTransformPagePoint() {\r\n        return this.props.transformPagePoint;\r\n    }\r\n    getClosestVariantNode() {\r\n        return this.isVariantNode\r\n            ? this\r\n            : this.parent\r\n                ? this.parent.getClosestVariantNode()\r\n                : undefined;\r\n    }\r\n    /**\r\n     * Add a child visual element to our set of children.\r\n     */\r\n    addVariantChild(child) {\r\n        const closestVariantNode = this.getClosestVariantNode();\r\n        if (closestVariantNode) {\r\n            closestVariantNode.variantChildren &&\r\n                closestVariantNode.variantChildren.add(child);\r\n            return () => closestVariantNode.variantChildren.delete(child);\r\n        }\r\n    }\r\n    /**\r\n     * Add a motion value and bind it to this visual element.\r\n     */\r\n    addValue(key, value) {\r\n        // Remove existing value if it exists\r\n        const existingValue = this.values.get(key);\r\n        if (value !== existingValue) {\r\n            if (existingValue)\r\n                this.removeValue(key);\r\n            this.bindToMotionValue(key, value);\r\n            this.values.set(key, value);\r\n            this.latestValues[key] = value.get();\r\n        }\r\n    }\r\n    /**\r\n     * Remove a motion value and unbind any active subscriptions.\r\n     */\r\n    removeValue(key) {\r\n        this.values.delete(key);\r\n        const unsubscribe = this.valueSubscriptions.get(key);\r\n        if (unsubscribe) {\r\n            unsubscribe();\r\n            this.valueSubscriptions.delete(key);\r\n        }\r\n        delete this.latestValues[key];\r\n        this.removeValueFromRenderState(key, this.renderState);\r\n    }\r\n    /**\r\n     * Check whether we have a motion value for this key\r\n     */\r\n    hasValue(key) {\r\n        return this.values.has(key);\r\n    }\r\n    getValue(key, defaultValue) {\r\n        if (this.props.values && this.props.values[key]) {\r\n            return this.props.values[key];\r\n        }\r\n        let value = this.values.get(key);\r\n        if (value === undefined && defaultValue !== undefined) {\r\n            value = motionValue(defaultValue === null ? undefined : defaultValue, { owner: this });\r\n            this.addValue(key, value);\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * If we're trying to animate to a previously unencountered value,\r\n     * we need to check for it in our state and as a last resort read it\r\n     * directly from the instance (which might have performance implications).\r\n     */\r\n    readValue(key, target) {\r\n        var _a;\r\n        let value = this.latestValues[key] !== undefined || !this.current\r\n            ? this.latestValues[key]\r\n            : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);\r\n        if (value !== undefined && value !== null) {\r\n            if (typeof value === \"string\" &&\r\n                (isNumericalString(value) || isZeroValueString(value))) {\r\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\r\n                value = parseFloat(value);\r\n            }\r\n            else if (!findValueType(value) && complex.test(target)) {\r\n                value = getAnimatableNone(key, target);\r\n            }\r\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\r\n        }\r\n        return isMotionValue(value) ? value.get() : value;\r\n    }\r\n    /**\r\n     * Set the base target to later animate back to. This is currently\r\n     * only hydrated on creation and when we first read a value.\r\n     */\r\n    setBaseTarget(key, value) {\r\n        this.baseTarget[key] = value;\r\n    }\r\n    /**\r\n     * Find the base target for a value thats been removed from all animation\r\n     * props.\r\n     */\r\n    getBaseTarget(key) {\r\n        var _a;\r\n        const { initial } = this.props;\r\n        let valueFromInitial;\r\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\r\n            const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);\r\n            if (variant) {\r\n                valueFromInitial = variant[key];\r\n            }\r\n        }\r\n        /**\r\n         * If this value still exists in the current initial variant, read that.\r\n         */\r\n        if (initial && valueFromInitial !== undefined) {\r\n            return valueFromInitial;\r\n        }\r\n        /**\r\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\r\n         * so we can read the value from an alternative source, try that.\r\n         */\r\n        const target = this.getBaseTargetFromProps(this.props, key);\r\n        if (target !== undefined && !isMotionValue(target))\r\n            return target;\r\n        /**\r\n         * If the value was initially defined on initial, but it doesn't any more,\r\n         * return undefined. Otherwise return the value as initially read from the DOM.\r\n         */\r\n        return this.initialValues[key] !== undefined &&\r\n            valueFromInitial === undefined\r\n            ? undefined\r\n            : this.baseTarget[key];\r\n    }\r\n    on(eventName, callback) {\r\n        if (!this.events[eventName]) {\r\n            this.events[eventName] = new SubscriptionManager();\r\n        }\r\n        return this.events[eventName].add(callback);\r\n    }\r\n    notify(eventName, ...args) {\r\n        if (this.events[eventName]) {\r\n            this.events[eventName].notify(...args);\r\n        }\r\n    }\r\n}\r\n\r\nexport { VisualElement };\r\n","import { isBrowser } from '../is-browser.mjs';\r\nimport { hasReducedMotionListener, prefersReducedMotion } from './state.mjs';\r\n\r\nfunction initPrefersReducedMotion() {\r\n    hasReducedMotionListener.current = true;\r\n    if (!isBrowser)\r\n        return;\r\n    if (window.matchMedia) {\r\n        const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\r\n        const setReducedMotionPreferences = () => (prefersReducedMotion.current = motionMediaQuery.matches);\r\n        motionMediaQuery.addListener(setReducedMotionPreferences);\r\n        setReducedMotionPreferences();\r\n    }\r\n    else {\r\n        prefersReducedMotion.current = false;\r\n    }\r\n}\r\n\r\nexport { initPrefersReducedMotion };\r\n","import { warnOnce } from '../../utils/warn-once.mjs';\r\nimport { motionValue } from '../../value/index.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\n\r\nfunction updateMotionValuesFromProps(element, next, prev) {\r\n    for (const key in next) {\r\n        const nextValue = next[key];\r\n        const prevValue = prev[key];\r\n        if (isMotionValue(nextValue)) {\r\n            /**\r\n             * If this is a motion value found in props or style, we want to add it\r\n             * to our visual element's motion value map.\r\n             */\r\n            element.addValue(key, nextValue);\r\n            /**\r\n             * Check the version of the incoming motion value with this version\r\n             * and warn against mismatches.\r\n             */\r\n            if (process.env.NODE_ENV === \"development\") {\r\n                warnOnce(nextValue.version === \"11.18.2\", `Attempting to mix Motion versions ${nextValue.version} with 11.18.2 may not work as expected.`);\r\n            }\r\n        }\r\n        else if (isMotionValue(prevValue)) {\r\n            /**\r\n             * If we're swapping from a motion value to a static value,\r\n             * create a new motion value from that\r\n             */\r\n            element.addValue(key, motionValue(nextValue, { owner: element }));\r\n        }\r\n        else if (prevValue !== nextValue) {\r\n            /**\r\n             * If this is a flat value that has changed, update the motion value\r\n             * or create one if it doesn't exist. We only want to do this if we're\r\n             * not handling the value with our animation state.\r\n             */\r\n            if (element.hasValue(key)) {\r\n                const existingValue = element.getValue(key);\r\n                if (existingValue.liveStyle === true) {\r\n                    existingValue.jump(nextValue);\r\n                }\r\n                else if (!existingValue.hasAnimated) {\r\n                    existingValue.set(nextValue);\r\n                }\r\n            }\r\n            else {\r\n                const latestValue = element.getStaticValue(key);\r\n                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));\r\n            }\r\n        }\r\n    }\r\n    // Handle removed values\r\n    for (const key in prev) {\r\n        if (next[key] === undefined)\r\n            element.removeValue(key);\r\n    }\r\n    return next;\r\n}\r\n\r\nexport { updateMotionValuesFromProps };\r\n","import { VisualElement } from '../VisualElement.mjs';\r\nimport { DOMKeyframesResolver } from './DOMKeyframesResolver.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\n\r\nclass DOMVisualElement extends VisualElement {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.KeyframeResolver = DOMKeyframesResolver;\r\n    }\r\n    sortInstanceNodePosition(a, b) {\r\n        /**\r\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\r\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\r\n         * to true if b preceeds a.\r\n         */\r\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\r\n    }\r\n    getBaseTargetFromProps(props, key) {\r\n        return props.style\r\n            ? props.style[key]\r\n            : undefined;\r\n    }\r\n    removeValueFromRenderState(key, { vars, style }) {\r\n        delete vars[key];\r\n        delete style[key];\r\n    }\r\n    handleChildMotionValue() {\r\n        if (this.childSubscription) {\r\n            this.childSubscription();\r\n            delete this.childSubscription;\r\n        }\r\n        const { children } = this.props;\r\n        if (isMotionValue(children)) {\r\n            this.childSubscription = children.on(\"change\", (latest) => {\r\n                if (this.current) {\r\n                    this.current.textContent = `${latest}`;\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nexport { DOMVisualElement };\r\n","import { measureViewportBox } from '../../projection/utils/measure.mjs';\r\nimport { DOMVisualElement } from '../dom/DOMVisualElement.mjs';\r\nimport { isCSSVariableName } from '../dom/utils/is-css-variable.mjs';\r\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\r\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\r\nimport { transformProps } from './utils/keys-transform.mjs';\r\nimport { renderHTML } from './utils/render.mjs';\r\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\r\n\r\nfunction getComputedStyle(element) {\r\n    return window.getComputedStyle(element);\r\n}\r\nclass HTMLVisualElement extends DOMVisualElement {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"html\";\r\n        this.renderInstance = renderHTML;\r\n    }\r\n    readValueFromInstance(instance, key) {\r\n        if (transformProps.has(key)) {\r\n            const defaultType = getDefaultValueType(key);\r\n            return defaultType ? defaultType.default || 0 : 0;\r\n        }\r\n        else {\r\n            const computedStyle = getComputedStyle(instance);\r\n            const value = (isCSSVariableName(key)\r\n                ? computedStyle.getPropertyValue(key)\r\n                : computedStyle[key]) || 0;\r\n            return typeof value === \"string\" ? value.trim() : value;\r\n        }\r\n    }\r\n    measureInstanceViewportBox(instance, { transformPagePoint }) {\r\n        return measureViewportBox(instance, transformPagePoint);\r\n    }\r\n    build(renderState, latestValues, props) {\r\n        buildHTMLStyles(renderState, latestValues, props.transformTemplate);\r\n    }\r\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\r\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\r\n    }\r\n}\r\n\r\nexport { HTMLVisualElement, getComputedStyle };\r\n","import { createBox } from '../../projection/geometry/models.mjs';\r\nimport { DOMVisualElement } from '../dom/DOMVisualElement.mjs';\r\nimport { camelToDash } from '../dom/utils/camel-to-dash.mjs';\r\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\r\nimport { transformProps } from '../html/utils/keys-transform.mjs';\r\nimport { buildSVGAttrs } from './utils/build-attrs.mjs';\r\nimport { camelCaseAttributes } from './utils/camel-case-attrs.mjs';\r\nimport { isSVGTag } from './utils/is-svg-tag.mjs';\r\nimport { renderSVG } from './utils/render.mjs';\r\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\r\n\r\nclass SVGVisualElement extends DOMVisualElement {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"svg\";\r\n        this.isSVGTag = false;\r\n        this.measureInstanceViewportBox = createBox;\r\n    }\r\n    getBaseTargetFromProps(props, key) {\r\n        return props[key];\r\n    }\r\n    readValueFromInstance(instance, key) {\r\n        if (transformProps.has(key)) {\r\n            const defaultType = getDefaultValueType(key);\r\n            return defaultType ? defaultType.default || 0 : 0;\r\n        }\r\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\r\n        return instance.getAttribute(key);\r\n    }\r\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\r\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\r\n    }\r\n    build(renderState, latestValues, props) {\r\n        buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);\r\n    }\r\n    renderInstance(instance, renderState, styleProp, projection) {\r\n        renderSVG(instance, renderState, styleProp, projection);\r\n    }\r\n    mount(instance) {\r\n        this.isSVGTag = isSVGTag(instance.tagName);\r\n        super.mount(instance);\r\n    }\r\n}\r\n\r\nexport { SVGVisualElement };\r\n","import { Fragment } from 'react';\r\nimport { HTMLVisualElement } from '../html/HTMLVisualElement.mjs';\r\nimport { SVGVisualElement } from '../svg/SVGVisualElement.mjs';\r\nimport { isSVGComponent } from './utils/is-svg-component.mjs';\r\n\r\nconst createDomVisualElement = (Component, options) => {\r\n    return isSVGComponent(Component)\r\n        ? new SVGVisualElement(options)\r\n        : new HTMLVisualElement(options, {\r\n            allowProjection: Component !== Fragment,\r\n        });\r\n};\r\n\r\nexport { createDomVisualElement };\r\n","import { createDOMMotionComponentProxy } from '../create-proxy.mjs';\r\nimport { createMotionComponent } from './create.mjs';\r\n\r\nconst motion = /*@__PURE__*/ createDOMMotionComponentProxy(createMotionComponent);\r\n\r\nexport { motion };\r\n","import { animations } from '../../../motion/features/animations.mjs';\r\nimport { drag } from '../../../motion/features/drag.mjs';\r\nimport { gestureAnimations } from '../../../motion/features/gestures.mjs';\r\nimport { layout } from '../../../motion/features/layout.mjs';\r\nimport { createMotionComponentFactory } from '../create-factory.mjs';\r\nimport { createDomVisualElement } from '../../dom/create-visual-element.mjs';\r\n\r\nconst createMotionComponent = /*@__PURE__*/ createMotionComponentFactory({\r\n    ...animations,\r\n    ...gestureAnimations,\r\n    ...drag,\r\n    ...layout,\r\n}, createDomVisualElement);\r\n\r\nexport { createMotionComponent };\r\n","import { analyseComplexValue } from '../../../value/types/complex/index.mjs';\r\nimport { getAnimatableNone } from '../../dom/value-types/animatable-none.mjs';\r\n\r\n/**\r\n * If we encounter keyframes like \"none\" or \"0\" and we also have keyframes like\r\n * \"#fff\" or \"200px 200px\" we want to find a keyframe to serve as a template for\r\n * the \"none\" keyframes. In this case \"#fff\" or \"200px 200px\" - then these get turned into\r\n * zero equivalents, i.e. \"#fff0\" or \"0px 0px\".\r\n */\r\nconst invalidTemplates = new Set([\"auto\", \"none\", \"0\"]);\r\nfunction makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {\r\n    let i = 0;\r\n    let animatableTemplate = undefined;\r\n    while (i < unresolvedKeyframes.length && !animatableTemplate) {\r\n        const keyframe = unresolvedKeyframes[i];\r\n        if (typeof keyframe === \"string\" &&\r\n            !invalidTemplates.has(keyframe) &&\r\n            analyseComplexValue(keyframe).values.length) {\r\n            animatableTemplate = unresolvedKeyframes[i];\r\n        }\r\n        i++;\r\n    }\r\n    if (animatableTemplate && name) {\r\n        for (const noneIndex of noneKeyframeIndexes) {\r\n            unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);\r\n        }\r\n    }\r\n}\r\n\r\nexport { makeNoneKeyframesAnimatable };\r\n","import { invariant } from 'motion-utils';\r\nimport { isNumericalString } from '../../../utils/is-numerical-string.mjs';\r\nimport { isCSSVariableToken } from './is-css-variable.mjs';\r\n\r\n/**\r\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\r\n *\r\n * ```\r\n * `var(--foo, #fff)` => [`--foo`, '#fff']\r\n * ```\r\n *\r\n * @param current\r\n */\r\nconst splitCSSVariableRegex = \r\n// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words\r\n/^var\\(--(?:([\\w-]+)|([\\w-]+), ?([a-zA-Z\\d ()%#.,-]+))\\)/u;\r\nfunction parseCSSVariable(current) {\r\n    const match = splitCSSVariableRegex.exec(current);\r\n    if (!match)\r\n        return [,];\r\n    const [, token1, token2, fallback] = match;\r\n    return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];\r\n}\r\nconst maxDepth = 4;\r\nfunction getVariableValue(current, element, depth = 1) {\r\n    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\r\n    const [token, fallback] = parseCSSVariable(current);\r\n    // No CSS variable detected\r\n    if (!token)\r\n        return;\r\n    // Attempt to read this CSS variable off the element\r\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\r\n    if (resolved) {\r\n        const trimmed = resolved.trim();\r\n        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\r\n    }\r\n    return isCSSVariableToken(fallback)\r\n        ? getVariableValue(fallback, element, depth + 1)\r\n        : fallback;\r\n}\r\n\r\nexport { getVariableValue, parseCSSVariable };\r\n","import { isNone } from '../../animation/utils/is-none.mjs';\r\nimport { positionalKeys } from '../html/utils/keys-position.mjs';\r\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\r\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\r\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\r\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\r\nimport { isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\r\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\r\n\r\nclass DOMKeyframesResolver extends KeyframeResolver {\r\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\r\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\r\n    }\r\n    readKeyframes() {\r\n        const { unresolvedKeyframes, element, name } = this;\r\n        if (!element || !element.current)\r\n            return;\r\n        super.readKeyframes();\r\n        /**\r\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\r\n         */\r\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\r\n            let keyframe = unresolvedKeyframes[i];\r\n            if (typeof keyframe === \"string\") {\r\n                keyframe = keyframe.trim();\r\n                if (isCSSVariableToken(keyframe)) {\r\n                    const resolved = getVariableValue(keyframe, element.current);\r\n                    if (resolved !== undefined) {\r\n                        unresolvedKeyframes[i] = resolved;\r\n                    }\r\n                    if (i === unresolvedKeyframes.length - 1) {\r\n                        this.finalKeyframe = keyframe;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\r\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\r\n         * have a far bigger performance impact.\r\n         */\r\n        this.resolveNoneKeyframes();\r\n        /**\r\n         * Check to see if unit type has changed. If so schedule jobs that will\r\n         * temporarily set styles to the destination keyframes.\r\n         * Skip if we have more than two keyframes or this isn't a positional value.\r\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\r\n         */\r\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\r\n            return;\r\n        }\r\n        const [origin, target] = unresolvedKeyframes;\r\n        const originType = findDimensionValueType(origin);\r\n        const targetType = findDimensionValueType(target);\r\n        /**\r\n         * Either we don't recognise these value types or we can animate between them.\r\n         */\r\n        if (originType === targetType)\r\n            return;\r\n        /**\r\n         * If both values are numbers or pixels, we can animate between them by\r\n         * converting them to numbers.\r\n         */\r\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\r\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\r\n                const value = unresolvedKeyframes[i];\r\n                if (typeof value === \"string\") {\r\n                    unresolvedKeyframes[i] = parseFloat(value);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            /**\r\n             * Else, the only way to resolve this is by measuring the element.\r\n             */\r\n            this.needsMeasurement = true;\r\n        }\r\n    }\r\n    resolveNoneKeyframes() {\r\n        const { unresolvedKeyframes, name } = this;\r\n        const noneKeyframeIndexes = [];\r\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\r\n            if (isNone(unresolvedKeyframes[i])) {\r\n                noneKeyframeIndexes.push(i);\r\n            }\r\n        }\r\n        if (noneKeyframeIndexes.length) {\r\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\r\n        }\r\n    }\r\n    measureInitialState() {\r\n        const { element, unresolvedKeyframes, name } = this;\r\n        if (!element || !element.current)\r\n            return;\r\n        if (name === \"height\") {\r\n            this.suspendedScrollY = window.pageYOffset;\r\n        }\r\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\r\n        unresolvedKeyframes[0] = this.measuredOrigin;\r\n        // Set final key frame to measure after next render\r\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\r\n        if (measureKeyframe !== undefined) {\r\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\r\n        }\r\n    }\r\n    measureEndState() {\r\n        var _a;\r\n        const { element, name, unresolvedKeyframes } = this;\r\n        if (!element || !element.current)\r\n            return;\r\n        const value = element.getValue(name);\r\n        value && value.jump(this.measuredOrigin, false);\r\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\r\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\r\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\r\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\r\n            this.finalKeyframe = finalKeyframe;\r\n        }\r\n        // If we removed transform values, reapply them before the next render\r\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\r\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\r\n                element\r\n                    .getValue(unsetTransformName)\r\n                    .set(unsetTransformValue);\r\n            });\r\n        }\r\n        this.resolveNoneKeyframes();\r\n    }\r\n}\r\n\r\nexport { DOMKeyframesResolver };\r\n","/**\r\n * Convert camelCase to dash-case properties.\r\n */\r\nconst camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, \"$1-$2\").toLowerCase();\r\n\r\nexport { camelToDash };\r\n","const checkStringStartsWith = (token) => (key) => typeof key === \"string\" && key.startsWith(token);\r\nconst isCSSVariableName = \r\n/*@__PURE__*/ checkStringStartsWith(\"--\");\r\nconst startsAsVariableToken = \r\n/*@__PURE__*/ checkStringStartsWith(\"var(--\");\r\nconst isCSSVariableToken = (value) => {\r\n    const startsWithToken = startsAsVariableToken(value);\r\n    if (!startsWithToken)\r\n        return false;\r\n    // Ensure any comments are stripped from the value as this can harm performance of the regex.\r\n    return singleCssVariableRegex.test(value.split(\"/*\")[0].trim());\r\n};\r\nconst singleCssVariableRegex = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu;\r\n\r\nexport { isCSSVariableName, isCSSVariableToken };\r\n","import { number } from '../../../value/types/numbers/index.mjs';\r\nimport { px } from '../../../value/types/numbers/units.mjs';\r\nimport { transformPropOrder } from '../../html/utils/keys-transform.mjs';\r\n\r\nconst isNumOrPxType = (v) => v === number || v === px;\r\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\r\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\r\n    if (transform === \"none\" || !transform)\r\n        return 0;\r\n    const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/u);\r\n    if (matrix3d) {\r\n        return getPosFromMatrix(matrix3d[1], pos3);\r\n    }\r\n    else {\r\n        const matrix = transform.match(/^matrix\\((.+)\\)$/u);\r\n        if (matrix) {\r\n            return getPosFromMatrix(matrix[1], pos2);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n};\r\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\r\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\r\nfunction removeNonTranslationalTransform(visualElement) {\r\n    const removedTransforms = [];\r\n    nonTranslationalTransformKeys.forEach((key) => {\r\n        const value = visualElement.getValue(key);\r\n        if (value !== undefined) {\r\n            removedTransforms.push([key, value.get()]);\r\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\r\n        }\r\n    });\r\n    return removedTransforms;\r\n}\r\nconst positionalValues = {\r\n    // Dimensions\r\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\r\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\r\n    top: (_bbox, { top }) => parseFloat(top),\r\n    left: (_bbox, { left }) => parseFloat(left),\r\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\r\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\r\n    // Transform\r\n    x: getTranslateFromMatrix(4, 13),\r\n    y: getTranslateFromMatrix(5, 14),\r\n};\r\n// Alias translate longform names\r\npositionalValues.translateX = positionalValues.x;\r\npositionalValues.translateY = positionalValues.y;\r\n\r\nexport { isNumOrPxType, positionalValues, removeNonTranslationalTransform };\r\n","import { complex } from '../../../value/types/complex/index.mjs';\r\nimport { filter } from '../../../value/types/complex/filter.mjs';\r\nimport { getDefaultValueType } from './defaults.mjs';\r\n\r\nfunction getAnimatableNone(key, value) {\r\n    let defaultValueType = getDefaultValueType(key);\r\n    if (defaultValueType !== filter)\r\n        defaultValueType = complex;\r\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\r\n    return defaultValueType.getAnimatableNone\r\n        ? defaultValueType.getAnimatableNone(value)\r\n        : undefined;\r\n}\r\n\r\nexport { getAnimatableNone };\r\n","import { color } from '../../../value/types/color/index.mjs';\r\nimport { filter } from '../../../value/types/complex/filter.mjs';\r\nimport { numberValueTypes } from './number.mjs';\r\n\r\n/**\r\n * A map of default value types for common values\r\n */\r\nconst defaultValueTypes = {\r\n    ...numberValueTypes,\r\n    // Color props\r\n    color,\r\n    backgroundColor: color,\r\n    outlineColor: color,\r\n    fill: color,\r\n    stroke: color,\r\n    // Border props\r\n    borderColor: color,\r\n    borderTopColor: color,\r\n    borderRightColor: color,\r\n    borderBottomColor: color,\r\n    borderLeftColor: color,\r\n    filter,\r\n    WebkitFilter: filter,\r\n};\r\n/**\r\n * Gets the default ValueType for the provided value key\r\n */\r\nconst getDefaultValueType = (key) => defaultValueTypes[key];\r\n\r\nexport { defaultValueTypes, getDefaultValueType };\r\n","/**\r\n * ValueType for \"auto\"\r\n */\r\nconst auto = {\r\n    test: (v) => v === \"auto\",\r\n    parse: (v) => v,\r\n};\r\n\r\nexport { auto };\r\n","import { number } from '../../../value/types/numbers/index.mjs';\r\nimport { px, percent, degrees, vw, vh } from '../../../value/types/numbers/units.mjs';\r\nimport { testValueType } from './test.mjs';\r\nimport { auto } from './type-auto.mjs';\r\n\r\n/**\r\n * A list of value types commonly used for dimensions\r\n */\r\nconst dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\r\n/**\r\n * Tests a dimensional value against the list of dimension ValueTypes\r\n */\r\nconst findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\r\n\r\nexport { dimensionValueTypes, findDimensionValueType };\r\n","import { px } from '../../../value/types/numbers/units.mjs';\r\n\r\nconst browserNumberValueTypes = {\r\n    // Border props\r\n    borderWidth: px,\r\n    borderTopWidth: px,\r\n    borderRightWidth: px,\r\n    borderBottomWidth: px,\r\n    borderLeftWidth: px,\r\n    borderRadius: px,\r\n    radius: px,\r\n    borderTopLeftRadius: px,\r\n    borderTopRightRadius: px,\r\n    borderBottomRightRadius: px,\r\n    borderBottomLeftRadius: px,\r\n    // Positioning props\r\n    width: px,\r\n    maxWidth: px,\r\n    height: px,\r\n    maxHeight: px,\r\n    top: px,\r\n    right: px,\r\n    bottom: px,\r\n    left: px,\r\n    // Spacing props\r\n    padding: px,\r\n    paddingTop: px,\r\n    paddingRight: px,\r\n    paddingBottom: px,\r\n    paddingLeft: px,\r\n    margin: px,\r\n    marginTop: px,\r\n    marginRight: px,\r\n    marginBottom: px,\r\n    marginLeft: px,\r\n    // Misc\r\n    backgroundPositionX: px,\r\n    backgroundPositionY: px,\r\n};\r\n\r\nexport { browserNumberValueTypes };\r\n","import { scale, alpha } from '../../../value/types/numbers/index.mjs';\r\nimport { degrees, px, progressPercentage } from '../../../value/types/numbers/units.mjs';\r\n\r\nconst transformValueTypes = {\r\n    rotate: degrees,\r\n    rotateX: degrees,\r\n    rotateY: degrees,\r\n    rotateZ: degrees,\r\n    scale,\r\n    scaleX: scale,\r\n    scaleY: scale,\r\n    scaleZ: scale,\r\n    skew: degrees,\r\n    skewX: degrees,\r\n    skewY: degrees,\r\n    distance: px,\r\n    translateX: px,\r\n    translateY: px,\r\n    translateZ: px,\r\n    x: px,\r\n    y: px,\r\n    z: px,\r\n    perspective: px,\r\n    transformPerspective: px,\r\n    opacity: alpha,\r\n    originX: progressPercentage,\r\n    originY: progressPercentage,\r\n    originZ: px,\r\n};\r\n\r\nexport { transformValueTypes };\r\n","import { number } from '../../../value/types/numbers/index.mjs';\r\n\r\nconst int = {\r\n    ...number,\r\n    transform: Math.round,\r\n};\r\n\r\nexport { int };\r\n","import { alpha } from '../../../value/types/numbers/index.mjs';\r\nimport { px } from '../../../value/types/numbers/units.mjs';\r\nimport { browserNumberValueTypes } from './number-browser.mjs';\r\nimport { transformValueTypes } from './transform.mjs';\r\nimport { int } from './type-int.mjs';\r\n\r\nconst numberValueTypes = {\r\n    ...browserNumberValueTypes,\r\n    ...transformValueTypes,\r\n    zIndex: int,\r\n    size: px,\r\n    // SVG\r\n    fillOpacity: alpha,\r\n    strokeOpacity: alpha,\r\n    numOctaves: int,\r\n};\r\n\r\nexport { numberValueTypes };\r\n","/**\r\n * Tests a provided value against a ValueType\r\n */\r\nconst testValueType = (v) => (type) => type.test(v);\r\n\r\nexport { testValueType };\r\n","import { transformPropOrder } from './keys-transform.mjs';\r\n\r\nconst positionalKeys = new Set([\r\n    \"width\",\r\n    \"height\",\r\n    \"top\",\r\n    \"left\",\r\n    \"right\",\r\n    \"bottom\",\r\n    ...transformPropOrder,\r\n]);\r\n\r\nexport { positionalKeys };\r\n","/**\r\n * Generate a list of every possible transform key.\r\n */\r\nconst transformPropOrder = [\r\n    \"transformPerspective\",\r\n    \"x\",\r\n    \"y\",\r\n    \"z\",\r\n    \"translateX\",\r\n    \"translateY\",\r\n    \"translateZ\",\r\n    \"scale\",\r\n    \"scaleX\",\r\n    \"scaleY\",\r\n    \"rotate\",\r\n    \"rotateX\",\r\n    \"rotateY\",\r\n    \"rotateZ\",\r\n    \"skew\",\r\n    \"skewX\",\r\n    \"skewY\",\r\n];\r\n/**\r\n * A quick lookup for transform props.\r\n */\r\nconst transformProps = new Set(transformPropOrder);\r\n\r\nexport { transformPropOrder, transformProps };\r\n","import { removeNonTranslationalTransform } from '../dom/utils/unit-conversion.mjs';\r\nimport { frame } from '../../frameloop/frame.mjs';\r\n\r\nconst toResolve = new Set();\r\nlet isScheduled = false;\r\nlet anyNeedsMeasurement = false;\r\nfunction measureAllKeyframes() {\r\n    if (anyNeedsMeasurement) {\r\n        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\r\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\r\n        const transformsToRestore = new Map();\r\n        /**\r\n         * Write pass\r\n         * If we're measuring elements we want to remove bounding box-changing transforms.\r\n         */\r\n        elementsToMeasure.forEach((element) => {\r\n            const removedTransforms = removeNonTranslationalTransform(element);\r\n            if (!removedTransforms.length)\r\n                return;\r\n            transformsToRestore.set(element, removedTransforms);\r\n            element.render();\r\n        });\r\n        // Read\r\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\r\n        // Write\r\n        elementsToMeasure.forEach((element) => {\r\n            element.render();\r\n            const restore = transformsToRestore.get(element);\r\n            if (restore) {\r\n                restore.forEach(([key, value]) => {\r\n                    var _a;\r\n                    (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);\r\n                });\r\n            }\r\n        });\r\n        // Read\r\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState());\r\n        // Write\r\n        resolversToMeasure.forEach((resolver) => {\r\n            if (resolver.suspendedScrollY !== undefined) {\r\n                window.scrollTo(0, resolver.suspendedScrollY);\r\n            }\r\n        });\r\n    }\r\n    anyNeedsMeasurement = false;\r\n    isScheduled = false;\r\n    toResolve.forEach((resolver) => resolver.complete());\r\n    toResolve.clear();\r\n}\r\nfunction readAllKeyframes() {\r\n    toResolve.forEach((resolver) => {\r\n        resolver.readKeyframes();\r\n        if (resolver.needsMeasurement) {\r\n            anyNeedsMeasurement = true;\r\n        }\r\n    });\r\n}\r\nfunction flushKeyframeResolvers() {\r\n    readAllKeyframes();\r\n    measureAllKeyframes();\r\n}\r\nclass KeyframeResolver {\r\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\r\n        /**\r\n         * Track whether this resolver has completed. Once complete, it never\r\n         * needs to attempt keyframe resolution again.\r\n         */\r\n        this.isComplete = false;\r\n        /**\r\n         * Track whether this resolver is async. If it is, it'll be added to the\r\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\r\n         * to trigger read/write thrashing don't need to be async.\r\n         */\r\n        this.isAsync = false;\r\n        /**\r\n         * Track whether this resolver needs to perform a measurement\r\n         * to resolve its keyframes.\r\n         */\r\n        this.needsMeasurement = false;\r\n        /**\r\n         * Track whether this resolver is currently scheduled to resolve\r\n         * to allow it to be cancelled and resumed externally.\r\n         */\r\n        this.isScheduled = false;\r\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\r\n        this.onComplete = onComplete;\r\n        this.name = name;\r\n        this.motionValue = motionValue;\r\n        this.element = element;\r\n        this.isAsync = isAsync;\r\n    }\r\n    scheduleResolve() {\r\n        this.isScheduled = true;\r\n        if (this.isAsync) {\r\n            toResolve.add(this);\r\n            if (!isScheduled) {\r\n                isScheduled = true;\r\n                frame.read(readAllKeyframes);\r\n                frame.resolveKeyframes(measureAllKeyframes);\r\n            }\r\n        }\r\n        else {\r\n            this.readKeyframes();\r\n            this.complete();\r\n        }\r\n    }\r\n    readKeyframes() {\r\n        const { unresolvedKeyframes, name, element, motionValue } = this;\r\n        /**\r\n         * If a keyframe is null, we hydrate it either by reading it from\r\n         * the instance, or propagating from previous keyframes.\r\n         */\r\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\r\n            if (unresolvedKeyframes[i] === null) {\r\n                /**\r\n                 * If the first keyframe is null, we need to find its value by sampling the element\r\n                 */\r\n                if (i === 0) {\r\n                    const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\r\n                    const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\r\n                    if (currentValue !== undefined) {\r\n                        unresolvedKeyframes[0] = currentValue;\r\n                    }\r\n                    else if (element && name) {\r\n                        const valueAsRead = element.readValue(name, finalKeyframe);\r\n                        if (valueAsRead !== undefined && valueAsRead !== null) {\r\n                            unresolvedKeyframes[0] = valueAsRead;\r\n                        }\r\n                    }\r\n                    if (unresolvedKeyframes[0] === undefined) {\r\n                        unresolvedKeyframes[0] = finalKeyframe;\r\n                    }\r\n                    if (motionValue && currentValue === undefined) {\r\n                        motionValue.set(unresolvedKeyframes[0]);\r\n                    }\r\n                }\r\n                else {\r\n                    unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    setFinalKeyframe() { }\r\n    measureInitialState() { }\r\n    renderEndStyles() { }\r\n    measureEndState() { }\r\n    complete() {\r\n        this.isComplete = true;\r\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\r\n        toResolve.delete(this);\r\n    }\r\n    cancel() {\r\n        if (!this.isComplete) {\r\n            this.isScheduled = false;\r\n            toResolve.delete(this);\r\n        }\r\n    }\r\n    resume() {\r\n        if (!this.isComplete)\r\n            this.scheduleResolve();\r\n    }\r\n}\r\n\r\nexport { KeyframeResolver, flushKeyframeResolvers };\r\n","function shallowCompare(next, prev) {\r\n    if (!Array.isArray(prev))\r\n        return false;\r\n    const prevLength = prev.length;\r\n    if (prevLength !== next.length)\r\n        return false;\r\n    for (let i = 0; i < prevLength; i++) {\r\n        if (prev[i] !== next[i])\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nexport { shallowCompare };\r\n","import { isVariantLabel } from './is-variant-label.mjs';\r\nimport { variantProps } from './variant-props.mjs';\r\n\r\nconst numVariantProps = variantProps.length;\r\nfunction getVariantContext(visualElement) {\r\n    if (!visualElement)\r\n        return undefined;\r\n    if (!visualElement.isControllingVariants) {\r\n        const context = visualElement.parent\r\n            ? getVariantContext(visualElement.parent) || {}\r\n            : {};\r\n        if (visualElement.props.initial !== undefined) {\r\n            context.initial = visualElement.props.initial;\r\n        }\r\n        return context;\r\n    }\r\n    const context = {};\r\n    for (let i = 0; i < numVariantProps; i++) {\r\n        const name = variantProps[i];\r\n        const prop = visualElement.props[name];\r\n        if (isVariantLabel(prop) || prop === false) {\r\n            context[name] = prop;\r\n        }\r\n    }\r\n    return context;\r\n}\r\n\r\nexport { getVariantContext };\r\n","import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\r\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\r\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\r\nimport { isVariantLabel } from './is-variant-label.mjs';\r\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\r\nimport { variantPriorityOrder } from './variant-props.mjs';\r\nimport { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\r\nimport { getVariantContext } from './get-variant-context.mjs';\r\n\r\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\r\nconst numAnimationTypes = variantPriorityOrder.length;\r\nfunction animateList(visualElement) {\r\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\r\n}\r\nfunction createAnimationState(visualElement) {\r\n    let animate = animateList(visualElement);\r\n    let state = createState();\r\n    let isInitialRender = true;\r\n    /**\r\n     * This function will be used to reduce the animation definitions for\r\n     * each active animation type into an object of resolved values for it.\r\n     */\r\n    const buildResolvedTypeValues = (type) => (acc, definition) => {\r\n        var _a;\r\n        const resolved = resolveVariant(visualElement, definition, type === \"exit\"\r\n            ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\r\n            : undefined);\r\n        if (resolved) {\r\n            const { transition, transitionEnd, ...target } = resolved;\r\n            acc = { ...acc, ...target, ...transitionEnd };\r\n        }\r\n        return acc;\r\n    };\r\n    /**\r\n     * This just allows us to inject mocked animation functions\r\n     * @internal\r\n     */\r\n    function setAnimateFunction(makeAnimator) {\r\n        animate = makeAnimator(visualElement);\r\n    }\r\n    /**\r\n     * When we receive new props, we need to:\r\n     * 1. Create a list of protected keys for each type. This is a directory of\r\n     *    value keys that are currently being \"handled\" by types of a higher priority\r\n     *    so that whenever an animation is played of a given type, these values are\r\n     *    protected from being animated.\r\n     * 2. Determine if an animation type needs animating.\r\n     * 3. Determine if any values have been removed from a type and figure out\r\n     *    what to animate those to.\r\n     */\r\n    function animateChanges(changedActiveType) {\r\n        const { props } = visualElement;\r\n        const context = getVariantContext(visualElement.parent) || {};\r\n        /**\r\n         * A list of animations that we'll build into as we iterate through the animation\r\n         * types. This will get executed at the end of the function.\r\n         */\r\n        const animations = [];\r\n        /**\r\n         * Keep track of which values have been removed. Then, as we hit lower priority\r\n         * animation types, we can check if they contain removed values and animate to that.\r\n         */\r\n        const removedKeys = new Set();\r\n        /**\r\n         * A dictionary of all encountered keys. This is an object to let us build into and\r\n         * copy it without iteration. Each time we hit an animation type we set its protected\r\n         * keys - the keys its not allowed to animate - to the latest version of this object.\r\n         */\r\n        let encounteredKeys = {};\r\n        /**\r\n         * If a variant has been removed at a given index, and this component is controlling\r\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\r\n         */\r\n        let removedVariantIndex = Infinity;\r\n        /**\r\n         * Iterate through all animation types in reverse priority order. For each, we want to\r\n         * detect which values it's handling and whether or not they've changed (and therefore\r\n         * need to be animated). If any values have been removed, we want to detect those in\r\n         * lower priority props and flag for animation.\r\n         */\r\n        for (let i = 0; i < numAnimationTypes; i++) {\r\n            const type = reversePriorityOrder[i];\r\n            const typeState = state[type];\r\n            const prop = props[type] !== undefined\r\n                ? props[type]\r\n                : context[type];\r\n            const propIsVariant = isVariantLabel(prop);\r\n            /**\r\n             * If this type has *just* changed isActive status, set activeDelta\r\n             * to that status. Otherwise set to null.\r\n             */\r\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\r\n            if (activeDelta === false)\r\n                removedVariantIndex = i;\r\n            /**\r\n             * If this prop is an inherited variant, rather than been set directly on the\r\n             * component itself, we want to make sure we allow the parent to trigger animations.\r\n             *\r\n             * TODO: Can probably change this to a !isControllingVariants check\r\n             */\r\n            let isInherited = prop === context[type] &&\r\n                prop !== props[type] &&\r\n                propIsVariant;\r\n            /**\r\n             *\r\n             */\r\n            if (isInherited &&\r\n                isInitialRender &&\r\n                visualElement.manuallyAnimateOnMount) {\r\n                isInherited = false;\r\n            }\r\n            /**\r\n             * Set all encountered keys so far as the protected keys for this type. This will\r\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\r\n             */\r\n            typeState.protectedKeys = { ...encounteredKeys };\r\n            // Check if we can skip analysing this prop early\r\n            if (\r\n            // If it isn't active and hasn't *just* been set as inactive\r\n            (!typeState.isActive && activeDelta === null) ||\r\n                // If we didn't and don't have any defined prop for this animation type\r\n                (!prop && !typeState.prevProp) ||\r\n                // Or if the prop doesn't define an animation\r\n                isAnimationControls(prop) ||\r\n                typeof prop === \"boolean\") {\r\n                continue;\r\n            }\r\n            /**\r\n             * As we go look through the values defined on this type, if we detect\r\n             * a changed value or a value that was removed in a higher priority, we set\r\n             * this to true and add this prop to the animation list.\r\n             */\r\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\r\n            let shouldAnimateType = variantDidChange ||\r\n                // If we're making this variant active, we want to always make it active\r\n                (type === changedActiveType &&\r\n                    typeState.isActive &&\r\n                    !isInherited &&\r\n                    propIsVariant) ||\r\n                // If we removed a higher-priority variant (i is in reverse order)\r\n                (i > removedVariantIndex && propIsVariant);\r\n            let handledRemovedValues = false;\r\n            /**\r\n             * As animations can be set as variant lists, variants or target objects, we\r\n             * coerce everything to an array if it isn't one already\r\n             */\r\n            const definitionList = Array.isArray(prop) ? prop : [prop];\r\n            /**\r\n             * Build an object of all the resolved values. We'll use this in the subsequent\r\n             * animateChanges calls to determine whether a value has changed.\r\n             */\r\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\r\n            if (activeDelta === false)\r\n                resolvedValues = {};\r\n            /**\r\n             * Now we need to loop through all the keys in the prev prop and this prop,\r\n             * and decide:\r\n             * 1. If the value has changed, and needs animating\r\n             * 2. If it has been removed, and needs adding to the removedKeys set\r\n             * 3. If it has been removed in a higher priority type and needs animating\r\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\r\n             *    needs adding to the type's protectedKeys list.\r\n             */\r\n            const { prevResolvedValues = {} } = typeState;\r\n            const allKeys = {\r\n                ...prevResolvedValues,\r\n                ...resolvedValues,\r\n            };\r\n            const markToAnimate = (key) => {\r\n                shouldAnimateType = true;\r\n                if (removedKeys.has(key)) {\r\n                    handledRemovedValues = true;\r\n                    removedKeys.delete(key);\r\n                }\r\n                typeState.needsAnimating[key] = true;\r\n                const motionValue = visualElement.getValue(key);\r\n                if (motionValue)\r\n                    motionValue.liveStyle = false;\r\n            };\r\n            for (const key in allKeys) {\r\n                const next = resolvedValues[key];\r\n                const prev = prevResolvedValues[key];\r\n                // If we've already handled this we can just skip ahead\r\n                if (encounteredKeys.hasOwnProperty(key))\r\n                    continue;\r\n                /**\r\n                 * If the value has changed, we probably want to animate it.\r\n                 */\r\n                let valueHasChanged = false;\r\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\r\n                    valueHasChanged = !shallowCompare(next, prev);\r\n                }\r\n                else {\r\n                    valueHasChanged = next !== prev;\r\n                }\r\n                if (valueHasChanged) {\r\n                    if (next !== undefined && next !== null) {\r\n                        // If next is defined and doesn't equal prev, it needs animating\r\n                        markToAnimate(key);\r\n                    }\r\n                    else {\r\n                        // If it's undefined, it's been removed.\r\n                        removedKeys.add(key);\r\n                    }\r\n                }\r\n                else if (next !== undefined && removedKeys.has(key)) {\r\n                    /**\r\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\r\n                     * been removed by a higher priority\r\n                     */\r\n                    markToAnimate(key);\r\n                }\r\n                else {\r\n                    /**\r\n                     * If it hasn't changed, we add it to the list of protected values\r\n                     * to ensure it doesn't get animated.\r\n                     */\r\n                    typeState.protectedKeys[key] = true;\r\n                }\r\n            }\r\n            /**\r\n             * Update the typeState so next time animateChanges is called we can compare the\r\n             * latest prop and resolvedValues to these.\r\n             */\r\n            typeState.prevProp = prop;\r\n            typeState.prevResolvedValues = resolvedValues;\r\n            /**\r\n             *\r\n             */\r\n            if (typeState.isActive) {\r\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\r\n            }\r\n            if (isInitialRender && visualElement.blockInitialAnimation) {\r\n                shouldAnimateType = false;\r\n            }\r\n            /**\r\n             * If this is an inherited prop we want to skip this animation\r\n             * unless the inherited variants haven't changed on this render.\r\n             */\r\n            const willAnimateViaParent = isInherited && variantDidChange;\r\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues;\r\n            if (shouldAnimateType && needsAnimating) {\r\n                animations.push(...definitionList.map((animation) => ({\r\n                    animation: animation,\r\n                    options: { type },\r\n                })));\r\n            }\r\n        }\r\n        /**\r\n         * If there are some removed value that haven't been dealt with,\r\n         * we need to create a new animation that falls back either to the value\r\n         * defined in the style prop, or the last read value.\r\n         */\r\n        if (removedKeys.size) {\r\n            const fallbackAnimation = {};\r\n            removedKeys.forEach((key) => {\r\n                const fallbackTarget = visualElement.getBaseTarget(key);\r\n                const motionValue = visualElement.getValue(key);\r\n                if (motionValue)\r\n                    motionValue.liveStyle = true;\r\n                // @ts-expect-error - @mattgperry to figure if we should do something here\r\n                fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;\r\n            });\r\n            animations.push({ animation: fallbackAnimation });\r\n        }\r\n        let shouldAnimate = Boolean(animations.length);\r\n        if (isInitialRender &&\r\n            (props.initial === false || props.initial === props.animate) &&\r\n            !visualElement.manuallyAnimateOnMount) {\r\n            shouldAnimate = false;\r\n        }\r\n        isInitialRender = false;\r\n        return shouldAnimate ? animate(animations) : Promise.resolve();\r\n    }\r\n    /**\r\n     * Change whether a certain animation type is active.\r\n     */\r\n    function setActive(type, isActive) {\r\n        var _a;\r\n        // If the active state hasn't changed, we can safely do nothing here\r\n        if (state[type].isActive === isActive)\r\n            return Promise.resolve();\r\n        // Propagate active change to children\r\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\r\n        state[type].isActive = isActive;\r\n        const animations = animateChanges(type);\r\n        for (const key in state) {\r\n            state[key].protectedKeys = {};\r\n        }\r\n        return animations;\r\n    }\r\n    return {\r\n        animateChanges,\r\n        setActive,\r\n        setAnimateFunction,\r\n        getState: () => state,\r\n        reset: () => {\r\n            state = createState();\r\n            isInitialRender = true;\r\n        },\r\n    };\r\n}\r\nfunction checkVariantsDidChange(prev, next) {\r\n    if (typeof next === \"string\") {\r\n        return next !== prev;\r\n    }\r\n    else if (Array.isArray(next)) {\r\n        return !shallowCompare(next, prev);\r\n    }\r\n    return false;\r\n}\r\nfunction createTypeState(isActive = false) {\r\n    return {\r\n        isActive,\r\n        protectedKeys: {},\r\n        needsAnimating: {},\r\n        prevResolvedValues: {},\r\n    };\r\n}\r\nfunction createState() {\r\n    return {\r\n        animate: createTypeState(true),\r\n        whileInView: createTypeState(),\r\n        whileHover: createTypeState(),\r\n        whileTap: createTypeState(),\r\n        whileDrag: createTypeState(),\r\n        whileFocus: createTypeState(),\r\n        exit: createTypeState(),\r\n    };\r\n}\r\n\r\nexport { checkVariantsDidChange, createAnimationState };\r\n","import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\r\nimport { isVariantLabel } from './is-variant-label.mjs';\r\nimport { variantProps } from './variant-props.mjs';\r\n\r\nfunction isControllingVariants(props) {\r\n    return (isAnimationControls(props.animate) ||\r\n        variantProps.some((name) => isVariantLabel(props[name])));\r\n}\r\nfunction isVariantNode(props) {\r\n    return Boolean(isControllingVariants(props) || props.variants);\r\n}\r\n\r\nexport { isControllingVariants, isVariantNode };\r\n","/**\r\n * Decides if the supplied variable is variant label\r\n */\r\nfunction isVariantLabel(v) {\r\n    return typeof v === \"string\" || Array.isArray(v);\r\n}\r\n\r\nexport { isVariantLabel };\r\n","import { resolveVariantFromProps } from './resolve-variants.mjs';\r\n\r\nfunction resolveVariant(visualElement, definition, custom) {\r\n    const props = visualElement.getProps();\r\n    return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);\r\n}\r\n\r\nexport { resolveVariant };\r\n","function getValueState(visualElement) {\r\n    const state = [{}, {}];\r\n    visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {\r\n        state[0][key] = value.get();\r\n        state[1][key] = value.getVelocity();\r\n    });\r\n    return state;\r\n}\r\nfunction resolveVariantFromProps(props, definition, custom, visualElement) {\r\n    /**\r\n     * If the variant definition is a function, resolve.\r\n     */\r\n    if (typeof definition === \"function\") {\r\n        const [current, velocity] = getValueState(visualElement);\r\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\r\n    }\r\n    /**\r\n     * If the variant definition is a variant label, or\r\n     * the function returned a variant label, resolve.\r\n     */\r\n    if (typeof definition === \"string\") {\r\n        definition = props.variants && props.variants[definition];\r\n    }\r\n    /**\r\n     * At this point we've resolved both functions and variant labels,\r\n     * but the resolved variant label might itself have been a function.\r\n     * If so, resolve. This can only have returned a valid target object.\r\n     */\r\n    if (typeof definition === \"function\") {\r\n        const [current, velocity] = getValueState(visualElement);\r\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\r\n    }\r\n    return definition;\r\n}\r\n\r\nexport { resolveVariantFromProps };\r\n","import { resolveFinalValueInKeyframes } from '../../utils/resolve-value.mjs';\r\nimport { motionValue } from '../../value/index.mjs';\r\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\r\n\r\n/**\r\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\r\n * it doesn't exist.\r\n */\r\nfunction setMotionValue(visualElement, key, value) {\r\n    if (visualElement.hasValue(key)) {\r\n        visualElement.getValue(key).set(value);\r\n    }\r\n    else {\r\n        visualElement.addValue(key, motionValue(value));\r\n    }\r\n}\r\nfunction setTarget(visualElement, definition) {\r\n    const resolved = resolveVariant(visualElement, definition);\r\n    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};\r\n    target = { ...target, ...transitionEnd };\r\n    for (const key in target) {\r\n        const value = resolveFinalValueInKeyframes(target[key]);\r\n        setMotionValue(visualElement, key, value);\r\n    }\r\n}\r\n\r\nexport { setTarget };\r\n","const variantPriorityOrder = [\r\n    \"animate\",\r\n    \"whileInView\",\r\n    \"whileFocus\",\r\n    \"whileHover\",\r\n    \"whileTap\",\r\n    \"whileDrag\",\r\n    \"exit\",\r\n];\r\nconst variantProps = [\"initial\", ...variantPriorityOrder];\r\n\r\nexport { variantPriorityOrder, variantProps };\r\n","const MotionGlobalConfig = {\r\n    skipAnimations: false,\r\n    useManualTiming: false,\r\n};\r\n\r\nexport { MotionGlobalConfig };\r\n","function addUniqueItem(arr, item) {\r\n    if (arr.indexOf(item) === -1)\r\n        arr.push(item);\r\n}\r\nfunction removeItem(arr, item) {\r\n    const index = arr.indexOf(item);\r\n    if (index > -1)\r\n        arr.splice(index, 1);\r\n}\r\n// Adapted from array-move\r\nfunction moveItem([...arr], fromIndex, toIndex) {\r\n    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\r\n    if (startIndex >= 0 && startIndex < arr.length) {\r\n        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\r\n        const [item] = arr.splice(fromIndex, 1);\r\n        arr.splice(endIndex, 0, item);\r\n    }\r\n    return arr;\r\n}\r\n\r\nexport { addUniqueItem, moveItem, removeItem };\r\n","const clamp = (min, max, v) => {\r\n    if (v > max)\r\n        return max;\r\n    if (v < min)\r\n        return min;\r\n    return v;\r\n};\r\n\r\nexport { clamp };\r\n","const distance = (a, b) => Math.abs(a - b);\r\nfunction distance2D(a, b) {\r\n    // Multi-dimensional\r\n    const xDelta = distance(a.x, b.x);\r\n    const yDelta = distance(a.y, b.y);\r\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\r\n}\r\n\r\nexport { distance, distance2D };\r\n","// Fixes https://github.com/motiondivision/motion/issues/2270\r\nconst getContextWindow = ({ current }) => {\r\n    return current ? current.ownerDocument.defaultView : null;\r\n};\r\n\r\nexport { getContextWindow };\r\n","import { invariant, noop, progress } from 'motion-utils';\r\nimport { clamp } from './clamp.mjs';\r\nimport { mix } from './mix/index.mjs';\r\nimport { pipe } from './pipe.mjs';\r\n\r\nfunction createMixers(output, ease, customMixer) {\r\n    const mixers = [];\r\n    const mixerFactory = customMixer || mix;\r\n    const numMixers = output.length - 1;\r\n    for (let i = 0; i < numMixers; i++) {\r\n        let mixer = mixerFactory(output[i], output[i + 1]);\r\n        if (ease) {\r\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\r\n            mixer = pipe(easingFunction, mixer);\r\n        }\r\n        mixers.push(mixer);\r\n    }\r\n    return mixers;\r\n}\r\n/**\r\n * Create a function that maps from a numerical input array to a generic output array.\r\n *\r\n * Accepts:\r\n *   - Numbers\r\n *   - Colors (hex, hsl, hsla, rgb, rgba)\r\n *   - Complex (combinations of one or more numbers or strings)\r\n *\r\n * ```jsx\r\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\r\n *\r\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\r\n * ```\r\n *\r\n * TODO Revist this approach once we've moved to data models for values,\r\n * probably not needed to pregenerate mixer functions.\r\n *\r\n * @public\r\n */\r\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\r\n    const inputLength = input.length;\r\n    invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\r\n    /**\r\n     * If we're only provided a single input, we can just make a function\r\n     * that returns the output.\r\n     */\r\n    if (inputLength === 1)\r\n        return () => output[0];\r\n    if (inputLength === 2 && output[0] === output[1])\r\n        return () => output[1];\r\n    const isZeroDeltaRange = input[0] === input[1];\r\n    // If input runs highest -> lowest, reverse both arrays\r\n    if (input[0] > input[inputLength - 1]) {\r\n        input = [...input].reverse();\r\n        output = [...output].reverse();\r\n    }\r\n    const mixers = createMixers(output, ease, mixer);\r\n    const numMixers = mixers.length;\r\n    const interpolator = (v) => {\r\n        if (isZeroDeltaRange && v < input[0])\r\n            return output[0];\r\n        let i = 0;\r\n        if (numMixers > 1) {\r\n            for (; i < input.length - 2; i++) {\r\n                if (v < input[i + 1])\r\n                    break;\r\n            }\r\n        }\r\n        const progressInRange = progress(input[i], input[i + 1], v);\r\n        return mixers[i](progressInRange);\r\n    };\r\n    return isClamp\r\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\r\n        : interpolator;\r\n}\r\n\r\nexport { interpolate };\r\n","const isBrowser = typeof window !== \"undefined\";\r\n\r\nexport { isBrowser };\r\n","/**\r\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\r\n */\r\nconst isNumericalString = (v) => /^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(v);\r\n\r\nexport { isNumericalString };\r\n","function isRefObject(ref) {\r\n    return (ref &&\r\n        typeof ref === \"object\" &&\r\n        Object.prototype.hasOwnProperty.call(ref, \"current\"));\r\n}\r\n\r\nexport { isRefObject };\r\n","/**\r\n * Check if the value is a zero value string like \"0px\" or \"0%\"\r\n */\r\nconst isZeroValueString = (v) => /^0[^.\\s]+$/u.test(v);\r\n\r\nexport { isZeroValueString };\r\n","// Adapted from https://gist.github.com/mjackson/5311256\r\nfunction hueToRgb(p, q, t) {\r\n    if (t < 0)\r\n        t += 1;\r\n    if (t > 1)\r\n        t -= 1;\r\n    if (t < 1 / 6)\r\n        return p + (q - p) * 6 * t;\r\n    if (t < 1 / 2)\r\n        return q;\r\n    if (t < 2 / 3)\r\n        return p + (q - p) * (2 / 3 - t) * 6;\r\n    return p;\r\n}\r\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\r\n    hue /= 360;\r\n    saturation /= 100;\r\n    lightness /= 100;\r\n    let red = 0;\r\n    let green = 0;\r\n    let blue = 0;\r\n    if (!saturation) {\r\n        red = green = blue = lightness;\r\n    }\r\n    else {\r\n        const q = lightness < 0.5\r\n            ? lightness * (1 + saturation)\r\n            : lightness + saturation - lightness * saturation;\r\n        const p = 2 * lightness - q;\r\n        red = hueToRgb(p, q, hue + 1 / 3);\r\n        green = hueToRgb(p, q, hue);\r\n        blue = hueToRgb(p, q, hue - 1 / 3);\r\n    }\r\n    return {\r\n        red: Math.round(red * 255),\r\n        green: Math.round(green * 255),\r\n        blue: Math.round(blue * 255),\r\n        alpha,\r\n    };\r\n}\r\n\r\nexport { hslaToRgba };\r\n","function mixImmediate(a, b) {\r\n    return (p) => (p > 0 ? b : a);\r\n}\r\n\r\nexport { mixImmediate };\r\n","import { mixNumber } from './number.mjs';\r\nimport { warning } from 'motion-utils';\r\nimport { hslaToRgba } from '../hsla-to-rgba.mjs';\r\nimport { hex } from '../../value/types/color/hex.mjs';\r\nimport { rgba } from '../../value/types/color/rgba.mjs';\r\nimport { hsla } from '../../value/types/color/hsla.mjs';\r\nimport { mixImmediate } from './immediate.mjs';\r\n\r\n// Linear color space blending\r\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\r\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\r\nconst mixLinearColor = (from, to, v) => {\r\n    const fromExpo = from * from;\r\n    const expo = v * (to * to - fromExpo) + fromExpo;\r\n    return expo < 0 ? 0 : Math.sqrt(expo);\r\n};\r\nconst colorTypes = [hex, rgba, hsla];\r\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\r\nfunction asRGBA(color) {\r\n    const type = getColorType(color);\r\n    warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);\r\n    if (!Boolean(type))\r\n        return false;\r\n    let model = type.parse(color);\r\n    if (type === hsla) {\r\n        // TODO Remove this cast - needed since Motion's stricter typing\r\n        model = hslaToRgba(model);\r\n    }\r\n    return model;\r\n}\r\nconst mixColor = (from, to) => {\r\n    const fromRGBA = asRGBA(from);\r\n    const toRGBA = asRGBA(to);\r\n    if (!fromRGBA || !toRGBA) {\r\n        return mixImmediate(from, to);\r\n    }\r\n    const blended = { ...fromRGBA };\r\n    return (v) => {\r\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\r\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\r\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\r\n        blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);\r\n        return rgba.transform(blended);\r\n    };\r\n};\r\n\r\nexport { mixColor, mixLinearColor };\r\n","const invisibleValues = new Set([\"none\", \"hidden\"]);\r\n/**\r\n * Returns a function that, when provided a progress value between 0 and 1,\r\n * will return the \"none\" or \"hidden\" string only when the progress is that of\r\n * the origin or target.\r\n */\r\nfunction mixVisibility(origin, target) {\r\n    if (invisibleValues.has(origin)) {\r\n        return (p) => (p <= 0 ? origin : target);\r\n    }\r\n    else {\r\n        return (p) => (p >= 1 ? target : origin);\r\n    }\r\n}\r\n\r\nexport { invisibleValues, mixVisibility };\r\n","import { mixNumber as mixNumber$1 } from './number.mjs';\r\nimport { mixColor } from './color.mjs';\r\nimport { pipe } from '../pipe.mjs';\r\nimport { warning } from 'motion-utils';\r\nimport { color } from '../../value/types/color/index.mjs';\r\nimport { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';\r\nimport { isCSSVariableToken } from '../../render/dom/utils/is-css-variable.mjs';\r\nimport { invisibleValues, mixVisibility } from './visibility.mjs';\r\nimport { mixImmediate } from './immediate.mjs';\r\n\r\nfunction mixNumber(a, b) {\r\n    return (p) => mixNumber$1(a, b, p);\r\n}\r\nfunction getMixer(a) {\r\n    if (typeof a === \"number\") {\r\n        return mixNumber;\r\n    }\r\n    else if (typeof a === \"string\") {\r\n        return isCSSVariableToken(a)\r\n            ? mixImmediate\r\n            : color.test(a)\r\n                ? mixColor\r\n                : mixComplex;\r\n    }\r\n    else if (Array.isArray(a)) {\r\n        return mixArray;\r\n    }\r\n    else if (typeof a === \"object\") {\r\n        return color.test(a) ? mixColor : mixObject;\r\n    }\r\n    return mixImmediate;\r\n}\r\nfunction mixArray(a, b) {\r\n    const output = [...a];\r\n    const numValues = output.length;\r\n    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\r\n    return (p) => {\r\n        for (let i = 0; i < numValues; i++) {\r\n            output[i] = blendValue[i](p);\r\n        }\r\n        return output;\r\n    };\r\n}\r\nfunction mixObject(a, b) {\r\n    const output = { ...a, ...b };\r\n    const blendValue = {};\r\n    for (const key in output) {\r\n        if (a[key] !== undefined && b[key] !== undefined) {\r\n            blendValue[key] = getMixer(a[key])(a[key], b[key]);\r\n        }\r\n    }\r\n    return (v) => {\r\n        for (const key in blendValue) {\r\n            output[key] = blendValue[key](v);\r\n        }\r\n        return output;\r\n    };\r\n}\r\nfunction matchOrder(origin, target) {\r\n    var _a;\r\n    const orderedOrigin = [];\r\n    const pointers = { color: 0, var: 0, number: 0 };\r\n    for (let i = 0; i < target.values.length; i++) {\r\n        const type = target.types[i];\r\n        const originIndex = origin.indexes[type][pointers[type]];\r\n        const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;\r\n        orderedOrigin[i] = originValue;\r\n        pointers[type]++;\r\n    }\r\n    return orderedOrigin;\r\n}\r\nconst mixComplex = (origin, target) => {\r\n    const template = complex.createTransformer(target);\r\n    const originStats = analyseComplexValue(origin);\r\n    const targetStats = analyseComplexValue(target);\r\n    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&\r\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\r\n        originStats.indexes.number.length >= targetStats.indexes.number.length;\r\n    if (canInterpolate) {\r\n        if ((invisibleValues.has(origin) &&\r\n            !targetStats.values.length) ||\r\n            (invisibleValues.has(target) &&\r\n                !originStats.values.length)) {\r\n            return mixVisibility(origin, target);\r\n        }\r\n        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\r\n    }\r\n    else {\r\n        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\r\n        return mixImmediate(origin, target);\r\n    }\r\n};\r\n\r\nexport { getMixer, mixArray, mixComplex, mixObject };\r\n","import { getMixer } from './complex.mjs';\r\nimport { mixNumber } from './number.mjs';\r\n\r\nfunction mix(from, to, p) {\r\n    if (typeof from === \"number\" &&\r\n        typeof to === \"number\" &&\r\n        typeof p === \"number\") {\r\n        return mixNumber(from, to, p);\r\n    }\r\n    const mixer = getMixer(from);\r\n    return mixer(from, to);\r\n}\r\n\r\nexport { mix };\r\n","/*\r\n  Value in range from progress\r\n\r\n  Given a lower limit and an upper limit, we return the value within\r\n  that range as expressed by progress (usually a number from 0 to 1)\r\n\r\n  So progress = 0.5 would change\r\n\r\n  from -------- to\r\n\r\n  to\r\n\r\n  from ---- to\r\n\r\n  E.g. from = 10, to = 20, progress = 0.5 => 15\r\n\r\n  @param [number]: Lower limit of range\r\n  @param [number]: Upper limit of range\r\n  @param [number]: The progress between lower and upper limits expressed 0-1\r\n  @return [number]: Value as calculated from progress within range (not limited within range)\r\n*/\r\nconst mixNumber = (from, to, progress) => {\r\n    return from + (to - from) * progress;\r\n};\r\n\r\nexport { mixNumber };\r\n","import { fillOffset } from './fill.mjs';\r\n\r\nfunction defaultOffset(arr) {\r\n    const offset = [0];\r\n    fillOffset(offset, arr.length - 1);\r\n    return offset;\r\n}\r\n\r\nexport { defaultOffset };\r\n","import { progress } from 'motion-utils';\r\nimport { mixNumber } from '../mix/number.mjs';\r\n\r\nfunction fillOffset(offset, remaining) {\r\n    const min = offset[offset.length - 1];\r\n    for (let i = 1; i <= remaining; i++) {\r\n        const offsetProgress = progress(0, remaining, i);\r\n        offset.push(mixNumber(min, 1, offsetProgress));\r\n    }\r\n}\r\n\r\nexport { fillOffset };\r\n","function convertOffsetToTimes(offset, duration) {\r\n    return offset.map((o) => o * duration);\r\n}\r\n\r\nexport { convertOffsetToTimes };\r\n","/**\r\n * Pipe\r\n * Compose other transformers to run linearily\r\n * pipe(min(20), max(40))\r\n * @param  {...functions} transformers\r\n * @return {function}\r\n */\r\nconst combineFunctions = (a, b) => (v) => b(a(v));\r\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\r\n\r\nexport { pipe };\r\n","import { isKeyframesTarget } from '../animation/utils/is-keyframes-target.mjs';\r\n\r\nconst isCustomValue = (v) => {\r\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\r\n};\r\nconst resolveFinalValueInKeyframes = (v) => {\r\n    // TODO maybe throw if v.length - 1 is placeholder token?\r\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\r\n};\r\n\r\nexport { isCustomValue, resolveFinalValueInKeyframes };\r\n","import { addUniqueItem, removeItem } from './array.mjs';\r\n\r\nclass SubscriptionManager {\r\n    constructor() {\r\n        this.subscriptions = [];\r\n    }\r\n    add(handler) {\r\n        addUniqueItem(this.subscriptions, handler);\r\n        return () => removeItem(this.subscriptions, handler);\r\n    }\r\n    notify(a, b, c) {\r\n        const numSubscriptions = this.subscriptions.length;\r\n        if (!numSubscriptions)\r\n            return;\r\n        if (numSubscriptions === 1) {\r\n            /**\r\n             * If there's only a single handler we can just call it without invoking a loop.\r\n             */\r\n            this.subscriptions[0](a, b, c);\r\n        }\r\n        else {\r\n            for (let i = 0; i < numSubscriptions; i++) {\r\n                /**\r\n                 * Check whether the handler exists before firing as it's possible\r\n                 * the subscriptions were modified during this loop running.\r\n                 */\r\n                const handler = this.subscriptions[i];\r\n                handler && handler(a, b, c);\r\n            }\r\n        }\r\n    }\r\n    getSize() {\r\n        return this.subscriptions.length;\r\n    }\r\n    clear() {\r\n        this.subscriptions.length = 0;\r\n    }\r\n}\r\n\r\nexport { SubscriptionManager };\r\n","import { useRef } from 'react';\r\n\r\n/**\r\n * Creates a constant value over the lifecycle of a component.\r\n *\r\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\r\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\r\n * you can ensure that initialisers don't execute twice or more.\r\n */\r\nfunction useConstant(init) {\r\n    const ref = useRef(null);\r\n    if (ref.current === null) {\r\n        ref.current = init();\r\n    }\r\n    return ref.current;\r\n}\r\n\r\nexport { useConstant };\r\n","const instantAnimationState = {\r\n    current: false,\r\n};\r\n\r\nexport { instantAnimationState };\r\n","import { useLayoutEffect, useEffect } from 'react';\r\nimport { isBrowser } from './is-browser.mjs';\r\n\r\nconst useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;\r\n\r\nexport { useIsomorphicLayoutEffect };\r\n","/*\r\n  Convert velocity into velocity per second\r\n\r\n  @param [number]: Unit per frame\r\n  @param [number]: Frame duration in ms\r\n*/\r\nfunction velocityPerSecond(velocity, frameDuration) {\r\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\r\n}\r\n\r\nexport { velocityPerSecond };\r\n"],"names":["convertBoundingBoxToBox","top","left","right","bottom","x","min","max","y","convertBoxToBoundingBox","transformBoxPoints","point","transformPoint","topLeft","bottomRight","scalePoint","scale","originPoint","applyPointDelta","translate","boxScale","undefined","applyAxisDelta","axis","applyBoxDelta","box","TREE_SCALE_SNAP_MIN","TREE_SCALE_SNAP_MAX","applyTreeDeltas","treeScale","treePath","isSharedTransition","treeLength","length","node","delta","i","projectionDelta","visualElement","options","props","style","display","layoutScroll","scroll","root","transformBox","offset","latestValues","translateAxis","distance","transformAxis","axisTranslate","axisScale","axisOrigin","transform","scaleX","originX","scaleY","originY","SCALE_MIN","SCALE_MAX","TRANSLATE_MIN","TRANSLATE_MAX","calcLength","isNear","value","target","maxDistance","Math","abs","calcAxisDelta","source","origin","isNaN","calcBoxDelta","calcRelativeAxis","relative","parent","calcRelativeBox","calcRelativeAxisPosition","layout","calcRelativePosition","createDelta","createBox","compareByDepth","a","b","depth","FlatTree","constructor","this","children","isDirty","add","child","remove","forEach","callback","sort","delay","timeout","start","now","checkElapsed","timestamp","elapsed","read","borders","numBorders","asNumber","parseFloat","isPx","px","test","getRadius","values","radiusName","borderRadius","easeCrossfadeIn","compress","circ","easeCrossfadeOut","noop","easing","p","progress","copyAxisInto","originAxis","copyBoxInto","originBox","copyAxisDeltaInto","originDelta","removePointDelta","removeAxisTransforms","transforms","key","scaleKey","originKey","sourceAxis","removeAxisDelta","xKeys","yKeys","removeBoxTransforms","sourceBox","isAxisDeltaZero","isDeltaZero","axisEquals","axisEqualsRounded","round","boxEqualsRounded","aspectRatio","axisDeltaEquals","NodeStack","members","scheduleRender","prevLead","lead","promote","relegate","indexOfNode","findIndex","member","isPresent","preserveFollowOpacity","show","instance","resumeFrom","preserveOpacity","snapshot","animationValues","isUpdating","isLayoutDirty","crossfade","hide","exitAnimationComplete","resumingFrom","onExitComplete","removeLeadSnapshot","metrics","type","totalNodes","resolvedTargetDeltas","recalculatedProjection","isDebug","window","MotionDebug","transformAxes","hiddenVisibility","visibility","id","resetDistortingTransform","sharedAnimationValues","setStaticValue","cancelTreeOptimisedTransformAnimations","projectionNode","hasCheckedOptimisedAppear","appearId","MotionHasOptimisedAnimation","layoutId","MotionCancelOptimisedAnimation","createProjectionNode","attachResizeListener","defaultParent","measureScroll","checkIsScrollRoot","resetTransform","animationId","Set","isTreeAnimating","isAnimationBlocked","isProjectionDirty","isSharedProjectionDirty","isTransformDirty","updateManuallyBlocked","updateBlockedByResize","isSVG","needsReset","shouldResetTransform","eventHandlers","Map","hasTreeAnimated","updateScheduled","scheduleUpdate","update","projectionUpdateScheduled","checkUpdateFailed","clearAllSnapshots","updateProjection","nodes","propagateDirtyNodes","resolveTargetDelta","calcProjection","cleanDirtyNodes","record","resolvedRelativeTargetAt","hasProjected","isVisible","animationProgress","sharedNodes","path","addEventListener","name","handler","has","set","get","notifyListeners","args","subscriptionManager","notify","hasListeners","mount","element","SVGElement","tagName","current","cancelDelay","resizeUnblockUpdate","hasAnimatedSinceResize","finishAnimation","registerSharedNode","animate","hasLayoutChanged","hasRelativeTargetChanged","newLayout","isTreeAnimationBlocked","relativeTarget","layoutTransition","transition","getDefaultTransition","defaultLayoutTransition","onLayoutAnimationStart","onLayoutAnimationComplete","getProps","targetChanged","targetLayout","hasOnlyRelativeTargetChanged","layoutRoot","currentAnimation","setAnimationOrigin","animationOptions","onPlay","onComplete","shouldReduceMotion","startAnimation","isLead","unmount","willUpdate","stack","getStack","delete","blockUpdate","unblockUpdate","isUpdateBlocked","startUpdate","resetSkewAndRotation","getTransformTemplate","transformTemplate","shouldNotifyListeners","updateScroll","prevTransformTemplateValue","updateSnapshot","clearMeasurements","clearIsLayoutDirty","resetTransformStyle","updateLayout","notifyLayoutUpdate","clamp","isProcessing","process","preRender","render","didUpdate","microtask","clearSnapshot","removeLeadSnapshots","scheduleUpdateProjection","scheduleCheckAfterUnmount","postRender","measure","alwaysMeasureLayout","prevLayout","layoutCorrected","layoutBox","phase","needsMeasurement","Boolean","isRoot","wasRoot","isResetRequested","hasProjection","transformTemplateValue","transformTemplateHasChanged","removeTransform","pageBox","measurePageBox","removeElementScroll","roundAxis","measuredBox","_a","measureViewportBox","some","checkNodeWasScrollRoot","boxWithoutScroll","applyTransform","transformOnly","withTransforms","boxWithoutTransform","setTargetDelta","targetDelta","setOptions","forceRelativeParentToResolveTarget","relativeParent","forceRecalculation","getLead","isShared","attemptToResolveRelativeTarget","getClosestProjectingParent","relativeTargetOrigin","targetWithTransforms","isProjecting","canSkip","pendingAnimation","prevTreeScaleX","prevTreeScaleY","prevProjectionDelta","createProjectionDeltas","notifyAll","projectionDeltaWithTransform","snapshotLatestValues","mixedValues","relativeLayout","isSharedLayoutAnimation","isOnlyMember","shouldCrossfadeOpacity","hasOpacityCrossfade","prevRelativeTarget","mixTargetDelta","latest","output","from","to","mixAxisDelta","mixAxis","follow","opacity","opacityExit","borderLabel","followRadius","leadRadius","rotate","mixValues","stop","onUpdate","completeAnimation","applyTransformsToTarget","shouldAnimatePositionOnly","animationType","xLength","yLength","config","initialPromotionConfig","shouldPreserveFollowOpacity","getPrevLead","hasDistortingTransform","z","rotateX","rotateY","rotateZ","skewX","skewY","resetValues","getProjectionStyles","styleProp","_b","styles","pointerEvents","emptyStyles","valuesToRender","latestTransform","xTranslate","yTranslate","zTranslate","transformPerspective","elementScaleX","elementScaleY","buildProjectionTransform","transformOrigin","correct","applyTo","corrected","num","resetTree","clear","measuredLayout","axisSnapshot","layoutDelta","visualDelta","parentSnapshot","parentLayout","relativeSnapshot","onBeforeLayoutMeasure","duration","ease","userAgentContains","string","navigator","userAgent","toLowerCase","includes","roundPoint","DocumentProjectionNode","ref","document","documentElement","scrollLeft","body","scrollTop","rootProjectionNode","HTMLProjectionNode","documentNode","getComputedStyle","position","globalProjectionState","hasEverUpdated","pixelsToPercent","pixels","correctBorderRadius","correctBoxShadow","original","shadow","parse","template","createTransformer","xScale","yScale","averageScale","scaleCorrectors","addScaleCorrector","correctors","Object","assign","eachAxis","isIdentityScale","hasScale","hasTransform","has2DTranslate","is2DTranslate","getBoundingClientRect","transformPagePoint","viewportBox","createDOMMotionComponentProxy","componentFactory","Proxy","componentCache","_target","lowercaseSVGElements","isSVGComponent","Component","indexOf","getValueAsType","translateAlias","numTransforms","buildHTMLStyles","state","vars","hasTransformOrigin","valueAsType","number","startsWith","transformString","transformIsDefault","valueIsDefault","trim","buildTransform","originZ","dashKeys","array","camelKeys","calcOrigin","size","buildSVGAttrs","attrX","attrY","attrScale","pathLength","pathSpacing","pathOffset","isSVGTag","viewBox","attrs","dimensions","width","height","calcSVGTransformOrigin","spacing","useDashCase","keys","buildSVGPath","createHtmlRenderState","createSvgRenderState","tag","renderHTML","projection","setProperty","camelCaseAttributes","renderSVG","renderState","_styleProp","setAttribute","scrapeMotionValuesFromProps","prevProps","newValues","getValue","liveStyle","charAt","toUpperCase","substring","layoutProps","svgMotionConfig","useVisualState","createRenderState","drag","needsMeasure","getBBox","e","updateSVGDimensions","htmlMotionConfig","copyRawValuesOnly","useStyle","visualState","useMemo","useInitialMotionValues","useHTMLProps","htmlProps","dragListener","draggable","userSelect","WebkitUserSelect","WebkitTouchCallout","touchAction","tabIndex","onTap","onTapStart","whileTap","shouldForward","isValidProp","require","default","useSVGProps","_isStatic","visualProps","rawStyles","createUseRender","forwardMotionProps","isStatic","filteredProps","isDom","filterProps","elementProps","Fragment","renderedChildren","createElement","createMotionComponentFactory","preloadedFeatures","createVisualElement","useRender","prefersReducedMotion","hasReducedMotionListener","valueTypes","color","complex","visualElementStore","WeakMap","propEventHandlers","VisualElement","_props","_prevProps","_visualElement","presenceContext","reducedMotionConfig","blockInitialAnimation","isVariantNode","isControllingVariants","KeyframeResolver","features","valueSubscriptions","prevMotionValues","events","propEventSubscriptions","notifyUpdate","triggerBuild","renderInstance","renderScheduledAt","baseTarget","initialValues","initial","variantChildren","manuallyAnimateOnMount","willChange","initialMotionValues","removeFromVariantTree","addVariantChild","bindToMotionValue","matchMedia","motionMediaQuery","setReducedMotionPreferences","matches","addListener","initPrefersReducedMotion","feature","isMounted","valueIsTransform","removeOnChange","on","latestValue","removeOnRenderRequest","removeSyncCheck","MotionCheckAppearSync","owner","sortNodePosition","other","sortInstanceNodePosition","updateFeatures","featureDefinition","isEnabled","Feature","FeatureConstructor","build","measureInstanceViewportBox","getStaticValue","prevPresenceContext","listener","next","prev","nextValue","prevValue","addValue","hasValue","existingValue","jump","hasAnimated","removeValue","updateMotionValuesFromProps","handleChildMotionValue","getVariant","variants","getTransformPagePoint","getClosestVariantNode","closestVariantNode","unsubscribe","removeValueFromRenderState","defaultValue","readValue","getBaseTargetFromProps","readValueFromInstance","v","find","setBaseTarget","getBaseTarget","valueFromInitial","variant","custom","eventName","DOMVisualElement","super","arguments","DOMKeyframesResolver","compareDocumentPosition","childSubscription","textContent","HTMLVisualElement","defaultType","computedStyle","getPropertyValue","m","SVGVisualElement","getAttribute","createDomVisualElement","allowProjection","animations","invalidTemplates","splitCSSVariableRegex","getVariableValue","token","fallback","match","exec","token1","token2","parseCSSVariable","resolved","trimmed","unresolvedKeyframes","motionValue","readKeyframes","keyframe","finalKeyframe","resolveNoneKeyframes","originType","targetType","noneKeyframeIndexes","push","animatableTemplate","noneIndex","makeNoneKeyframesAnimatable","measureInitialState","suspendedScrollY","pageYOffset","measuredOrigin","measureKeyframe","measureEndState","finalKeyframeIndex","removedTransforms","unsetTransformName","unsetTransformValue","camelToDash","str","replace","checkStringStartsWith","isCSSVariableName","startsAsVariableToken","isCSSVariableToken","singleCssVariableRegex","split","isNumOrPxType","getPosFromMatrix","matrix","pos","getTranslateFromMatrix","pos2","pos3","_bbox","matrix3d","transformKeys","nonTranslationalTransformKeys","filter","removeNonTranslationalTransform","positionalValues","paddingLeft","paddingRight","paddingTop","paddingBottom","translateX","translateY","getAnimatableNone","defaultValueType","defaultValueTypes","backgroundColor","outlineColor","fill","stroke","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","WebkitFilter","getDefaultValueType","dimensionValueTypes","vw","vh","findDimensionValueType","browserNumberValueTypes","borderWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","maxWidth","maxHeight","padding","margin","marginTop","marginRight","marginBottom","marginLeft","backgroundPositionX","backgroundPositionY","transformValueTypes","scaleZ","skew","translateZ","perspective","numberValueTypes","zIndex","fillOpacity","strokeOpacity","numOctaves","testValueType","positionalKeys","transformPropOrder","transformProps","toResolve","isScheduled","anyNeedsMeasurement","measureAllKeyframes","resolversToMeasure","Array","resolver","elementsToMeasure","map","transformsToRestore","restore","scrollTo","complete","readAllKeyframes","flushKeyframeResolvers","isAsync","isComplete","scheduleResolve","resolveKeyframes","currentValue","valueAsRead","setFinalKeyframe","renderEndStyles","cancel","resume","shallowCompare","isArray","prevLength","numVariantProps","getVariantContext","context","prop","reversePriorityOrder","reverse","numAnimationTypes","createAnimationState","Promise","all","animation","animateList","createState","isInitialRender","buildResolvedTypeValues","acc","definition","transitionEnd","animateChanges","changedActiveType","removedKeys","encounteredKeys","removedVariantIndex","Infinity","typeState","propIsVariant","activeDelta","isActive","isInherited","protectedKeys","prevProp","variantDidChange","checkVariantsDidChange","shouldAnimateType","handledRemovedValues","definitionList","resolvedValues","reduce","prevResolvedValues","allKeys","markToAnimate","needsAnimating","hasOwnProperty","valueHasChanged","fallbackAnimation","fallbackTarget","shouldAnimate","resolve","setActive","animationState","setAnimateFunction","makeAnimator","getState","reset","createTypeState","whileInView","whileHover","whileDrag","whileFocus","exit","isVariantLabel","resolveVariant","getValueState","getVelocity","resolveVariantFromProps","velocity","setMotionValue","setTarget","variantPriorityOrder","variantProps","MotionGlobalConfig","skipAnimations","useManualTiming","addUniqueItem","arr","item","removeItem","index","splice","distance2D","xDelta","yDelta","sqrt","getContextWindow","ownerDocument","defaultView","interpolate","input","isClamp","mixer","inputLength","isZeroDeltaRange","mixers","customMixer","mixerFactory","numMixers","easingFunction","createMixers","interpolator","progressInRange","isBrowser","isNumericalString","isRefObject","prototype","call","isZeroValueString","hueToRgb","q","t","mixImmediate","mixLinearColor","fromExpo","expo","colorTypes","hex","rgba","hsla","asRGBA","model","hue","saturation","lightness","alpha","red","green","blue","hslaToRgba","mixColor","fromRGBA","toRGBA","blended","invisibleValues","mixNumber","getMixer","mixComplex","mixArray","mixObject","numValues","blendValue","originStats","targetStats","indexes","var","mixVisibility","pipe","orderedOrigin","pointers","types","originIndex","originValue","matchOrder","mix","defaultOffset","remaining","offsetProgress","fillOffset","convertOffsetToTimes","o","combineFunctions","transformers","isCustomValue","toValue","resolveFinalValueInKeyframes","SubscriptionManager","subscriptions","c","numSubscriptions","getSize","useConstant","init","useRef","instantAnimationState","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","velocityPerSecond","frameDuration"],"sourceRoot":""}