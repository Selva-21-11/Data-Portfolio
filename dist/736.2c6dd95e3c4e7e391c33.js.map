{"version":3,"file":"736.2c6dd95e3c4e7e391c33.js","mappings":"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","sources":["webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animate/single-value.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/utils/can-animate.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/spring/defaults.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/inertia.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/drivers/driver-frameloop.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/utils/accelerated-values.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/waapi/utils/supports-waapi.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/animators/waapi/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-transition-defined.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/animation/utils/is-none.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/LazyContext.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/MotionContext/create.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/MotionContext/index.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/PresenceContext.mjs","webpack://my-3d-portfolio/./node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs"],"sourcesContent":["import { motionValue } from '../../value/index.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { animateMotionValue } from '../interfaces/motion-value.mjs';\n\nfunction animateSingleValue(value, keyframes, options) {\n    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\n    motionValue$1.start(animateMotionValue(\"\", motionValue$1, keyframes, options));\n    return motionValue$1.animation;\n}\n\nexport { animateSingleValue };\n","import { complex } from '../../value/types/complex/index.mjs';\n\n/**\n * Check if a value is animatable. Examples:\n *\n * ✅: 100, \"100px\", \"#fff\"\n * ❌: \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nconst isAnimatable = (value, name) => {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (name === \"zIndex\")\n        return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value))\n        return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n        (complex.test(value) || value === \"0\") && // And it contains numbers and/or colors\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\n\nexport { isAnimatable };\n","import { time } from '../../frameloop/sync-time.mjs';\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass BaseAnimation {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }) {\n        // Track whether the animation has been stopped. Stopped animations won't restart.\n        this.isStopped = false;\n        this.hasAttemptedResolve = false;\n        this.createdAt = time.now();\n        this.options = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            ...options,\n        };\n        this.updateFinishedPromise();\n    }\n    /**\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there's a delay (main thread work) between the creation of\n     * the animation and the first commited frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n    calcStartTime() {\n        if (!this.resolvedAt)\n            return this.createdAt;\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n            ? this.resolvedAt\n            : this.createdAt;\n    }\n    /**\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\n     * this.resolved will synchronously flush all pending keyframe resolvers.\n     * This is a deoptimisation, but at its worst still batches read/writes.\n     */\n    get resolved() {\n        if (!this._resolved && !this.hasAttemptedResolve) {\n            flushKeyframeResolvers();\n        }\n        return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */\n    onKeyframesResolved(keyframes, finalKeyframe) {\n        this.resolvedAt = time.now();\n        this.hasAttemptedResolve = true;\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n            // Finish immediately\n            if (instantAnimationState.current || !delay) {\n                onUpdate &&\n                    onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.resolveFinishedPromise();\n                return;\n            }\n            // Finish after a delay\n            else {\n                this.options.duration = 0;\n            }\n        }\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n        if (resolvedAnimation === false)\n            return;\n        this._resolved = {\n            keyframes,\n            finalKeyframe,\n            ...resolvedAnimation,\n        };\n        this.onPostResolved();\n    }\n    onPostResolved() { }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.currentFinishedPromise.then(resolve, reject);\n    }\n    flatten() {\n        this.options.type = \"keyframes\";\n        this.options.ease = \"linear\";\n    }\n    updateFinishedPromise() {\n        this.currentFinishedPromise = new Promise((resolve) => {\n            this.resolveFinishedPromise = resolve;\n        });\n    }\n}\n\nexport { BaseAnimation };\n","import { isGenerator } from 'motion-dom';\nimport { warning } from 'motion-utils';\nimport { isAnimatable } from '../../utils/is-animatable.mjs';\n\nfunction hasKeyframesChanged(keyframes) {\n    const current = keyframes[0];\n    if (keyframes.length === 1)\n        return true;\n    for (let i = 0; i < keyframes.length; i++) {\n        if (keyframes[i] !== current)\n            return true;\n    }\n}\nfunction canAnimate(keyframes, name, type, velocity) {\n    /**\n     * Check if we're able to animate between the start and end keyframes,\n     * and throw a warning if we're attempting to animate between one that's\n     * animatable and another that isn't.\n     */\n    const originKeyframe = keyframes[0];\n    if (originKeyframe === null)\n        return false;\n    /**\n     * These aren't traditionally animatable but we do support them.\n     * In future we could look into making this more generic or replacing\n     * this function with mix() === mixImmediate\n     */\n    if (name === \"display\" || name === \"visibility\")\n        return true;\n    const targetKeyframe = keyframes[keyframes.length - 1];\n    const isOriginAnimatable = isAnimatable(originKeyframe, name);\n    const isTargetAnimatable = isAnimatable(targetKeyframe, name);\n    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n    // Always skip if any of these are true\n    if (!isOriginAnimatable || !isTargetAnimatable) {\n        return false;\n    }\n    return (hasKeyframesChanged(keyframes) ||\n        ((type === \"spring\" || isGenerator(type)) && velocity));\n}\n\nexport { canAnimate };\n","import { velocityPerSecond } from '../../../utils/velocity-per-second.mjs';\n\nconst velocitySampleDuration = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - velocitySampleDuration, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\nexport { calcGeneratorVelocity };\n","const springDefaults = {\n    // Default spring physics\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    velocity: 0.0,\n    // Default duration/bounce-based options\n    duration: 800, // in ms\n    bounce: 0.3,\n    visualDuration: 0.3, // in seconds\n    // Rest thresholds\n    restSpeed: {\n        granular: 0.01,\n        default: 2,\n    },\n    restDelta: {\n        granular: 0.005,\n        default: 0.5,\n    },\n    // Limits\n    minDuration: 0.01, // in seconds\n    maxDuration: 10.0, // in seconds\n    minDamping: 0.05,\n    maxDamping: 1,\n};\n\nexport { springDefaults };\n","import { warning, secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { springDefaults } from './defaults.mjs';\n\nconst safeMin = 0.001;\nfunction findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {\n    let envelope;\n    let derivative;\n    warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), \"Spring duration must be 10 seconds or less\");\n    let dampingRatio = 1 - bounce;\n    /**\n     * Restrict dampingRatio and duration to within acceptable ranges.\n     */\n    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);\n    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));\n    if (dampingRatio < 1) {\n        /**\n         * Underdamped spring\n         */\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        /**\n         * Critically-damped spring\n         */\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = secondsToMilliseconds(duration);\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: springDefaults.stiffness,\n            damping: springDefaults.damping,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nexport { calcAngularFreq, findSpring };\n","import { calcGeneratorDuration, maxGeneratorDuration, generateLinearEasing } from 'motion-dom';\nimport { millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { springDefaults } from './defaults.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: springDefaults.velocity,\n        stiffness: springDefaults.stiffness,\n        damping: springDefaults.damping,\n        mass: springDefaults.mass,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        if (options.visualDuration) {\n            const visualDuration = options.visualDuration;\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\n            const stiffness = root * root;\n            const damping = 2 *\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\n                Math.sqrt(stiffness);\n            springOptions = {\n                ...springOptions,\n                mass: springDefaults.mass,\n                stiffness,\n                damping,\n            };\n        }\n        else {\n            const derived = findSpring(options);\n            springOptions = {\n                ...springOptions,\n                ...derived,\n                mass: springDefaults.mass,\n            };\n            springOptions.isResolvedFromDuration = true;\n        }\n    }\n    return springOptions;\n}\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\n    const options = typeof optionsOrVisualDuration !== \"object\"\n        ? {\n            visualDuration: optionsOrVisualDuration,\n            keyframes: [0, 1],\n            bounce,\n        }\n        : optionsOrVisualDuration;\n    let { restSpeed, restDelta } = options;\n    const origin = options.keyframes[0];\n    const target = options.keyframes[options.keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0),\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale\n        ? springDefaults.restSpeed.granular\n        : springDefaults.restSpeed.default);\n    restDelta || (restDelta = isGranularScale\n        ? springDefaults.restDelta.granular\n        : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    const generator = {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = 0.0;\n                /**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can't overshoot, so\n                 * checking only for displacement is enough.\n                 */\n                if (dampingRatio < 1) {\n                    currentVelocity =\n                        t === 0\n                            ? secondsToMilliseconds(initialVelocity)\n                            : calcGeneratorVelocity(resolveSpring, t, current);\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        toString: () => {\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n            return calculatedDuration + \"ms \" + easing;\n        },\n    };\n    return generator;\n}\n\nexport { spring };\n","import { spring } from './spring/index.mjs';\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\nexport { inertia };\n","import { easeInOut } from '../../easing/ease.mjs';\nimport { isEasingArray } from '../../easing/utils/is-easing-array.mjs';\nimport { easingDefinitionToFunction } from '../../easing/utils/map.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { convertOffsetToTimes } from '../../utils/offsets/time.mjs';\n\nfunction defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = \"easeInOut\", }) {\n    /**\n     * Easing functions can be externally defined as strings. Here we convert them\n     * into actual functions.\n     */\n    const easingFunctions = isEasingArray(ease)\n        ? ease.map(easingDefinitionToFunction)\n        : easingDefinitionToFunction(ease);\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = {\n        done: false,\n        value: keyframeValues[0],\n    };\n    /**\n     * Create a times array based on the provided 0-1 offsets\n     */\n    const absoluteTimes = convertOffsetToTimes(\n    // Only use the provided offsets if they're the correct length\n    // TODO Maybe we should warn here if there's a length mismatch\n    times && times.length === keyframeValues.length\n        ? times\n        : defaultOffset(keyframeValues), duration);\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\n        ease: Array.isArray(easingFunctions)\n            ? easingFunctions\n            : defaultEasing(keyframeValues, easingFunctions),\n    });\n    return {\n        calculatedDuration: duration,\n        next: (t) => {\n            state.value = mapTimeToKeyframe(t);\n            state.done = t >= duration;\n            return state;\n        },\n    };\n}\n\nexport { defaultEasing, keyframes };\n","import { time } from '../../../frameloop/sync-time.mjs';\nimport { frame, cancelFrame, frameData } from '../../../frameloop/frame.mjs';\n\nconst frameloopDriver = (update) => {\n    const passTimestamp = ({ timestamp }) => update(timestamp);\n    return {\n        start: () => frame.update(passTimestamp, true),\n        stop: () => cancelFrame(passTimestamp),\n        /**\n         * If we're processing this frame we can use the\n         * framelocked timestamp to keep things in sync.\n         */\n        now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),\n    };\n};\n\nexport { frameloopDriver };\n","import { isGenerator, calcGeneratorDuration } from 'motion-dom';\nimport { invariant, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { mix } from '../../utils/mix/index.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { inertia } from '../generators/inertia.mjs';\nimport { keyframes } from '../generators/keyframes.mjs';\nimport { spring } from '../generators/spring/index.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\nconst generators = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\nconst percentToProgress = (percent) => percent / 100;\n/**\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\n * features we expose publically. Mostly the compatibility is to ensure visual identity\n * between both WAAPI and main thread animations.\n */\nclass MainThreadAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        /**\n         * The time at which the animation was paused.\n         */\n        this.holdTime = null;\n        /**\n         * The time at which the animation was cancelled.\n         */\n        this.cancelTime = null;\n        /**\n         * The current time of the animation.\n         */\n        this.currentTime = 0;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */\n        this.playbackSpeed = 1;\n        /**\n         * The state of the animation to apply when the animation is resolved. This\n         * allows calls to the public API to control the animation before it is resolved,\n         * without us having to resolve it first.\n         */\n        this.pendingPlayState = \"running\";\n        /**\n         * The time at which the animation was started.\n         */\n        this.startTime = null;\n        this.state = \"idle\";\n        /**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */\n        this.stop = () => {\n            this.resolver.cancel();\n            this.isStopped = true;\n            if (this.state === \"idle\")\n                return;\n            this.teardown();\n            const { onStop } = this.options;\n            onStop && onStop();\n        };\n        const { name, motionValue, element, keyframes } = this.options;\n        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\n        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n        this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    flatten() {\n        super.flatten();\n        // If we've already resolved the animation, re-initialise it\n        if (this._resolved) {\n            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));\n        }\n    }\n    initPlayback(keyframes$1) {\n        const { type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;\n        const generatorFactory = isGenerator(type)\n            ? type\n            : generators[type] || keyframes;\n        /**\n         * If our generator doesn't support mixing numbers, we need to replace keyframes with\n         * [0, 100] and then make a function that maps that to the actual keyframes.\n         *\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\n         */\n        let mapPercentToKeyframes;\n        let mirroredGenerator;\n        if (generatorFactory !== keyframes &&\n            typeof keyframes$1[0] !== \"number\") {\n            if (process.env.NODE_ENV !== \"production\") {\n                invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n            }\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [0, 100];\n        }\n        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === \"mirror\") {\n            mirroredGenerator = generatorFactory({\n                ...this.options,\n                keyframes: [...keyframes$1].reverse(),\n                velocity: -velocity,\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        const resolvedDuration = calculatedDuration + repeatDelay;\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n        return {\n            generator,\n            mirroredGenerator,\n            mapPercentToKeyframes,\n            calculatedDuration,\n            resolvedDuration,\n            totalDuration,\n        };\n    }\n    onPostResolved() {\n        const { autoplay = true } = this.options;\n        this.play();\n        if (this.pendingPlayState === \"paused\" || !autoplay) {\n            this.pause();\n        }\n        else {\n            this.state = this.pendingPlayState;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { resolved } = this;\n        // If the animations has failed to resolve, return the final keyframe.\n        if (!resolved) {\n            const { keyframes } = this.options;\n            return { done: true, value: keyframes[keyframes.length - 1] };\n        }\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;\n        if (this.startTime === null)\n            return generator.next(0);\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        }\n        else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        // Update currentTime\n        if (sample) {\n            this.currentTime = timestamp;\n        }\n        else if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime =\n                Math.round(timestamp - this.startTime) * this.speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.speed >= 0\n            ? timeWithoutDelay < 0\n            : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === \"finished\" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed);\n        if (mapPercentToKeyframes) {\n            state.value = mapPercentToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.speed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null &&\n            (this.state === \"finished\" || (this.state === \"running\" && done));\n        if (isAnimationFinished && finalKeyframe !== undefined) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    get duration() {\n        const { resolved } = this;\n        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\n    }\n    get time() {\n        return millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.holdTime !== null || this.speed === 0) {\n            this.holdTime = newTime;\n        }\n        else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.speed;\n        }\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (!this.resolver.isScheduled) {\n            this.resolver.resume();\n        }\n        if (!this._resolved) {\n            this.pendingPlayState = \"running\";\n            return;\n        }\n        if (this.isStopped)\n            return;\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp));\n        }\n        onPlay && onPlay();\n        const now = this.driver.now();\n        if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        }\n        else if (this.state === \"finished\") {\n            this.startTime = now;\n        }\n        if (this.state === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        this.cancelTime = this.startTime;\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        this.state = \"running\";\n        this.driver.start();\n    }\n    pause() {\n        var _a;\n        if (!this._resolved) {\n            this.pendingPlayState = \"paused\";\n            return;\n        }\n        this.state = \"paused\";\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n    }\n    complete() {\n        if (this.state !== \"running\") {\n            this.play();\n        }\n        this.pendingPlayState = this.state = \"finished\";\n        this.holdTime = null;\n    }\n    finish() {\n        this.teardown();\n        this.state = \"finished\";\n        const { onComplete } = this.options;\n        onComplete && onComplete();\n    }\n    cancel() {\n        if (this.cancelTime !== null) {\n            this.tick(this.cancelTime);\n        }\n        this.teardown();\n        this.updateFinishedPromise();\n    }\n    teardown() {\n        this.state = \"idle\";\n        this.stopDriver();\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        this.startTime = this.cancelTime = null;\n        this.resolver.cancel();\n    }\n    stopDriver() {\n        if (!this.driver)\n            return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(time) {\n        this.startTime = 0;\n        return this.tick(time, true);\n    }\n}\n// Legacy interface\nfunction animateValue(options) {\n    return new MainThreadAnimation(options);\n}\n\nexport { MainThreadAnimation, animateValue };\n","const isNotNull = (value) => value !== null;\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }, finalKeyframe) {\n    const resolvedKeyframes = keyframes.filter(isNotNull);\n    const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1\n        ? 0\n        : resolvedKeyframes.length - 1;\n    return !index || finalKeyframe === undefined\n        ? resolvedKeyframes[index]\n        : finalKeyframe;\n}\n\nexport { getFinalKeyframe };\n","/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\n    \"opacity\",\n    \"clipPath\",\n    \"filter\",\n    \"transform\",\n    // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\n    // or until we implement support for linear() easing.\n    // \"background-color\"\n]);\n\nexport { acceleratedValues };\n","import { memo } from 'motion-utils';\n\nconst supportsWaapi = /*@__PURE__*/ memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\n\nexport { supportsWaapi };\n","import { supportsLinearEasing, attachTimeline, isGenerator, isWaapiSupportedEasing } from 'motion-dom';\nimport { millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { anticipate } from '../../easing/anticipate.mjs';\nimport { backInOut } from '../../easing/back.mjs';\nimport { circInOut } from '../../easing/circ.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { acceleratedValues } from './utils/accelerated-values.mjs';\nimport { startWaapiAnimation } from './waapi/index.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nimport { supportsWaapi } from './waapi/utils/supports-waapi.mjs';\n\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\nfunction requiresPregeneratedKeyframes(options) {\n    return (isGenerator(options.type) ||\n        options.type === \"spring\" ||\n        !isWaapiSupportedEasing(options.ease));\n}\nfunction pregenerateKeyframes(keyframes, options) {\n    /**\n     * Create a main-thread animation to pregenerate keyframes.\n     * We sample this at regular intervals to generate keyframes that we then\n     * linearly interpolate between.\n     */\n    const sampleAnimation = new MainThreadAnimation({\n        ...options,\n        keyframes,\n        repeat: 0,\n        delay: 0,\n        isGenerator: true,\n    });\n    let state = { done: false, value: keyframes[0] };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\n     * we're heading for an infinite loop.\n     */\n    let t = 0;\n    while (!state.done && t < maxDuration) {\n        state = sampleAnimation.sample(t);\n        pregeneratedKeyframes.push(state.value);\n        t += sampleDelta;\n    }\n    return {\n        times: undefined,\n        keyframes: pregeneratedKeyframes,\n        duration: t - sampleDelta,\n        ease: \"linear\",\n    };\n}\nconst unsupportedEasingFunctions = {\n    anticipate,\n    backInOut,\n    circInOut,\n};\nfunction isUnsupportedEase(key) {\n    return key in unsupportedEasingFunctions;\n}\nclass AcceleratedAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        const { name, motionValue, element, keyframes } = this.options;\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes, finalKeyframe) {\n        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;\n        /**\n         * If element has since been unmounted, return false to indicate\n         * the animation failed to initialised.\n         */\n        if (!motionValue.owner || !motionValue.owner.current) {\n            return false;\n        }\n        /**\n         * If the user has provided an easing function name that isn't supported\n         * by WAAPI (like \"anticipate\"), we need to provide the corressponding\n         * function. This will later get converted to a linear() easing function.\n         */\n        if (typeof ease === \"string\" &&\n            supportsLinearEasing() &&\n            isUnsupportedEase(ease)) {\n            ease = unsupportedEasingFunctions[ease];\n        }\n        /**\n         * If this animation needs pre-generated keyframes then generate.\n         */\n        if (requiresPregeneratedKeyframes(this.options)) {\n            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n            keyframes = pregeneratedAnimation.keyframes;\n            // If this is a very short animation, ensure we have\n            // at least two keyframes to animate between as older browsers\n            // can't animate between a single keyframe.\n            if (keyframes.length === 1) {\n                keyframes[1] = keyframes[0];\n            }\n            duration = pregeneratedAnimation.duration;\n            times = pregeneratedAnimation.times;\n            ease = pregeneratedAnimation.ease;\n            type = \"keyframes\";\n        }\n        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\n        // Override the browser calculated startTime with one synchronised to other JS\n        // and WAAPI animations starting this event loop.\n        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        if (this.pendingTimeline) {\n            attachTimeline(animation, this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        }\n        else {\n            /**\n             * Prefer the `onfinish` prop as it's more widely supported than\n             * the `finished` promise.\n             *\n             * Here, we synchronously set the provided MotionValue to the end\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\n             * be removed from the element which would then revert to its old styles.\n             */\n            animation.onfinish = () => {\n                const { onComplete } = this.options;\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.cancel();\n                this.resolveFinishedPromise();\n            };\n        }\n        return {\n            animation,\n            duration,\n            times,\n            type,\n            ease,\n            keyframes: keyframes,\n        };\n    }\n    get duration() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { duration } = resolved;\n        return millisecondsToSeconds(duration);\n    }\n    get time() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { animation } = resolved;\n        return millisecondsToSeconds(animation.currentTime || 0);\n    }\n    set time(newTime) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    get speed() {\n        const { resolved } = this;\n        if (!resolved)\n            return 1;\n        const { animation } = resolved;\n        return animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.playbackRate = newSpeed;\n    }\n    get state() {\n        const { resolved } = this;\n        if (!resolved)\n            return \"idle\";\n        const { animation } = resolved;\n        return animation.playState;\n    }\n    get startTime() {\n        const { resolved } = this;\n        if (!resolved)\n            return null;\n        const { animation } = resolved;\n        // Coerce to number as TypeScript incorrectly types this\n        // as CSSNumberish\n        return animation.startTime;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n    attachTimeline(timeline) {\n        if (!this._resolved) {\n            this.pendingTimeline = timeline;\n        }\n        else {\n            const { resolved } = this;\n            if (!resolved)\n                return noop;\n            const { animation } = resolved;\n            attachTimeline(animation, timeline);\n        }\n        return noop;\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        if (animation.playState === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        animation.play();\n    }\n    pause() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.pause();\n    }\n    stop() {\n        this.resolver.cancel();\n        this.isStopped = true;\n        if (this.state === \"idle\")\n            return;\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation, keyframes, duration, type, ease, times } = resolved;\n        if (animation.playState === \"idle\" ||\n            animation.playState === \"finished\") {\n            return;\n        }\n        /**\n         * WAAPI doesn't natively have any interruption capabilities.\n         *\n         * Rather than read commited styles back out of the DOM, we can\n         * create a renderless JS animation and sample it twice to calculate\n         * its current value, \"previous\" value, and therefore allow\n         * Motion to calculate velocity for any subsequent animation.\n         */\n        if (this.time) {\n            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\n            const sampleAnimation = new MainThreadAnimation({\n                ...options,\n                keyframes,\n                duration,\n                type,\n                ease,\n                times,\n                isGenerator: true,\n            });\n            const sampleTime = secondsToMilliseconds(this.time);\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n        }\n        const { onStop } = this.options;\n        onStop && onStop();\n        this.cancel();\n    }\n    complete() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.finish();\n    }\n    cancel() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.cancel();\n    }\n    static supports(options) {\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n        if (!motionValue ||\n            !motionValue.owner ||\n            !(motionValue.owner.current instanceof HTMLElement)) {\n            return false;\n        }\n        const { onUpdate, transformTemplate } = motionValue.owner.getProps();\n        return (supportsWaapi() &&\n            name &&\n            acceleratedValues.has(name) &&\n            /**\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\n             * no way to read the value from WAAPI every frame.\n             */\n            !onUpdate &&\n            !transformTemplate &&\n            !repeatDelay &&\n            repeatType !== \"mirror\" &&\n            damping !== 0 &&\n            type !== \"inertia\");\n    }\n}\n\nexport { AcceleratedAnimation };\n","import { mapEasingToNativeEasing } from 'motion-dom';\n\nfunction startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = \"loop\", ease = \"easeInOut\", times, } = {}) {\n    const keyframeOptions = { [valueName]: keyframes };\n    if (times)\n        keyframeOptions.offset = times;\n    const easing = mapEasingToNativeEasing(ease, duration);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */\n    if (Array.isArray(easing))\n        keyframeOptions.easing = easing;\n    return element.animate(keyframeOptions, {\n        delay,\n        duration,\n        easing: !Array.isArray(easing) ? easing : \"linear\",\n        fill: \"both\",\n        iterations: repeat + 1,\n        direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\",\n    });\n}\n\nexport { startWaapiAnimation };\n","import { transformProps } from '../../render/html/utils/keys-transform.mjs';\n\nconst underDampedSpring = {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restSpeed: 10,\n};\nconst criticallyDampedSpring = (target) => ({\n    type: \"spring\",\n    stiffness: 550,\n    damping: target === 0 ? 2 * Math.sqrt(550) : 30,\n    restSpeed: 10,\n});\nconst keyframesTransition = {\n    type: \"keyframes\",\n    duration: 0.8,\n};\n/**\n * Default easing curve is a slightly shallower version of\n * the default browser easing curve.\n */\nconst ease = {\n    type: \"keyframes\",\n    ease: [0.25, 0.1, 0.35, 1],\n    duration: 0.3,\n};\nconst getDefaultTransition = (valueKey, { keyframes }) => {\n    if (keyframes.length > 2) {\n        return keyframesTransition;\n    }\n    else if (transformProps.has(valueKey)) {\n        return valueKey.startsWith(\"scale\")\n            ? criticallyDampedSpring(keyframes[1])\n            : underDampedSpring;\n    }\n    return ease;\n};\n\nexport { getDefaultTransition };\n","import { getValueTransition, GroupPlaybackControls } from 'motion-dom';\nimport { secondsToMilliseconds } from 'motion-utils';\nimport { frame } from '../../frameloop/frame.mjs';\nimport { MotionGlobalConfig } from '../../utils/GlobalConfig.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { AcceleratedAnimation } from '../animators/AcceleratedAnimation.mjs';\nimport { MainThreadAnimation } from '../animators/MainThreadAnimation.mjs';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    let options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: \"easeOut\",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n        },\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        options = {\n            ...options,\n            ...getDefaultTransition(name, options),\n        };\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    if (options.duration) {\n        options.duration = secondsToMilliseconds(options.duration);\n    }\n    if (options.repeatDelay) {\n        options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n    }\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        options.duration = 0;\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (instantAnimationState.current ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        options.duration = 0;\n        options.delay = 0;\n    }\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            // We still want to return some animation controls here rather\n            // than returning undefined\n            return new GroupPlaybackControls([]);\n        }\n    }\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\n        return new AcceleratedAnimation(options);\n    }\n    else {\n        return new MainThreadAnimation(options);\n    }\n};\n\nexport { animateMotionValue };\n","/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\n    return !!Object.keys(transition).length;\n}\n\nexport { isTransitionDefined };\n","import { getValueTransition } from 'motion-dom';\nimport { positionalKeys } from '../../render/html/utils/keys-position.mjs';\nimport { setTarget } from '../../render/utils/setters.mjs';\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\nimport { getOptimisedAppearId } from '../optimized-appear/get-appear-id.mjs';\nimport { animateMotionValue } from './motion-value.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\n\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\nfunction animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {\n    var _a;\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\n    if (transitionOverride)\n        transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type &&\n        visualElement.animationState &&\n        visualElement.animationState.getState()[type];\n    for (const key in target) {\n        const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);\n        const valueTarget = target[key];\n        if (valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        const valueTransition = {\n            delay,\n            ...getValueTransition(transition || {}, key),\n        };\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */\n        let isHandoff = false;\n        if (window.MotionHandoffAnimation) {\n            const appearId = getOptimisedAppearId(visualElement);\n            if (appearId) {\n                const startTime = window.MotionHandoffAnimation(appearId, key, frame);\n                if (startTime !== null) {\n                    valueTransition.startTime = startTime;\n                    isHandoff = true;\n                }\n            }\n        }\n        addValueToWillChange(visualElement, key);\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key)\n            ? { type: false }\n            : valueTransition, visualElement, isHandoff));\n        const animation = value.animation;\n        if (animation) {\n            animations.push(animation);\n        }\n    }\n    if (transitionEnd) {\n        Promise.all(animations).then(() => {\n            frame.update(() => {\n                transitionEnd && setTarget(visualElement, transitionEnd);\n            });\n        });\n    }\n    return animations;\n}\n\nexport { animateTarget };\n","import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\n\nfunction animateVariant(visualElement, variant, options = {}) {\n    var _a;\n    const resolved = resolveVariant(visualElement, variant, options.type === \"exit\"\n        ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\n        : undefined);\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getAnimation = resolved\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\n        : () => Promise.resolve();\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size\n        ? (forwardDelay = 0) => {\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : () => Promise.resolve();\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    const { when } = transition;\n    if (when) {\n        const [first, last] = when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation];\n        return first().then(() => last());\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n    const animations = [];\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    const generateStaggerDuration = staggerDirection === 1\n        ? (i = 0) => i * staggerChildren\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach((child, i) => {\n        child.notify(\"AnimationStart\", variant);\n        animations.push(animateVariant(child, variant, {\n            ...options,\n            delay: delayChildren + generateStaggerDuration(i),\n        }).then(() => child.notify(\"AnimationComplete\", variant)));\n    });\n    return Promise.all(animations);\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n\nexport { animateVariant, sortByTreeOrder };\n","import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\nimport { animateVariant } from './visual-element-variant.mjs';\n\nfunction animateVisualElement(visualElement, definition, options = {}) {\n    visualElement.notify(\"AnimationStart\", definition);\n    let animation;\n    if (Array.isArray(definition)) {\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        const resolvedDefinition = typeof definition === \"function\"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));\n    }\n    return animation.then(() => {\n        visualElement.notify(\"AnimationComplete\", definition);\n    });\n}\n\nexport { animateVisualElement };\n","import { camelToDash } from '../../render/dom/utils/camel-to-dash.mjs';\n\nconst optimizedAppearDataId = \"framerAppearId\";\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\n\nexport { optimizedAppearDataAttribute, optimizedAppearDataId };\n","import { optimizedAppearDataAttribute } from './data-id.mjs';\n\nfunction getOptimisedAppearId(visualElement) {\n    return visualElement.props[optimizedAppearDataAttribute];\n}\n\nexport { getOptimisedAppearId };\n","function isAnimationControls(v) {\n    return (v !== null &&\n        typeof v === \"object\" &&\n        typeof v.start === \"function\");\n}\n\nexport { isAnimationControls };\n","const isKeyframesTarget = (v) => {\n    return Array.isArray(v);\n};\n\nexport { isKeyframesTarget };\n","import { isZeroValueString } from '../../utils/is-zero-value-string.mjs';\n\nfunction isNone(value) {\n    if (typeof value === \"number\") {\n        return value === 0;\n    }\n    else if (value !== null) {\n        return value === \"none\" || value === \"0\" || isZeroValueString(value);\n    }\n    else {\n        return true;\n    }\n}\n\nexport { isNone };\n","import { useContext, useId, useEffect, useCallback } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nfunction usePresence(subscribe = true) {\n    const context = useContext(PresenceContext);\n    if (context === null)\n        return [true, null];\n    const { isPresent, onExitComplete, register } = context;\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n    const id = useId();\n    useEffect(() => {\n        if (subscribe)\n            register(id);\n    }, [subscribe]);\n    const safeToRemove = useCallback(() => subscribe && onExitComplete && onExitComplete(id), [id, onExitComplete, subscribe]);\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\nfunction useIsPresent() {\n    return isPresent(useContext(PresenceContext));\n}\nfunction isPresent(context) {\n    return context === null ? true : context.isPresent;\n}\n\nexport { isPresent, useIsPresent, usePresence };\n","\"use client\";\nimport { createContext } from 'react';\n\nconst LayoutGroupContext = createContext({});\n\nexport { LayoutGroupContext };\n","\"use client\";\nimport { createContext } from 'react';\n\nconst LazyContext = createContext({ strict: false });\n\nexport { LazyContext };\n","\"use client\";\nimport { createContext } from 'react';\n\n/**\n * @public\n */\nconst MotionConfigContext = createContext({\n    transformPagePoint: (p) => p,\n    isStatic: false,\n    reducedMotion: \"never\",\n});\n\nexport { MotionConfigContext };\n","import { useContext, useMemo } from 'react';\nimport { MotionContext } from './index.mjs';\nimport { getCurrentTreeVariants } from './utils.mjs';\n\nfunction useCreateMotionContext(props) {\n    const { initial, animate } = getCurrentTreeVariants(props, useContext(MotionContext));\n    return useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\nexport { useCreateMotionContext };\n","import { isVariantLabel } from '../../render/utils/is-variant-label.mjs';\nimport { isControllingVariants } from '../../render/utils/is-controlling-variants.mjs';\n\nfunction getCurrentTreeVariants(props, context) {\n    if (isControllingVariants(props)) {\n        const { initial, animate } = props;\n        return {\n            initial: initial === false || isVariantLabel(initial)\n                ? initial\n                : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined,\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\n\nexport { getCurrentTreeVariants };\n","\"use client\";\nimport { createContext } from 'react';\n\nconst MotionContext = createContext({});\n\nexport { MotionContext };\n","\"use client\";\nimport { createContext } from 'react';\n\n/**\n * @public\n */\nconst PresenceContext = createContext(null);\n\nexport { PresenceContext };\n","\"use client\";\nimport { createContext } from 'react';\n\n/**\n * Internal, exported only for usage in Framer\n */\nconst SwitchLayoutGroupContext = createContext({});\n\nexport { SwitchLayoutGroupContext };\n"],"names":["animateSingleValue","value","keyframes","options","motionValue$1","start","animation","isAnimatable","name","Array","isArray","complex","test","startsWith","BaseAnimation","constructor","autoplay","delay","type","repeat","repeatDelay","repeatType","this","isStopped","hasAttemptedResolve","createdAt","now","updateFinishedPromise","calcStartTime","resolvedAt","resolved","_resolved","onKeyframesResolved","finalKeyframe","velocity","onComplete","onUpdate","isGenerator","originKeyframe","targetKeyframe","length","isOriginAnimatable","isTargetAnimatable","current","i","hasKeyframesChanged","canAnimate","resolveFinishedPromise","duration","resolvedAnimation","initPlayback","onPostResolved","then","resolve","reject","currentFinishedPromise","flatten","ease","Promise","calcGeneratorVelocity","resolveValue","t","prevT","Math","max","springDefaults","granular","default","safeMin","findSpring","bounce","mass","envelope","derivative","dampingRatio","clamp","undampedFreq","exponentialDecay","delta","a","b","calcAngularFreq","c","exp","d","e","pow","f","g","initialGuess","result","rootIterations","approximateRoot","isNaN","stiffness","damping","sqrt","durationKeys","physicsKeys","isSpringType","keys","some","key","undefined","spring","optionsOrVisualDuration","visualDuration","restSpeed","restDelta","origin","target","state","done","isResolvedFromDuration","springOptions","root","PI","derived","getSpringOptions","initialVelocity","initialDelta","undampedAngularFreq","isGranularScale","abs","resolveSpring","angularFreq","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","generator","calculatedDuration","next","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","toString","easing","progress","inertia","power","timeConstant","bounceDamping","bounceStiffness","modifyTarget","nearestBoundary","v","amplitude","ideal","calcDelta","calcLatest","applyFriction","latest","timeReachedBoundary","spring$1","checkCatchBoundary","hasUpdatedFrame","defaultEasing","values","map","splice","keyframeValues","times","easingFunctions","absoluteTimes","mapTimeToKeyframe","interpolate","frameloopDriver","update","passTimestamp","timestamp","stop","isProcessing","generators","decay","tween","percentToProgress","percent","MainThreadAnimation","super","holdTime","cancelTime","currentTime","playbackSpeed","pendingPlayState","startTime","resolver","cancel","teardown","onStop","motionValue","element","KeyframeResolver$1","KeyframeResolver","resolvedKeyframes","scheduleResolve","Object","assign","keyframes$1","generatorFactory","mapPercentToKeyframes","mirroredGenerator","pipe","mix","reverse","resolvedDuration","totalDuration","play","pause","tick","sample","speed","round","timeWithoutDelay","isInDelayPhase","elapsed","frameGenerator","currentIteration","floor","iterationProgress","Boolean","isAnimationFinished","finish","time","newTime","driver","newSpeed","hasChanged","isScheduled","resume","onPlay","_a","complete","stopDriver","animateValue","isNotNull","getFinalKeyframe","filter","index","acceleratedValues","Set","supportsWaapi","hasOwnProperty","call","Element","prototype","unsupportedEasingFunctions","anticipate","backInOut","circInOut","AcceleratedAnimation","DOMKeyframesResolver","owner","pregeneratedAnimation","sampleAnimation","pregeneratedKeyframes","push","pregenerateKeyframes","valueName","keyframeOptions","offset","animate","fill","iterations","direction","startWaapiAnimation","pendingTimeline","onfinish","set","playbackRate","playState","attachTimeline","timeline","noop","sampleTime","setWithVelocity","supports","HTMLElement","transformTemplate","getProps","has","underDampedSpring","keyframesTransition","getDefaultTransition","valueKey","animateMotionValue","transition","isHandoff","valueTransition","getVelocity","when","_delay","delayChildren","staggerChildren","staggerDirection","from","isTransitionDefined","shouldSkip","skipAnimations","get","shouldBlockAnimation","protectedKeys","needsAnimating","shouldBlock","animateTarget","visualElement","targetAndTransition","transitionOverride","transitionEnd","animations","animationTypeState","animationState","getState","getValue","latestValues","valueTarget","window","MotionHandoffAnimation","appearId","shouldReduceMotion","all","animateVariant","variant","presenceContext","custom","getAnimation","getChildAnimations","variantChildren","size","forwardDelay","maxStaggerDuration","generateStaggerDuration","sort","sortByTreeOrder","forEach","child","notify","animateChildren","first","last","sortNodePosition","animateVisualElement","definition","resolvedDefinition","optimizedAppearDataAttribute","getOptimisedAppearId","props","isAnimationControls","isKeyframesTarget","isNone","usePresence","subscribe","context","useContext","isPresent","onExitComplete","register","id","useId","useEffect","safeToRemove","useCallback","LayoutGroupContext","createContext","LazyContext","strict","MotionConfigContext","transformPagePoint","p","isStatic","reducedMotion","useCreateMotionContext","initial","inherit","getCurrentTreeVariants","MotionContext","useMemo","variantLabelsAsDependency","prop","join","PresenceContext","SwitchLayoutGroupContext"],"sourceRoot":""}